--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -17,15 +17,20 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.text.DecimalFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -37,10 +42,39 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
 import javax.imageio.ImageIO;
+
+import com.mtbs3d.minecrift.api.IBodyAimController;
+import com.mtbs3d.minecrift.api.IEyePositionProvider;
+import com.mtbs3d.minecrift.api.IHMDInfo;
+import com.mtbs3d.minecrift.api.IOrientationProvider;
+import com.mtbs3d.minecrift.api.IStereoProvider;
+import com.mtbs3d.minecrift.api.PluginManager;
+import com.mtbs3d.minecrift.control.ControlBinding;
+import com.mtbs3d.minecrift.control.JoystickAim;
+import com.mtbs3d.minecrift.provider.MCController;
+import com.mtbs3d.minecrift.provider.MCMouse;
+import com.mtbs3d.minecrift.provider.MCOculus;
+import com.mtbs3d.minecrift.provider.NullEyePosition;
+import com.mtbs3d.minecrift.provider.NullStereoRenderer;
+import com.mtbs3d.minecrift.render.FBOParams;
+import com.mtbs3d.minecrift.render.ShaderHelper;
+import com.mtbs3d.minecrift.settings.VRHotkeys;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import de.fruitfly.ovr.EyeRenderParams;
+import de.fruitfly.ovr.OculusRift;
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.FovPort;
+import de.fruitfly.ovr.structs.FovTextureInfo;
+import de.fruitfly.ovr.structs.FrameTiming;
+import de.fruitfly.ovr.structs.GLConfig;
+import de.fruitfly.ovr.structs.Posef;
+import de.fruitfly.ovr.structs.Sizei;
+import net.aib42.mumblelink.MumbleLink;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
@@ -107,6 +141,7 @@
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.stream.IStream;
 import net.minecraft.client.stream.NullStream;
 import net.minecraft.client.stream.TwitchStream;
@@ -141,6 +176,7 @@
 import net.minecraft.profiler.Profiler;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
+import net.minecraft.src.Config;
 import net.minecraft.stats.AchievementList;
 import net.minecraft.stats.IStatStringFormat;
 import net.minecraft.stats.StatFileWriter;
@@ -159,6 +195,7 @@
 import net.minecraft.util.Session;
 import net.minecraft.util.Timer;
 import net.minecraft.util.Util;
+import net.minecraft.util.Vec3;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldProviderHell;
@@ -171,19 +208,25 @@
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
+import org.lwjgl.LWJGLUtil;
 import org.lwjgl.Sys;
+import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
+import org.lwjgl.opengl.ARBShaderObjects;
 import org.lwjgl.opengl.ContextCapabilities;
 import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.DisplayMode;
 import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
 import org.lwjgl.opengl.GL20;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.opengl.OpenGLException;
 import org.lwjgl.opengl.PixelFormat;
 import org.lwjgl.util.glu.GLU;
+import org.lwjgl.util.vector.Quaternion;
 
 public class Minecraft implements IThreadListener, IPlayerUsage
 {
@@ -200,8 +243,9 @@
     private ServerData currentServerData;
 
     /** The RenderEngine instance used by Minecraft */
-    private TextureManager renderEngine;
-
+    /** MINECRIFT */
+    public TextureManager renderEngine;
+    /** END MINECRIFT */
     /**
      * Set to 'this' in Minecraft constructor; used by some settings get methods
      */
@@ -315,7 +359,9 @@
     private IStream stream;
     private Framebuffer framebufferMc;
     private TextureMap textureMapBlocks;
-    private SoundHandler mcSoundHandler;
+    /** MINECRIFT */
+    public  SoundHandler mcSoundHandler; 
+    /** END MINECRIFT */
     private MusicTicker mcMusicTicker;
     private ResourceLocation mojangLogo;
     private final MinecraftSessionService sessionService;
@@ -349,8 +395,96 @@
     private String debugProfilerName = "root";
     private static final String __OBFID = "CL_00000631";
 
+    /** MINECRIFT */
+    public final float PIOVER180 = (float)(Math.PI/180);
+    public boolean reinitFramebuffers = true;
+    public Framebuffer[] framebuffers = new Framebuffer[2];
+    public Framebuffer guiFramebuffer = null;
+    public int lastDisplayFBWidth = 0;
+    public int lastDisplayFBHeight = 0;
+    public int displayFBWidth;     /* Actual width of the display buffer */
+    public int displayFBHeight;    /* Actual height of the display buffer */
+    public int viewPortCount = 2;
+    public ShaderGroup[] shaderGroup = new ShaderGroup[2];
+    public int lastShaderIndex = -1;
+    public Object displayImpl = null;
+    public Field fieldHwnd = null;
+    public Field fieldDisplay = null;
+    public Field fieldWindow = null;
+    public Field fieldResized = null;
+    public Method fieldResizedMethod = null;
+    public IHMDInfo hmdInfo;
+    public IStereoProvider stereoProvider;
+    public IOrientationProvider headTracker;
+    public IEyePositionProvider positionTracker;
+    public IBodyAimController lookaimController;
+    public VRSettings vrSettings;
+    public MumbleLink mumbleLink;
+    public long lastIntegratedServerLaunchCheck = 0;
+    public boolean integratedServerLaunchInProgress = false;
+    public boolean resetMouse = false;
+    public boolean lastEnableVsync = true;
+    public EyeRenderParams eyeRenderParams = null;
+    public EyeType currentEye = EyeType.ovrEye_Left;
+    public Posef currentPose = null;
+    public Cursor nativeMouseCursor = null;
+    public boolean lastShowMouseNative = true;
+    public Cursor invisibleMouseCursor = null;
+    public GLConfig glConfig = new GLConfig();
+    public long lastWindow = 0;
+    public int lastRenderDistanceChunks = -1;
+    public boolean lastFogFancy = true;
+    public boolean lastFogFast = false;
+    public int lastDimensionId = -1;
+    public SoundManager sndManager = null;
+    public Sizei[] EyeTextureSize = new Sizei[2];
+    public boolean hydraLibsAvailable = false;
+    public FrameTiming frameTiming = new FrameTiming();
+    public int _Lanczos_shaderProgramId = -1;
+    public int _LanczosShader_texelWidthOffsetUniform = -1;
+    public int _LanczosShader_texelHeightOffsetUniform = -1;
+    public int _LanczosShader_inputImageTextureUniform = -1;
+    public FBOParams[] fsaaFirstPassResultFBO = new FBOParams[2];
+    public FBOParams[] fsaaSecondPassResultFBO = new FBOParams[2];
+    public Sizei[] distortionRenderTargetSize = new Sizei[2];
+    public final float OCULUS_RED_COLOUR_COMPONENT = (1f/255f)*61f;
+    public final float OCULUS_GREEN_COLOUR_COMPONENT = (1f/255f)*61f;
+    public final float OCULUS_BLUE_COLOUR_COMPONENT = (1f/255f)*61f;
+    public float RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+    public float GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+    public float BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+    public Sizei initialResolution = new Sizei();
+    public boolean isDirectMode = false;
+    public boolean firstInit = true;
+    public boolean showSplashScreen = true;
+    public boolean showSplash1 = true;
+    public boolean showSplash2 = false;
+    public long splashTimer1 = 0;
+    public long splashTimer2 = 0;
+    public Framebuffer splash;
+    public float splashFadeAlpha = 0;
+    public int lastGuiScale = -1;
+    public boolean reloadShaders = true;
+    public long runTickTimeNanos = 0;
+    public Deque<Long> runTickTimeNanoDeque = new ArrayDeque<Long>();
+    public long medianRunTickTimeNanos = 0;
+    public boolean canPrintFrameDebug = false;
+    public int debugFrameCounter = 0;
+    public long frameIndex = 0;
+
+    public final String minecriftVerString = "Minecrift 1.8.1 PRE2";
+    /** END MINECRIFT */
+
     public Minecraft(GameConfiguration p_i45547_1_)
     {
+        /** MINECRIFT */
+        initialResolution = new Sizei(p_i45547_1_.field_178743_b.field_178764_a, p_i45547_1_.field_178743_b.field_178762_b);
+        minecriftFirstInit();
+        this.tempDisplayWidth = this.displayWidth = initialResolution.w > 0 ? initialResolution.w : 1;
+        this.tempDisplayHeight = this.displayHeight = initialResolution.h > 0 ? initialResolution.h : 1;
+        this.fullscreen = isDirectMode ? false : p_i45547_1_.field_178743_b.field_178763_c;
+        /** END MINECRIFT */
+
         theMinecraft = this;
         this.mcDataDir = p_i45547_1_.field_178744_c.field_178760_a;
         this.fileAssets = p_i45547_1_.field_178744_c.field_178759_c;
@@ -365,11 +499,13 @@
         logger.info("Setting user: " + this.session.getUsername());
         logger.info("(Session ID is " + this.session.getSessionID() + ")");
         this.isDemo = p_i45547_1_.field_178741_d.field_178756_a;
-        this.displayWidth = p_i45547_1_.field_178743_b.field_178764_a > 0 ? p_i45547_1_.field_178743_b.field_178764_a : 1;
-        this.displayHeight = p_i45547_1_.field_178743_b.field_178762_b > 0 ? p_i45547_1_.field_178743_b.field_178762_b : 1;
-        this.tempDisplayWidth = p_i45547_1_.field_178743_b.field_178764_a;
-        this.tempDisplayHeight = p_i45547_1_.field_178743_b.field_178762_b;
-        this.fullscreen = p_i45547_1_.field_178743_b.field_178763_c;
+        /** MINECRIFT */
+        //this.displayWidth = initialResolution.w > 0 ? initialResolution.w : 1;
+        //this.displayHeight = p_i45547_1_.field_178743_b.field_178762_b > 0 ? p_i45547_1_.field_178743_b.field_178762_b : 1;
+        //this.tempDisplayWidth = initialResolution.w;
+        //this.tempDisplayHeight = p_i45547_1_.field_178743_b.field_178762_b;
+        //this.fullscreen = p_i45547_1_.field_178743_b.field_178763_c;
+        /** END MINECRIFT */
         this.jvm64bit = isJvm64bit();
         this.theIntegratedServer = new IntegratedServer(this);
 
@@ -497,7 +633,9 @@
             this.fontRendererObj.setUnicodeFlag(this.isUnicode());
             this.fontRendererObj.setBidiFlag(this.mcLanguageManager.isCurrentLanguageBidirectional());
         }
-
+        /** MINECRIFT */
+        initMinecrift();
+        /** END MINECRIFT */
         this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii_sga.png"), this.renderEngine, false);
         this.mcResourceManager.registerReloadListener(this.fontRendererObj);
         this.mcResourceManager.registerReloadListener(this.standardGalacticFontRenderer);
@@ -575,7 +713,9 @@
 
         try
         {
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
+            /** MINECRIFT */
+            Display.setVSyncEnabled(true); 
+            /** END MINECRIFT */
         }
         catch (OpenGLException var2)
         {
@@ -611,7 +751,9 @@
     private void func_175609_am() throws LWJGLException
     {
         Display.setResizable(true);
-        Display.setTitle("Minecraft 1.8.1");
+        /** MINECRIFT */
+        Display.setTitle(this.minecriftVerString + " VR");
+        /** END MINECRIFT */
 
         try
         {
@@ -901,22 +1043,22 @@
         GlStateManager.disableDepth();
         GlStateManager.func_179098_w();
         InputStream var5 = null;
-
-        try
-        {
-            var5 = this.mcDefaultResourcePack.getInputStream(locationMojangPng);
-            this.mojangLogo = p_180510_1_.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(var5)));
-            p_180510_1_.bindTexture(this.mojangLogo);
-        }
-        catch (IOException var12)
-        {
-            logger.error("Unable to load logo: " + locationMojangPng, var12);
-        }
-        finally
-        {
-            IOUtils.closeQuietly(var5);
-        }
-
+        /** MINECRIFT */
+//        try
+//        {
+//            var5 = this.mcDefaultResourcePack.getInputStream(locationMojangPng);
+//            this.mojangLogo = p_180510_1_.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(var5)));
+//            p_180510_1_.bindTexture(this.mojangLogo);
+//        }
+//        catch (IOException var12)
+//        {
+//            logger.error("Unable to load logo: " + locationMojangPng, var12);
+//        }
+//        finally
+//        {
+//            IOUtils.closeQuietly(var5);
+//        }
+        /** END MINECRIFT */
         Tessellator var6 = Tessellator.getInstance();
         WorldRenderer var7 = var6.getWorldRenderer();
         var7.startDrawingQuads();
@@ -937,6 +1079,9 @@
         var4.framebufferRender(var2.getScaledWidth() * var3, var2.getScaledHeight() * var3);
         GlStateManager.enableAlpha();
         GlStateManager.alphaFunc(516, 0.1F);
+        /** MINECRIFT */
+        Display.update();
+        /** END MINECRIFT */
         this.func_175601_h();
     }
 
@@ -994,7 +1139,11 @@
         if (guiScreenIn != null)
         {
             this.setIngameNotInFocus();
-            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+            /** MINECRIFT */      // Can be called from network packet handlers! initGui() in currentScreen is a good place to check
+                                  // the call stack if windows are displayed with wrong offset / size etc. Debugging can cause
+                                  // position to change however!
+            ScaledResolution var2 = new ScaledResolution(this, this.displayFBWidth, this.displayFBHeight);
+            /** END MINECRIFT */
             int var3 = var2.getScaledWidth();
             int var4 = var2.getScaledHeight();
             ((GuiScreen)guiScreenIn).setWorldAndResolution(this, var3, var4);
@@ -1010,7 +1159,9 @@
     /**
      * Checks for an OpenGL error. If there is one, prints the error ID and error string.
      */
-    private void checkGLError(String message)
+    /** MINECRIFT */
+    public void checkGLError(String message)
+    /** END MINECRIFT */
     {
         if (this.field_175619_R)
         {
@@ -1066,6 +1217,13 @@
      */
     private void runGameLoop() throws IOException
     {
+		/** MINECRIFT */
+        setFrameDebugCounter();
+        this.frameIndex++;
+
+        long eyeRender1 = 0, eyeRender2 = 0, totalframe1Time = 0, totalframe2Time = 0;
+        long gameLoopStart = System.nanoTime();
+		/** END MINECRIFT */
         this.mcProfiler.startSection("root");
 
         if (Display.isCreated() && Display.isCloseRequested())
@@ -1073,6 +1231,9 @@
             this.shutdown();
         }
 
+        /** MINECRIFT */ // setup the display, render buffers, shaders etc.
+        setupRenderConfiguration();
+        /** END MINECRIFT */
         if (this.isGamePaused && this.theWorld != null)
         {
             float var1 = this.timer.renderPartialTicks;
@@ -1096,81 +1257,188 @@
         }
 
         this.mcProfiler.endSection();
+        /** MINECRIFT */
         long var7 = System.nanoTime();
-        this.mcProfiler.startSection("tick");
+        int ticks = 0;
 
-        for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
-        {
-            this.runTick();
-        }
+        if (!this.integratedServerLaunchInProgress)
+		{
+            this.mcProfiler.startSection("tick");
+
+            int currentDisplayWidth = this.displayWidth;
+            int currentDisplayHeight = this.displayHeight;
+
+            // Hack the GUI w & h
+            this.displayWidth = this.displayFBWidth;
+            this.displayHeight = this.displayFBHeight;
+
+            for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
+            {
+                this.runTick();
+                ticks++;
+            }
+
+            this.displayWidth = currentDisplayWidth;
+            this.displayHeight = currentDisplayHeight;
+
+            runTickTimeNanos = System.nanoTime() - var7;
+
+            // Test to see if render config change is requested. If so,
+            // update framebuffers
+            setupRenderConfiguration();
+        }
+//
+//        if (vrSettings.smoothTick) {
+//            if (ticks > 0) {
+//                addRunTickTimeNanos(runTickTimeNanos / ticks);
+//            } else {
+//                long sleepTimeNanos = getMedianRunTickTimeNanos();
+//                sleepNanos(sleepTimeNanos);
+//            }
+//        }
+//        else {
+//            runTickTimeNanos = System.nanoTime() - var7;
+//        }
 
         this.mcProfiler.endStartSection("preRenderErrors");
-        long var8 = System.nanoTime() - var7;
-        this.checkGLError("Pre render");
+        //long var8 = System.nanoTime() - var7;
+        //this.checkGLError("Pre render");
         this.mcProfiler.endStartSection("sound");
         this.mcSoundHandler.setListener(this.thePlayer, this.timer.renderPartialTicks);
         this.mcProfiler.endSection();
         this.mcProfiler.startSection("render");
-        GlStateManager.pushMatrix();
-        GlStateManager.clear(16640);
-        this.framebufferMc.bindFramebuffer(true);
-        this.mcProfiler.startSection("display");
-        GlStateManager.func_179098_w();
 
-        if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
+        // Render GUI to FBO if necessary
+        this.entityRenderer.renderVrGui(this.timer.renderPartialTicks);
+
+        // Now pad time - target 2ms for total pre render.
+        long endPreRender = System.nanoTime() - gameLoopStart;
+        if (endPreRender < 2000000)
         {
-            this.gameSettings.thirdPersonView = 0;
+            long preDiff = 2000000 - endPreRender;
+            //Thread.yield();
+            //sleepNanos(preDiff);
         }
 
-        this.mcProfiler.endSection();
+        PluginManager.beginFrameAll();
+        long preRender = System.nanoTime() - gameLoopStart;
+        long startRender = System.nanoTime();
+        long startEye2 = 0, startEnd = 0;
 
-        if (!this.skipRenderWorld)
+        // Mark beginning of frame AFTER any GUI rendering to allow maximum
+        // latency reduction
+        frameTiming = this.stereoProvider.getFrameTiming();
+
+        /** Minecrift - main stereo render loop **/
+        
+        for (int i = 0; i < viewPortCount; i++)
         {
-            this.mcProfiler.endStartSection("gameRenderer");
-            this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
+            this.currentEye = this.stereoProvider.eyeRenderOrder(i);
+
+            this.framebufferMc = framebuffers[this.currentEye.value()];
+            this.framebufferMc.bindFramebuffer(true);
+
+            if (this.entityRenderer != null)
+            {
+                this.entityRenderer.renderpass = i;
+                this.entityRenderer.theShaderGroup = shaderGroup[this.currentEye.value()];
+            }
+
+            this.displayWidth = this.EyeTextureSize[this.currentEye.value()].w;
+            this.displayHeight = this.EyeTextureSize[this.currentEye.value()].h;
+
+            currentPose = getEyePose(this.currentEye);
+
+            GlStateManager.pushMatrix();
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);     // GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT)?
+            //this.mcFramebuffer.bindFramebuffer(true);
+            this.mcProfiler.startSection("display");
+            GlStateManager.func_179098_w();   // GL11.glEnable(GL11.GL_TEXTURE_2D)?
+
+            if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
+            {
+                this.gameSettings.thirdPersonView = 0;
+            }
+
             this.mcProfiler.endSection();
-        }
 
-        this.mcProfiler.endSection();
+            // Update our orientation and position variables from the sensor polled data
+            this.entityRenderer.updatePositionAndOrientation(this.timer.renderPartialTicks, Display.isActive());
 
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
-        {
-            if (!this.mcProfiler.profilingEnabled)
+            if (!this.skipRenderWorld)
             {
-                this.mcProfiler.clearProfiling();
+                this.mcProfiler.endStartSection("gameRenderer");
+                this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
+                this.mcProfiler.endSection();
             }
 
-            this.mcProfiler.profilingEnabled = true;
-            this.displayDebugInfo(var8);
-        }
-        else
-        {
-            this.mcProfiler.profilingEnabled = false;
-            this.prevFrameTime = System.nanoTime();
-        }
+            //this.mcProfiler.endSection();
 
-        this.guiAchievement.updateAchievementWindow();
-        this.framebufferMc.unbindFramebuffer();
-        GlStateManager.popMatrix();
-        GlStateManager.pushMatrix();
-        this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
-        GlStateManager.popMatrix();
-        GlStateManager.pushMatrix();
-        this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);
-        GlStateManager.popMatrix();
-        this.mcProfiler.startSection("root");
-        this.func_175601_h();
-        Thread.yield();
-        this.mcProfiler.startSection("stream");
-        this.mcProfiler.startSection("update");
-        this.stream.func_152935_j();
-        this.mcProfiler.endStartSection("submit");
-        this.stream.func_152922_k();
-        this.mcProfiler.endSection();
-        this.mcProfiler.endSection();
-        this.checkGLError("Post render");
+            if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
+            {
+                if (!this.mcProfiler.profilingEnabled)
+                {
+                    this.mcProfiler.clearProfiling();
+                }
+
+                this.mcProfiler.profilingEnabled = true;
+                if (this.stereoProvider.isGuiOrtho())
+                    this.displayDebugInfo(runTickTimeNanos);      // Only call here if ortho gui
+            }
+            else
+            {
+                this.mcProfiler.profilingEnabled = false;
+                this.prevFrameTime = System.nanoTime();
+            }
+
+            //this.guiAchievement.func_146254_a();  // <-- TODO: Move; needs to be overlayed over GUI FBO
+            //this.mcFramebuffer.unbindFramebuffer();
+            GlStateManager.popMatrix();
+            GlStateManager.pushMatrix();
+            //this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+
+            doPostProcessing(this.currentEye);
+
+            GlStateManager.popMatrix();
+            GlStateManager.pushMatrix();
+            //this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);   // <-- TODO: What does this do? Some sort of stream status overlay? REENABLE, move to GUI FBO?
+            GlStateManager.popMatrix();
+//            if (i == 0) {
+//                totalframe1Time = System.nanoTime() - startRender;
+//                eyeRender1 = System.nanoTime() - startRender;
+//                startEye2 = System.nanoTime();
+//            }
+//            else {
+//                totalframe2Time = System.nanoTime() - startEye2;
+//                if (totalframe1Time > totalframe2Time)
+//                {
+//                    long diff = totalframe1Time - totalframe2Time;
+//                    //Thread.yield();
+//                    //sleepNanos(diff);
+//                    totalframe2Time = System.nanoTime() - startEye2;
+//                }
+//                startEnd = System.nanoTime();
+//                eyeRender2 = startEnd - startEye2;
+//            }
+        }
+
+        endFrame();
+        long endFrame = System.nanoTime() - startEnd;
+
+        //this.checkGLError("endFrame");
+        //this.mcProfiler.startSection("root");
+        //this.func_175601_h();     // Now handled in setup setupRenderConfiguration
+        //this.mcProfiler.startSection("stream");
+        //this.mcProfiler.startSection("update");
+        //this.stream.func_152935_j();
+        //this.mcProfiler.endStartSection("submit");
+        //this.stream.func_152922_k();
+        //this.mcProfiler.endSection();
+        //this.mcProfiler.endSection();
+        //this.checkGLError("Post render");
         ++this.fpsCounter;
         this.isGamePaused = this.isSingleplayer() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame() && !this.theIntegratedServer.getPublic();
+/** END MINECRIFT */		
 
         while (getSystemTime() >= this.debugUpdateTime + 1000L)
         {
@@ -1186,54 +1454,70 @@
                 this.usageSnooper.startSnooper();
             }
         }
-
-        if (this.isFramerateLimitBelowMax())
-        {
-            this.mcProfiler.startSection("fpslimit_wait");
-            Display.sync(this.getLimitFramerate());
-            this.mcProfiler.endSection();
-        }
-
+/** MINECRIFT */
+//        if (this.isFramerateLimitBelowMax())
+//        {
+//            this.mcProfiler.startSection("fpslimit_wait");
+//            Display.sync(this.getLimitFramerate());    // <-- Minecrift - Only support Vsync for head track min latency
+//            this.mcProfiler.endSection();
+//        }
+/** END MINECRIFT */
         this.mcProfiler.endSection();
+//        long gameLoopEnd = System.nanoTime() - gameLoopStart;
+//        //long budget = 1000f / 75f
+//        StringBuilder sb = new StringBuilder();
+//        //sb.append("Frame Timings:\nEye1: ").append(getMsStringFromNanos(totalframe1Time)).append("\nEye2: ").append(getMsStringFromNanos(totalframe2Time));//
+//        //sb.append("\nEnd: ").append(getMsStringFromNanos(endFrame)).append("\nTotal: ").append(getMsStringFromNanos(gameLoopEnd));
+//        sb.append("Frame Timings:\nPre: ").append(getMsStringFromNanos(preRender)).append("\nEye1: ").append(getMsStringFromNanos(eyeRender1)).append("\nEye2: ").append(getMsStringFromNanos(eyeRender2));
+//        sb.append("\nEnd: ").append(getMsStringFromNanos(endFrame)).append("\nTotal: ").append(getMsStringFromNanos(gameLoopEnd));
+//        printFrameDebug(sb.toString());
+
+        Thread.yield();
     }
 
     public void func_175601_h()
     {
-        this.mcProfiler.startSection("display_update");
-        Display.update();
-        this.mcProfiler.endSection();
-        this.func_175604_i();
+/** MINECRIFT */     // Now handled in setupRenderConfiguration    
+//        this.mcProfiler.startSection("display_update");
+//        Display.update();
+//        this.mcProfiler.endSection();
+//        this.func_175604_i();
+/** END MINECRIFT */        
     }
 
     protected void func_175604_i()
     {
-        if (!this.fullscreen && Display.wasResized())
-        {
-            int var1 = this.displayWidth;
-            int var2 = this.displayHeight;
-            this.displayWidth = Display.getWidth();
-            this.displayHeight = Display.getHeight();
-
-            if (this.displayWidth != var1 || this.displayHeight != var2)
-            {
-                if (this.displayWidth <= 0)
-                {
-                    this.displayWidth = 1;
-                }
-
-                if (this.displayHeight <= 0)
-                {
-                    this.displayHeight = 1;
-                }
-
-                this.resize(this.displayWidth, this.displayHeight);
-            }
-        }
+/** MINECRIFT */     // Now handled in setupRenderConfiguration    
+//        if (!this.fullscreen && Display.wasResized())
+//        {
+//            int var1 = this.displayWidth;
+//            int var2 = this.displayHeight;
+//            this.displayWidth = Display.getWidth();
+//            this.displayHeight = Display.getHeight();
+//
+//            if (this.displayWidth != var1 || this.displayHeight != var2)
+//            {
+//                if (this.displayWidth <= 0)
+//                {
+//                    this.displayWidth = 1;
+//                }
+//
+//                if (this.displayHeight <= 0)
+//                {
+//                    this.displayHeight = 1;
+//                }
+//
+//                this.resize(this.displayWidth, this.displayHeight);
+//            }
+//        }
+/** END MINECRIFT */
     }
 
     public int getLimitFramerate()
     {
-        return this.theWorld == null && this.currentScreen != null ? 30 : this.gameSettings.limitFramerate;
+        /** MINECRIFT */
+        return this.gameSettings.limitFramerate;   // Do not limit the framerate in menus!
+        /** END MINECRIFT */
     }
 
     public boolean isFramerateLimitBelowMax()
@@ -1309,10 +1593,19 @@
     /**
      * Parameter appears to be unused
      */
-    private void displayDebugInfo(long elapsedTicksTime)
+    /** MINECRIFT */
+    public void displayDebugInfo(long elapsedTicksTime)
+    /** END MINECRIFT */
     {
         if (this.mcProfiler.profilingEnabled)
         {
+            /** MINECRIFT */
+            GlStateManager.matrixMode(GL11.GL_PROJECTION);
+            GlStateManager.pushMatrix();
+            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+            GlStateManager.pushMatrix();
+            /** END MINECRIFT */
+
             List var3 = this.mcProfiler.getProfilingData(this.debugProfilerName);
             Profiler.Result var4 = (Profiler.Result)var3.remove(0);
             GlStateManager.clear(256);
@@ -1330,6 +1623,14 @@
             short var7 = 160;
             int var8 = this.displayWidth - var7 - 10;
             int var9 = this.displayHeight - var7 * 2;
+            /** MINECRIFT */
+            if (!this.stereoProvider.isGuiOrtho())
+            {
+                var7 = 375;
+                var8 = (int) Math.ceil(this.displayWidth - var7 * 2.5f - 10f);
+                var9 = this.displayHeight - var7 * 2 + 40;
+            }
+            /** END MINECRIFT */
             GlStateManager.enableBlend();
             var6.startDrawingQuads();
             var6.func_178974_a(0, 200);
@@ -1420,6 +1721,13 @@
                 this.fontRendererObj.func_175063_a(var23 = var19.format(var22.field_76332_a) + "%", (float)(var8 + var7 - 50 - this.fontRendererObj.getStringWidth(var23)), (float)(var9 + var7 / 2 + var21 * 8 + 20), var22.func_76329_a());
                 this.fontRendererObj.func_175063_a(var23 = var19.format(var22.field_76330_b) + "%", (float)(var8 + var7 - this.fontRendererObj.getStringWidth(var23)), (float)(var9 + var7 / 2 + var21 * 8 + 20), var22.func_76329_a());
             }
+
+            /** MINECRIFT */
+            GlStateManager.matrixMode(GL11.GL_PROJECTION);
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+            GlStateManager.popMatrix();
+            /** END MINECRIFT */
         }
     }
 
@@ -1503,8 +1811,9 @@
             }
         }
     }
-
-    private void clickMouse()
+    /** MINECRIFT */
+    public void clickMouse()
+    /** END MINECRIFT */
     {
         if (this.leftClickCounter <= 0)
         {
@@ -1512,7 +1821,9 @@
 
             if (this.objectMouseOver == null)
             {
-                logger.error("Null returned as \'hitResult\', this shouldn\'t happen!");
+                /** MINECRIFT */
+                //logger.error("Null returned as \'hitResult\', this shouldn\'t happen!");
+                /** END MINECRIFT */
 
                 if (this.playerController.isNotCreative())
                 {
@@ -1549,82 +1860,90 @@
 
     /**
      * Called when user clicked he's mouse right button (place)
-     */
-    private void rightClickMouse()
+    /** MINECRIFT */
+    public void rightClickMouse()
+    /** END MINECRIFT */
     {
         if (!this.playerController.m())
         {
-            this.rightClickDelayTimer = 4;
-            boolean var1 = true;
-            ItemStack var2 = this.thePlayer.inventory.getCurrentItem();
-
-            if (this.objectMouseOver == null)
-            {
-                logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
-            }
-            else
+        this.rightClickDelayTimer = 4;
+        boolean var1 = true;
+        ItemStack var2 = this.thePlayer.inventory.getCurrentItem();
+
+        if (this.objectMouseOver == null)
+        {
+            /** MINECRIFT */
+            //logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
+            /** END MINECRIFT */
+        }
+        else
+        {
+            switch (Minecraft.SwitchEnumMinecartType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
             {
-                switch (Minecraft.SwitchEnumMinecartType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
-                {
-                    case 1:
-                        if (this.playerController.func_178894_a(this.thePlayer, this.objectMouseOver.entityHit, this.objectMouseOver))
+                case 1:
+                    if (this.playerController.func_178894_a(this.thePlayer, this.objectMouseOver.entityHit, this.objectMouseOver))
+                    {
+                        var1 = false;
+                    }
+                    else if (this.playerController.interactWithEntitySendPacket(this.thePlayer, this.objectMouseOver.entityHit))
+                    {
+                        var1 = false;
+                    }
+
+                    break;
+
+                case 2:
+                    BlockPos var3 = this.objectMouseOver.func_178782_a();
+
+                    if (this.theWorld.getBlockState(var3).getBlock().getMaterial() != Material.air)
+                    {
+                        int var4 = var2 != null ? var2.stackSize : 0;
+
+                        if (this.playerController.func_178890_a(this.thePlayer, this.theWorld, var2, var3, this.objectMouseOver.field_178784_b, this.objectMouseOver.hitVec))
                         {
                             var1 = false;
+                            this.thePlayer.swingItem();
                         }
-                        else if (this.playerController.interactWithEntitySendPacket(this.thePlayer, this.objectMouseOver.entityHit))
+
+                        if (var2 == null)
                         {
-                            var1 = false;
+                            return;
                         }
 
-                        break;
-
-                    case 2:
-                        BlockPos var3 = this.objectMouseOver.func_178782_a();
-
-                        if (this.theWorld.getBlockState(var3).getBlock().getMaterial() != Material.air)
+                        if (var2.stackSize == 0)
                         {
-                            int var4 = var2 != null ? var2.stackSize : 0;
-
-                            if (this.playerController.func_178890_a(this.thePlayer, this.theWorld, var2, var3, this.objectMouseOver.field_178784_b, this.objectMouseOver.hitVec))
-                            {
-                                var1 = false;
-                                this.thePlayer.swingItem();
-                            }
-
-                            if (var2 == null)
-                            {
-                                return;
-                            }
-
-                            if (var2.stackSize == 0)
-                            {
-                                this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = null;
-                            }
-                            else if (var2.stackSize != var4 || this.playerController.isInCreativeMode())
-                            {
-                                this.entityRenderer.itemRenderer.resetEquippedProgress();
-                            }
+                            this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = null;
                         }
-                }
+                        else if (var2.stackSize != var4 || this.playerController.isInCreativeMode())
+                        {
+                            this.entityRenderer.itemRenderer.resetEquippedProgress();
+                        }
+                    }
             }
+        }
 
-            if (var1)
-            {
-                ItemStack var5 = this.thePlayer.inventory.getCurrentItem();
+        if (var1)
+        {
+            ItemStack var5 = this.thePlayer.inventory.getCurrentItem();
 
-                if (var5 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var5))
-                {
-                    this.entityRenderer.itemRenderer.resetEquippedProgress2();
-                }
+            if (var5 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var5))
+            {
+                this.entityRenderer.itemRenderer.resetEquippedProgress2();
             }
         }
     }
+    }
 
     /**
      * Toggles fullscreen mode.
      */
     public void toggleFullscreen()
     {
+        /** MINECRIFT */
+        if (this.isDirectMode)
+            return;
+        /** END MINECRIFT */
+
         try
         {
             this.fullscreen = !this.fullscreen;
@@ -1673,7 +1992,9 @@
             }
 
             Display.setFullscreen(this.fullscreen);
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
+            /** MINECRIFT */
+            Display.setVSyncEnabled(true);
+            /** END MINECRIFT */
             this.func_175601_h();
         }
         catch (Exception var2)
@@ -1687,17 +2008,21 @@
      */
     private void resize(int width, int height)
     {
-        this.displayWidth = Math.max(1, width);
-        this.displayHeight = Math.max(1, height);
-
-        if (this.currentScreen != null)
-        {
-            ScaledResolution var3 = new ScaledResolution(this, width, height);
-            this.currentScreen.func_175273_b(this, var3.getScaledWidth(), var3.getScaledHeight());
-        }
-
-        this.loadingScreen = new LoadingScreenRenderer(this);
-        this.updateFramebufferSize();
+        /** MINECRIFT */
+        this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+        
+//        this.displayWidth = Math.max(1, width);
+//        this.displayHeight = Math.max(1, height);
+//
+//        if (this.currentScreen != null)
+//        {
+//            ScaledResolution var3 = new ScaledResolution(this, width, height);
+//            this.currentScreen.func_175273_b(this, var3.getScaledWidth(), var3.getScaledHeight());
+//        }
+//
+//        this.loadingScreen = new LoadingScreenRenderer(this);
+//        this.updateFramebufferSize();
+        /** END MINECRIFT */
     }
 
     private void updateFramebufferSize()
@@ -1724,6 +2049,10 @@
 
         if (!this.isGamePaused)
         {
+            /** MINECRIFT */
+//            if( JoystickAim.selectedJoystickMode != null )
+//                JoystickAim.selectedJoystickMode.updateTick();
+            /** END MINECRIFT */
             this.ingameGUI.updateTick();
         }
 
@@ -1745,6 +2074,10 @@
 
         if (this.currentScreen == null && this.thePlayer != null)
         {
+            /** MINECRIFT */
+            this.thePlayer.stepHeight = this.vrSettings.walkUpBlocks ? 1f : 0.5f;
+            /** END MINECRIFT */
+
             if (this.thePlayer.getHealth() <= 0.0F)
             {
                 this.displayGuiScreen((GuiScreen)null);
@@ -1924,6 +2257,10 @@
                     }
                     else
                     {
+						/** MINECRIFT */
+                        VRHotkeys.handleKeyboardInputs(this);
+						/** END MINECRIFT */
+
                         if (var1 == 1)
                         {
                             this.displayInGameMenu();
@@ -2019,11 +2356,13 @@
 
                             if (this.gameSettings.thirdPersonView == 0)
                             {
-                                this.entityRenderer.func_175066_a(this.func_175606_aa());
+                                /** MINECRIFT */
+                                this.entityRenderer.activateEntityShader(this.func_175606_aa());
                             }
                             else if (this.gameSettings.thirdPersonView == 1)
                             {
-                                this.entityRenderer.func_175066_a((Entity)null);
+                                this.entityRenderer.activateEntityShader((Entity)null);
+                                /** END MINECRIFT */
                             }
                         }
 
@@ -2154,6 +2493,12 @@
 
             this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindPickBlock.getIsKeyPressed() && this.inGameHasFocus);
         }
+        /** MINECRIFT */
+        else
+        {
+            VRHotkeys.handleKeyboardInputs(this);
+        }
+        /** END MINECRIFT */
 
         if (this.theWorld != null)
         {
@@ -2295,29 +2640,55 @@
 
         this.loadingScreen.displaySavingString(I18n.format("menu.loadingLevel", new Object[0]));
 
-        while (!this.theIntegratedServer.serverIsInRunLoop())
+/** MINECRIFT */
+        // Exit now. Server launch progress will be checked periodically.
+        this.lastIntegratedServerLaunchCheck = System.currentTimeMillis();
+        this.integratedServerLaunchInProgress = true;
+    }
+
+    public boolean isIntegratedServerLaunching()
+    {
+        if (!this.integratedServerLaunchInProgress)
+            return false;
+
+        if (!this.theIntegratedServer.serverIsInRunLoop())
         {
-            String var6 = this.theIntegratedServer.getUserMessage();
+            long currentTime = System.currentTimeMillis();
 
-            if (var6 != null)
-            {
-                this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
-            }
-            else
+            if (currentTime - lastIntegratedServerLaunchCheck > 200L)
             {
-                this.loadingScreen.displayLoadingString("");
-            }
+                this.lastIntegratedServerLaunchCheck = currentTime;
+                String var6 = this.theIntegratedServer.getUserMessage();
 
-            try
-            {
-                Thread.sleep(200L);
-            }
-            catch (InterruptedException var9)
-            {
-                ;
+                if (var6 != null)
+                {
+                    this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
+                }
+                else
+                {
+                    this.loadingScreen.displayLoadingString("");
+                }
+
+                // Wait & loop not used
+                //try
+                //{
+                //    Thread.sleep(200L);
+                //}
+                //catch (InterruptedException var9)
+                //{
+                //    ;
+                //}
             }
+
+            return true;
         }
+        else
+        {
+            this.lastIntegratedServerLaunchCheck = 0;
+            this.integratedServerLaunchInProgress = false;
 
+            // Ideally the network stuff below would also be part of the integrated server
+            // launch, i.e. on it's own thread
         this.displayGuiScreen((GuiScreen)null);
         SocketAddress var11 = this.theIntegratedServer.getNetworkSystem().addLocalEndpoint();
         NetworkManager var12 = NetworkManager.provideLocalClient(var11);
@@ -2325,7 +2696,11 @@
         var12.sendPacket(new C00Handshake(47, var11.toString(), 0, EnumConnectionState.LOGIN));
         var12.sendPacket(new C00PacketLoginStart(this.getSession().getProfile()));
         this.myNetworkManager = var12;
+
+            return false;
+        }
     }
+/** END MINECRIFT */
 
     /**
      * unloads the current world first
@@ -2907,11 +3282,18 @@
         playerSnooper.addStatToSnooper("gl_max_texture_size", Integer.valueOf(getGLMaximumTextureSize()));
     }
 
+/** MINECRIFT */ // From Forge: Adds a optimization to the getGLMaximumTextureSize, only calculate it once.
+    private static int max_texture_size = -1;
     /**
      * Used in the usage snooper.
      */
     public static int getGLMaximumTextureSize()
     {
+        if (max_texture_size != -1)
+        {
+            return max_texture_size;
+        }
+
         for (int var0 = 16384; var0 > 0; var0 >>= 1)
         {
             GL11.glTexImage2D(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_RGBA, var0, var0, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)null);
@@ -2919,12 +3301,14 @@
 
             if (var1 != 0)
             {
+                max_texture_size = var0;
                 return var0;
             }
         }
 
         return -1;
     }
+/** END MINECRIFT */
 
     /**
      * Returns whether snooping is enabled or not.
@@ -3177,15 +3561,19 @@
         return this.skinManager;
     }
 
+    /* Gets current entity */
     public Entity func_175606_aa()
     {
         return this.field_175622_Z;
     }
 
+    /* Sets current entity */
     public void func_175607_a(Entity p_175607_1_)
     {
         this.field_175622_Z = p_175607_1_;
-        this.entityRenderer.func_175066_a(p_175607_1_);
+		/** MINECRIFT */
+        this.entityRenderer.activateEntityShader(p_175607_1_);
+		/** END MINECRIFT */
     }
 
     public ListenableFuture addScheduledTask(Callable callableToSchedule)
@@ -3345,4 +3733,985 @@
             }
         }
     }
+
+	/** MINECRIFT ADDITIONS BELOW */
+    
+    private void setupRenderConfiguration()
+    {
+        boolean changed = false;
+        final float renderScaleFactor = this.vrSettings.renderScaleFactor;
+
+        if (clipPlanesChanged())
+        {
+            this.reinitFramebuffers = true;
+        }
+
+        if (!Display.isActive() && this.fullscreen)
+        {
+            this.toggleFullscreen();
+            this.reinitFramebuffers = true;
+        }
+
+        if (wasDisplayResized())
+        {
+            Display.update();     // This will set new display widths accordingly
+            this.reinitFramebuffers = true;
+        }
+
+        if (this.lastGuiScale != this.gameSettings.guiScale)
+        {
+            this.lastGuiScale = this.gameSettings.guiScale;
+            this.reinitFramebuffers = true;
+        }
+
+        if (!this.stereoProvider.isGuiOrtho()) {
+            showNativeMouseCursor(!Display.isActive());
+        }
+        else {
+            showNativeMouseCursor(true);
+        }
+
+        if (this.entityRenderer != null && lastShaderIndex == -1)
+            this.lastShaderIndex = this.entityRenderer.shaderCount;
+
+        // Check for changes in window handle
+        glConfig = getLWJGLConfig(glConfig);
+        if (glConfig.Window != lastWindow)
+        {
+            this.reinitFramebuffers = true;
+            lastWindow = glConfig.Window;
+        }
+
+        if (this.reinitFramebuffers ||
+            this.lastEnableVsync != this.gameSettings.enableVsync)
+        {
+            changed = true;
+            viewPortCount = 1;
+            float superSampleScaleFactor = 1f;
+            if (this.vrSettings.useFsaa)
+                superSampleScaleFactor = this.vrSettings.fsaaScaleFactor;
+
+            displayFBWidth = (Display.getWidth() < 1) ? 1 : Display.getWidth();
+            displayFBHeight = (Display.getHeight() < 1) ? 1 : Display.getHeight();
+            distortionRenderTargetSize[0] = new Sizei(displayFBWidth, displayFBHeight);
+            distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+            this.EyeTextureSize[0].w = this.displayWidth = (int)Math.ceil((displayFBWidth * superSampleScaleFactor));
+            this.EyeTextureSize[0].h = this.displayHeight = (int)Math.ceil((displayFBHeight * superSampleScaleFactor));
+            this.EyeTextureSize[1] = this.EyeTextureSize[0];
+
+            FovPort leftFov = null;
+            FovPort rightFov = null;
+
+            // Scale up the FBO to allow for the distortion
+            if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+            {
+                if (this.vrSettings.useMaxFov)
+                {
+                    leftFov = hmdInfo.getHMDInfo().MaxEyeFov[0].enlargedFov(this.vrSettings.fovChange);
+                    rightFov = hmdInfo.getHMDInfo().MaxEyeFov[1].enlargedFov(this.vrSettings.fovChange);
+
+                }
+                else
+                {
+                    leftFov = hmdInfo.getHMDInfo().DefaultEyeFov[0].enlargedFov(this.vrSettings.fovChange);
+                    rightFov = hmdInfo.getHMDInfo().DefaultEyeFov[1].enlargedFov(this.vrSettings.fovChange);
+                }
+
+                System.out.println("L MaxEyeFov:     " + hmdInfo.getHMDInfo().MaxEyeFov[0].toString());
+                System.out.println("R MaxEyeFov:     " + hmdInfo.getHMDInfo().MaxEyeFov[1].toString());
+                System.out.println("L DefaultEyeFov: " + hmdInfo.getHMDInfo().DefaultEyeFov[0].toString());
+                System.out.println("R DefaultEyeFov: " + hmdInfo.getHMDInfo().DefaultEyeFov[1].toString());
+                System.out.println("L Fov:           " + leftFov.toString());
+                System.out.println("R Fov:           " + rightFov.toString());
+
+                FovTextureInfo fovTextureInfo = this.stereoProvider.getFovTextureSize(leftFov, rightFov, renderScaleFactor);
+
+                if (Display.isFullscreen() || this.isDirectMode)
+                {
+                    distortionRenderTargetSize[0] = fovTextureInfo.LeftFovTextureResolution;
+                    distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+                    this.EyeTextureSize[0].w = (int)Math.ceil(fovTextureInfo.LeftFovTextureResolution.w * superSampleScaleFactor);
+                    this.EyeTextureSize[0].h = (int)Math.ceil(fovTextureInfo.LeftFovTextureResolution.h * superSampleScaleFactor);
+                    this.EyeTextureSize[1] = this.EyeTextureSize[0];
+                }
+                else
+                {
+                    distortionRenderTargetSize[0] = new Sizei();
+                    distortionRenderTargetSize[1] = new Sizei();
+                    distortionRenderTargetSize[0].w = (int) Math.ceil((((float) fovTextureInfo.CombinedTextureResolution.w / (float) fovTextureInfo.HmdNativeResolution.w) * (float) this.displayFBWidth) / 2f);
+                    distortionRenderTargetSize[0].h = (int) Math.ceil(((float) fovTextureInfo.CombinedTextureResolution.h / (float) fovTextureInfo.HmdNativeResolution.h) * (float) this.displayFBHeight);
+                    distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+                    this.EyeTextureSize[0].w = (int) Math.ceil((((float)fovTextureInfo.CombinedTextureResolution.w / (float)fovTextureInfo.HmdNativeResolution.w) * (float)this.displayFBWidth * superSampleScaleFactor) / 2f);
+                    this.EyeTextureSize[0].h = (int) Math.ceil(((float)fovTextureInfo.CombinedTextureResolution.h / (float)fovTextureInfo.HmdNativeResolution.h) * (float)this.displayFBHeight * superSampleScaleFactor);
+                    this.EyeTextureSize[1] = this.EyeTextureSize[0];
+                }
+
+                viewPortCount = 2;
+
+                // Oculus scaled render height seems ridiculous? For DK1, yes.
+            }
+
+            if (this.framebuffers[0] != null) {
+                this.framebuffers[0].deleteFramebuffer();
+                this.framebuffers[0] = null;
+            }
+
+            if (this.framebuffers[1] != null) {
+                this.framebuffers[1].deleteFramebuffer();
+                this.framebuffers[1] = null;
+            }
+
+            if (this.guiFramebuffer != null) {
+                this.guiFramebuffer.deleteFramebuffer();
+                this.guiFramebuffer = null;
+            }
+
+            if (this.fsaaFirstPassResultFBO[0] != null) {
+                this.fsaaFirstPassResultFBO[0].delete();
+                this.fsaaFirstPassResultFBO[0] = null;
+            }
+            if (this.fsaaFirstPassResultFBO[1] != null) {
+                this.fsaaFirstPassResultFBO[1].delete();
+                this.fsaaFirstPassResultFBO[1] = null;
+            }
+            if (this.fsaaSecondPassResultFBO[0] != null) {
+                this.fsaaSecondPassResultFBO[0].delete();
+                this.fsaaSecondPassResultFBO[0] = null;
+            }
+            if (this.fsaaSecondPassResultFBO[1] != null) {
+                this.fsaaSecondPassResultFBO[1].delete();
+                this.fsaaSecondPassResultFBO[1] = null;
+            }
+
+            _LanczosShader_texelWidthOffsetUniform = -1;
+            _LanczosShader_texelHeightOffsetUniform = -1;
+            _LanczosShader_inputImageTextureUniform = -1;
+
+            int multiSampleCount = 0;   // TODO: The SDK (0.3.2 preview) doesn't like anything other than 0 currently AFAICT
+            boolean multiSample = (multiSampleCount > 0 ? true : false);
+            boolean genMipMaps = true;
+            this.entityRenderer.generatedIconMipmaps[0] = false;
+            this.entityRenderer.generatedIconMipmaps[1] = false;
+
+            this.framebuffers[0] = new Framebuffer(this.EyeTextureSize[0].w, this.EyeTextureSize[0].h, true, genMipMaps);
+            glConfig.TexId = this.framebuffers[0].framebufferTexture;
+            this.checkGLError("Viewport 1 framebuffer setup");
+            this.framebuffers[1] = new Framebuffer(this.EyeTextureSize[1].w, this.EyeTextureSize[1].h, true, genMipMaps);
+            glConfig.TexId2 = this.framebuffers[1].framebufferTexture;
+            this.checkGLError("Viewport 2 framebuffer setup");
+            this.guiFramebuffer  = new Framebuffer(this.displayFBWidth, this.displayFBHeight, true, genMipMaps);
+            this.checkGLError("GUI framebuffer setup");
+
+            this.framebuffers[0].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+            this.framebuffers[1].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+            this.guiFramebuffer.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+
+            try
+            {
+                if (this.vrSettings.useFsaa)
+                {
+                    // Lanczos downsample FBOs
+                    fsaaFirstPassResultFBO[0] = new FBOParams("FSAA Pass1 FBO1 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, this.EyeTextureSize[0].h);
+                    fsaaFirstPassResultFBO[1] = new FBOParams("FSAA Pass1 FBO2 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, this.EyeTextureSize[1].h);
+                    fsaaSecondPassResultFBO[0] = new FBOParams("FSAA Pass2 FBO1", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, distortionRenderTargetSize[0].h);
+                    fsaaSecondPassResultFBO[1] = new FBOParams("FSAA Pass2 FBO2", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, distortionRenderTargetSize[1].h);
+
+                    checkGLError("FSAA FBO creation");
+
+                    _Lanczos_shaderProgramId = ShaderHelper.initShaders(LANCZOS_SAMPLER_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER, true);
+
+                    ShaderHelper.checkGLError("@1");
+                    GL20.glValidateProgram(_Lanczos_shaderProgramId);
+
+                    // Setup uniform IDs
+                    _LanczosShader_texelWidthOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset");
+                    _LanczosShader_texelHeightOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset");
+                    _LanczosShader_inputImageTextureUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture");
+
+                    ShaderHelper.checkGLError("FBO init Lanczos shader");
+
+                    glConfig.TexId = fsaaSecondPassResultFBO[0].getColorTextureId();
+                    glConfig.TexId2 = fsaaSecondPassResultFBO[1].getColorTextureId();
+                }
+            }
+            catch (Exception ex)
+            {
+                // We had an issue. Set the usual suspects to defaults...
+                this.vrSettings.useFsaa = false;
+                this.vrSettings.fsaaScaleFactor = 1.4f;
+                this.vrSettings.saveOptions();
+                System.out.println("[Minecrift] FAILED to setup FSAA: " + ex.getMessage());
+                reinitFramebuffers = true;
+                return;
+            }
+
+            glConfig.VSyncEnabled = true;//this.gameSettings.enableVsync;
+            glConfig.useChromaticAbCorrection = this.vrSettings.useChromaticAbCorrection;
+            glConfig.useTimewarp = this.vrSettings.useTimewarp;
+            glConfig.useVignette = this.vrSettings.useVignette;
+            glConfig.useLowPersistence = this.vrSettings.useLowPersistence;
+            glConfig.MultiSampleCount = multiSampleCount;
+            glConfig.mirrorDisplay = this.vrSettings.useDisplayMirroring;
+            glConfig.useDisplayOverdrive = this.vrSettings.useDisplayOverdrive;
+            glConfig.useDynamicPrediction = this.vrSettings.useDynamicPrediction;
+            glConfig.useHighQualityDistortion = this.vrSettings.useHighQualityDistortion;
+
+            setupClipPlanes();
+
+            if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+            {
+                this.eyeRenderParams = this.stereoProvider.configureRenderingDualTexture(this.EyeTextureSize[0],
+                                                                                         this.EyeTextureSize[1],
+                                                                                         new Sizei(this.displayFBWidth, this.displayFBHeight),
+                                                                                         glConfig,
+                                                                                         leftFov,
+                                                                                         rightFov);
+
+                this.entityRenderer.eyeproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getMatrix4fProjection(leftFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+                this.entityRenderer.eyeproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getMatrix4fProjection(rightFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+                this.entityRenderer.skyproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getMatrix4fProjection(leftFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);   // The same as eyeproj?!
+                this.entityRenderer.skyproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getMatrix4fProjection(rightFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance); // The same as eyeproj?!
+                this.entityRenderer.cloudproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getMatrix4fProjection(leftFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance * 4f);
+                this.entityRenderer.cloudproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getMatrix4fProjection(rightFov, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance * 4f);
+            }
+
+            this.lastDisplayFBWidth = this.displayFBWidth;
+            this.lastDisplayFBHeight = this.displayFBHeight;
+            this.lastEnableVsync = this.gameSettings.enableVsync;
+            this.reinitFramebuffers = false;
+
+            if (this.firstInit)
+            {
+                // Workaround for bad init of Oculus SDK
+                this.firstInit = false;
+                this.reinitFramebuffers = true;
+                System.out.println("[Minecrift] Now re-init for Oculus SDK weirdness...");
+            }
+        }
+
+        if (this.entityRenderer != null)
+        {
+            if (changed || reloadShaders)
+            {
+                if (shaderGroup[0] != null) {
+                    shaderGroup[0].deleteShaderGroup();
+                    shaderGroup[0] = null;
+                }
+
+                if (shaderGroup[1] != null) {
+                    shaderGroup[1].deleteShaderGroup();
+                    shaderGroup[1] = null;
+                }
+
+                lastShaderIndex = this.entityRenderer.shaderIndex;
+                shaderGroup[0] = this.entityRenderer.initShaderGroup(framebuffers[0]);
+                shaderGroup[1] = this.entityRenderer.initShaderGroup(framebuffers[1]);
+            }
+        }
+
+        if (changed)
+        {
+            if (this.currentScreen != null)
+            {
+                ScaledResolution scaledresolution = new ScaledResolution(this,
+                        this.stereoProvider.isGuiOrtho() ? this.displayWidth : this.displayFBWidth,
+                        this.stereoProvider.isGuiOrtho() ? this.displayHeight : this.displayFBHeight);
+                int k = scaledresolution.getScaledWidth();
+                int l = scaledresolution.getScaledHeight();
+                this.currentScreen.setWorldAndResolution(this, k, l);
+            }
+            this.loadingScreen = new LoadingScreenRenderer(this, this.stereoProvider.isGuiOrtho() ? this.displayWidth : this.displayFBWidth, this.stereoProvider.isGuiOrtho() ? this.displayHeight : this.displayFBHeight);
+            if (this.stereoProvider.isGuiOrtho())
+                this.loadingScreen.renderTarget = this.getFramebuffer();
+            else
+                this.loadingScreen.renderTarget = this.guiFramebuffer;
+
+            System.out.println("[Minecrift] New render config:" +
+                    "\nRender target width:  " + (this.stereoProvider.isStereo() ? this.EyeTextureSize[0].w + this.EyeTextureSize[1].w: this.displayWidth) +
+                                                 ", height: " + (this.stereoProvider.isStereo() ? Math.max(this.EyeTextureSize[0].h, this.EyeTextureSize[1].h) : this.displayHeight) +
+                                                 (this.stereoProvider.isStereo() ? " [Render scale: " + renderScaleFactor + "]" : "") +
+                                                 (this.vrSettings.useFsaa ? " [FSAA Scale: " + this.vrSettings.fsaaScaleFactor + "]" : "") +
+                    "\nDisplay target width: " + this.displayFBWidth + ", height: " + displayFBHeight);
+        }
+    }
+
+    public void setupClipPlanes()
+    {
+        this.entityRenderer.farPlaneDistance = (float)(this.gameSettings.renderDistanceChunks * 16);
+
+        if (Config.isFogFancy())
+        {
+            this.entityRenderer.farPlaneDistance *= 0.95F;
+        }
+
+        if (Config.isFogFast())
+        {
+            this.entityRenderer.farPlaneDistance *= 0.83F;
+        }
+
+        this.entityRenderer.clipDistance = this.entityRenderer.farPlaneDistance * MathHelper.field_180189_a;
+
+        if (this.entityRenderer.clipDistance < 173.0F)
+        {
+            this.entityRenderer.clipDistance = 173.0F;
+        }
+
+        if (this.theWorld != null && this.theWorld.provider != null && this.theWorld.provider.dimensionId == 1)
+        {
+            this.entityRenderer.clipDistance = 256.0F;
+        }
+    }
+
+    public boolean clipPlanesChanged()
+    {
+        boolean changed = false;
+
+        if (this.theWorld != null && this.theWorld.provider != null)
+        {
+            if (this.theWorld.provider.dimensionId != this.lastDimensionId)
+            {
+                //changed = true;   // TODO: Re-enable when Lib OVR doesn't crash all the bloody time. We
+                                    // can't currently change render config in-game, without a crash in
+                                    // nvgl.dll glDrawArrays
+            }
+        }
+
+        if( this.gameSettings.renderDistanceChunks != this.lastRenderDistanceChunks ||
+            Config.isFogFancy() != this.lastFogFancy                                ||
+            Config.isFogFast() != this.lastFogFast)
+        {
+            changed = true;
+        }
+
+        lastRenderDistanceChunks = this.gameSettings.renderDistanceChunks;
+        lastFogFancy = Config.isFogFancy();
+        lastFogFast = Config.isFogFast();
+        if (this.theWorld != null && this.theWorld.provider != null)
+            lastDimensionId = this.theWorld.provider.dimensionId;
+
+        return changed;
+    }
+
+    public GLConfig getLWJGLConfig(GLConfig glConfig)
+    {
+        // TODO: For LWJGL 3.0, this function may well be screwed...
+
+        // We need to retrieve certain pointers / handles from LWJGL
+        // for the Oculus SDK. However, these are not exposed by
+        // LWJGL, so use reflection to get hold of the data we need.
+
+        try
+        {
+            switch(LWJGLUtil.getPlatform())
+            {
+                case LWJGLUtil.PLATFORM_WINDOWS:
+                {
+                    // Get HWND pointer...
+                    if (fieldHwnd == null)
+                    {
+                        fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+                        fieldHwnd.setAccessible(true);
+                    }
+                    glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+                    //System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+                    break;
+                }
+                case LWJGLUtil.PLATFORM_LINUX:
+                {
+                    // Get Display and Window pointers...
+                    if (fieldDisplay == null)
+                    {
+                        fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+                        fieldDisplay.setAccessible(true);
+                    }
+                    if (fieldWindow == null)
+                    {
+                        fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+                        fieldWindow.setAccessible(true);
+                    }
+                    glConfig.Display = (Long) fieldDisplay.get(null);
+                    glConfig.Window = (Long) fieldWindow.get(null);
+                    System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+                    System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+                    break;
+                }
+                case LWJGLUtil.PLATFORM_MACOSX:
+                {
+                    // Do nowt...
+                    break;
+                }
+                default:
+                    throw new Exception ("Current platform not supported!");
+            }
+        }
+        catch (Exception ex)
+        {
+            ex.printStackTrace();
+            glConfig = null;
+        }
+
+        return glConfig;
+    }
+
+    public boolean wasDisplayResized()
+    {
+        boolean wasResized = false;
+
+        // We don't want to have to call Display.update() just to determine
+        // if the display has been resized - this will invoke a swapBuffer.
+
+        switch(LWJGLUtil.getPlatform())
+        {
+            case LWJGLUtil.PLATFORM_WINDOWS:
+            case LWJGLUtil.PLATFORM_LINUX: {
+                // Get the 'resized' field from the Display class...
+                try {
+                    if (fieldResized == null) {
+                        fieldResized = displayImpl.getClass().getDeclaredField("resized");
+                        fieldResized.setAccessible(true);
+                    }
+                    wasResized = (Boolean) fieldResized.get(displayImpl);
+                } catch (Exception e) {
+                    System.out.println(displayImpl.getClass().getName());
+                    e.printStackTrace();
+                }
+            }
+            break;
+            case LWJGLUtil.PLATFORM_MACOSX: {
+                // Get the 'wasResized' method from the Display class...
+                try {
+                    if (fieldResizedMethod == null) {
+                        fieldResizedMethod = displayImpl.getClass().getDeclaredMethod("wasResized");
+                        fieldResizedMethod.setAccessible(true);
+                    }
+                    wasResized = (Boolean) fieldResizedMethod.invoke(displayImpl);
+                } catch (Exception e) {
+                    System.out.println(displayImpl.getClass().getName());
+                    e.printStackTrace();
+                }
+            }
+            break;
+        }
+
+        if (wasResized)
+            System.out.println("Display resized");
+
+        return wasResized;
+    }
+
+    public void initMinecrift()
+    {
+        this.vrSettings = new VRSettings(this, this.mcDataDir);
+        this.lastGuiScale = this.gameSettings.guiScale;
+
+        // Get underlying LWJGL Display implementation
+        if (displayImpl == null)
+        {
+            try {
+                Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+                displayMethod.setAccessible(true);
+                displayImpl = displayMethod.invoke(null, null);
+                System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        try {
+            Class.forName("com.mtbs3d.minecrift.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+            hydraLibsAvailable = true;
+        } catch (NoClassDefFoundError e1) {
+            System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+        } catch( Exception e1) {
+            System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+        }
+
+        // #85 Allow disable mumblelib load
+        if (this.vrSettings.loadMumbleLib) {
+            try {
+                MumbleLink.loadLibrary();
+                mumbleLink = new MumbleLink("MinecraftVR", "Minecraft VR");
+                mumbleLink.setIdentityAndContext(this.session.getUsername(), "Minecraft"/*TODO: get the servername? */);
+            } catch (Exception e) {
+                System.err.println("Couldn't load [MumbleLink library]: " + e.toString());
+            }
+        }
+        else {
+            System.err.println("Skipping loading: [MumbleLink library]: Configuration setting disabled loading");
+        }
+        new MCController();
+        ControlBinding.CreateBindingList(this.gameSettings); // Create control binding list
+        new MCMouse();                                       // Create and register mouse ILookAimMoveController plugin
+        new NullEyePosition();                               // Create and register "None" head position plugin
+        new NullStereoRenderer();                            // Create and register "None" stereo renderer plugin
+        PluginManager.register(new MCOculus());              // Create and register new plugin
+
+        hmdInfo           = PluginManager.configureHMD(this.vrSettings.hmdPluginID);
+        headTracker       = PluginManager.configureOrientation(this.vrSettings.headTrackerPluginID);
+        positionTracker   = PluginManager.configurePosition(this.vrSettings.headPositionPluginID);
+        lookaimController = PluginManager.configureController(this.vrSettings.controllerPluginID);
+        stereoProvider    = PluginManager.configureStereoProvider(this.vrSettings.stereoProviderPluginID);
+
+        nativeMouseCursor = Mouse.getNativeCursor();
+        try {
+            invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+        } catch (LWJGLException e) {
+            e.printStackTrace();
+        }
+
+
+    }
+
+    public void printChatMessage(String msg)
+    {
+        if (this.theWorld != null) {
+            ChatComponentText chatText = new ChatComponentText("\u00a7e[Minecrift]: " + msg + "\u00a7f");
+            this.ingameGUI.getChatGUI().printChatMessage(chatText);
+        }
+    }
+
+    public void showNativeMouseCursor(boolean show)
+    {
+        if (show == lastShowMouseNative)
+            return;
+
+        lastShowMouseNative = show;
+
+        try
+        {
+            if (show)
+            {
+                Mouse.setNativeCursor(nativeMouseCursor);
+            }
+            else
+            {
+                Mouse.setNativeCursor(invisibleMouseCursor);
+            }
+        }
+        catch (LWJGLException e)
+        {
+            e.printStackTrace();
+        }
+    }
+
+    public void minecriftFirstInit()
+    {
+        this.EyeTextureSize[0] = new Sizei();
+        this.EyeTextureSize[1] = new Sizei();
+
+        // Initialise Oculus library here (before LWJGL) to allow DirectMode support
+
+        OculusRift.LoadLibrary();
+        PluginManager.register(new MCOculus()); // create and register new plugin
+        hmdInfo = PluginManager.configureHMD("oculus");
+
+        if (hmdInfo != null && hmdInfo.isInitialized())
+        {
+            initialResolution = hmdInfo.getHMDInfo().Resolution;
+            isDirectMode = hmdInfo.getHMDInfo().isDirectMode();
+        }
+    }
+
+    public Posef getEyePose(EyeType eye)
+    {
+        Posef pose = new Posef();
+
+        // Mark getEyePose with stereo provider
+        if (this.stereoProvider != null)
+            this.stereoProvider.getEyePose(eye);
+
+        // Pull together position, orientation information (TODO: also body orientation)
+
+        // Get orient first...
+        if (this.headTracker != null && this.headTracker.isInitialized())
+        {
+            Quaternion orient = this.headTracker.getOrientationQuaternion();
+            if (orient != null) {
+                pose.Orientation.x = orient.x;
+                pose.Orientation.y = orient.y;
+                pose.Orientation.z = orient.z;
+                pose.Orientation.w = orient.w;
+            }
+        }
+
+        // ...as some position providers also require orientation information
+        if (positionTracker != null && this.positionTracker.isInitialized())
+        {
+            Vec3 pos = positionTracker.getEyePosition(eye);
+            if (pos != null)
+            {
+                pose.Position.x = (float) pos.xCoord;
+                pose.Position.y = (float) pos.yCoord;
+                pose.Position.z = (float) pos.zCoord;
+            }
+        }
+
+        return pose;
+    }
+
+    public void endFrame()
+    {
+        if (this.stereoProvider != null)
+            this.stereoProvider.endFrame();
+    }
+
+    public double getCurrentTimeSecs()
+    {
+        return this.stereoProvider.getCurrentTimeSecs();
+    }
+
+    private void doPostProcessing(EyeType eye)
+    {
+        if (showSplashScreen && splashFadeAlpha > 0)
+        {
+            final org.lwjgl.util.vector.Vector3f rgb = new org.lwjgl.util.vector.Vector3f(0f, 0f, 0f);
+            this.entityRenderer.renderFadeBlend(rgb, splashFadeAlpha);
+        }
+
+        if (this.vrSettings.useFsaa)
+        {
+            GlStateManager.disableAlpha();
+            GlStateManager.disableBlend();
+            
+            // Setup ortho projection
+            GlStateManager.matrixMode(GL11.GL_PROJECTION);
+            GlStateManager.loadIdentity();
+            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+            GlStateManager.loadIdentity();
+
+            GL11.glTranslatef(0.0f, 0.0f, -0.7f);
+
+            // Now switch to 1st pass FSAA result target framebuffer
+            this.fsaaFirstPassResultFBO[eye.value()].bindRenderTarget();
+
+            // Bind the FBO
+            this.framebuffers[eye.value()].bindFramebufferTexture();
+
+            GlStateManager.clearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+            GlStateManager.clearDepth(1.0D);
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer
+
+            // Render onto the entire screen framebuffer
+            GlStateManager.viewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.EyeTextureSize[eye.value()].h);
+
+            // Set the downsampling shader as in use
+            ARBShaderObjects.glUseProgramObjectARB(_Lanczos_shaderProgramId);
+
+            // Set up the fragment shader uniforms
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].w));
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 0.0f);
+            ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+
+            // Pass 1
+            drawQuad();
+
+            // checkGLError("After Lanczos Pass1");
+
+            // Pass 2
+            // Now switch to 2nd pass screen framebuffer
+            if (this.stereoProvider.isStereo())
+            {
+                fsaaSecondPassResultFBO[eye.value()].bindRenderTarget();
+            }
+            else
+            {
+                this.framebufferMc.unbindFramebuffer();
+            }
+
+            fsaaFirstPassResultFBO[eye.value()].bindTexture();
+
+            GlStateManager.viewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.distortionRenderTargetSize[eye.value()].h);
+            GlStateManager.clearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+            GlStateManager.clearDepth(1.0D);
+            GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+            // Bind the texture
+            GlStateManager.setActiveTexture(GL13.GL_TEXTURE0);
+
+            // Set up the fragment shader uniforms for pass 2
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 0.0f);
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].h));
+            ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+            drawQuad();
+
+            // Stop shader use
+            ARBShaderObjects.glUseProgramObjectARB(0);
+            // checkGLError("After Lanczos Pass2");
+
+            GlStateManager.enableAlpha();
+            GlStateManager.enableBlend();
+        }
+        else if (!this.stereoProvider.isStereo())
+        {
+            this.framebufferMc.unbindFramebuffer();
+            this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+        }
+    }
+
+    public void drawQuad()
+    {
+        // this func just draws a perfectly normal box with some texture coordinates
+        GL11.glBegin(GL11.GL_QUADS);
+
+        // Front Face
+        GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+        GL11.glEnd();
+    }
+
+    /** Minecrift */
+    public void showSplash(TextureManager p_180510_1_, Framebuffer rendertarget)
+    {
+        final int SPLASH_TIMEOUT_MS = this.stereoProvider.isStereo() ? 2000 : 1500;
+        final int SPLASH_FADE_TIMEOUT_MS = this.stereoProvider.isStereo() ? 1000 : 0;
+        splashFadeAlpha = 0f;
+        final long currentTimeMs = System.currentTimeMillis();
+
+        // Start display splash timer (only after any calibration has finished)
+        if (this.entityRenderer.calibrationHelper == null && splashTimer1 == 0 && splashTimer2 == 0)
+        {
+            splashTimer1 = currentTimeMs;
+        }
+
+        RED_COLOUR_COMPONENT = 1f;
+        GREEN_COLOUR_COMPONENT = 1f;
+        BLUE_COLOUR_COMPONENT = 1f;
+
+        // Start fade timer
+        if (splashTimer1 != 0 && (currentTimeMs > splashTimer1 + SPLASH_TIMEOUT_MS))
+        {
+            splashTimer1 = 0;
+            splashTimer2 = currentTimeMs;
+        }
+
+        // Continue or end fade
+        if (splashTimer2 != 0 && (currentTimeMs < splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+        {
+            splashFadeAlpha = (100f / SPLASH_FADE_TIMEOUT_MS) * (currentTimeMs - splashTimer2) * 0.01f;
+        }
+        else if (splashTimer2 != 0 && (currentTimeMs >= splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+        {
+            this.showSplashScreen = false;
+            splashFadeAlpha = this.stereoProvider.isStereo() ? 1f : 0f;
+            RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+            GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+            BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+        }
+
+        int existingScale = gameSettings.guiScale;
+        gameSettings.guiScale = 0;
+        ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+        int var3 = var2.getScaleFactor();
+        if (splash == null)
+            splash = new Framebuffer(var2.getScaledWidth() * var3, var2.getScaledHeight() * var3, true);
+        splash.bindFramebuffer(true);
+        GlStateManager.matrixMode(5889);                  // GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GlStateManager.loadIdentity();                    // GL11.glLoadIdentity();
+        GlStateManager.ortho(0.0D, (double)var2.getScaledWidth(), (double)var2.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);  // GL11.glOrtho(
+        GlStateManager.matrixMode(5888);                  // GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GlStateManager.loadIdentity();
+        GlStateManager.translate(0.0F, 0.0F, -2000.0F);   // GL11.glTranslatef
+        GlStateManager.disableLighting();                 // GL11.glDisable(GL11.GL_LIGHTING);
+        GlStateManager.disableFog();                      // GL11.glDisable(GL11.GL_FOG);
+        GlStateManager.disableDepth();                    // GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GlStateManager.func_179098_w();                   // GL11.glEnable(GL11.GL_TEXTURE_2D);
+        //GlStateManager.func_179090_x();                 // GL11.glDisable(GL11.GL_TEXTURE_2D);
+        InputStream var5 = null;
+        try
+        {
+            if (this.mojangLogo == null)
+            {
+                var5 = this.mcDefaultResourcePack.getInputStream(locationMojangPng);
+                this.mojangLogo = p_180510_1_.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(var5)));
+            }
+            p_180510_1_.bindTexture(this.mojangLogo);
+        }
+        catch (IOException var12)
+        {
+            logger.error("Unable to load logo: " + locationMojangPng, var12);
+        }
+        finally
+        {
+            IOUtils.closeQuietly(var5);
+        }
+        Tessellator var6 = Tessellator.getInstance();  // Tessellator.instance;
+        WorldRenderer var7 = var6.getWorldRenderer();
+        var7.startDrawingQuads();
+        var7.func_178991_c(16777215); // var6.setColorOpaque_I(16777215);
+        var7.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+        var7.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+        var7.addVertexWithUV((double)this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+        var7.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+        var6.draw();
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F); //GL11.glColor4f
+        var7.func_178991_c(16777215);                 // var6.setColorOpaque_I(16777215);
+        short var8 = 256;
+        short var9 = 256;
+        this.scaledTessellator((var2.getScaledWidth() - var8) / 2, (var2.getScaledHeight() - var9) / 2, 0, 0, var8, var9);
+        GlStateManager.disableLighting();             // GL11.glDisable(GL11.GL_LIGHTING);
+        GlStateManager.disableFog();                  // GL11.glDisable(GL11.GL_FOG);
+        rendertarget.bindFramebuffer(true);
+        splash.framebufferRender(var2.getScaledWidth() * var3, var2.getScaledHeight() * var3);
+        GlStateManager.enableAlpha();                 // GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GlStateManager.alphaFunc(516, 0.1F);          // GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+        //Display.update();
+        gameSettings.guiScale = existingScale;
+        //this.func_175601_h();
+    }
+    
+    public static void sleepNanos (long nanoDelay)
+    {
+        final long end = System.nanoTime() + nanoDelay;
+        do
+        {
+            Thread.yield();  // This is a busy wait sadly...
+        }
+        while (System.nanoTime() < end);
+    }
+
+    private void addRunTickTimeNanos(long runTickTime)
+    {
+        int i = 0;
+        medianRunTickTimeNanos = runTickTime;
+
+        if (this.vrSettings.smoothRunTickCount < 1)
+            this.vrSettings.smoothRunTickCount = 1;
+
+        if (this.vrSettings.smoothRunTickCount % 2 == 0)
+        {
+            // Need an odd number for this
+            this.vrSettings.smoothRunTickCount++;
+        }
+
+        runTickTimeNanoDeque.addFirst(runTickTime);
+        while (runTickTimeNanoDeque.size() > this.vrSettings.smoothRunTickCount)
+            runTickTimeNanoDeque.removeLast();
+
+        if (runTickTimeNanoDeque.size() == this.vrSettings.smoothRunTickCount)
+        {
+            Long[] array = new Long[runTickTimeNanoDeque.size()];
+            for (Iterator itr = runTickTimeNanoDeque.iterator(); itr.hasNext(); i++)
+            {
+                array[i] = (Long)itr.next();
+            }
+            Arrays.sort(array);
+            medianRunTickTimeNanos = array[array.length / 2];
+        }
+    }
+
+    private long getMedianRunTickTimeNanos()
+    {
+        return medianRunTickTimeNanos;
+    }
+
+    public void printFrameDebug(String debug)
+    {
+        if (canPrintFrameDebug)
+            this.printChatMessage(debug);
+    }
+
+    public void setFrameDebugCounter()
+    {
+        debugFrameCounter++;
+        if (debugFrameCounter == 450)
+        {
+            canPrintFrameDebug = true;
+        }
+        else if (debugFrameCounter > 450)
+        {
+            canPrintFrameDebug = false;
+            debugFrameCounter = 0;
+        }
+        else
+        {
+            canPrintFrameDebug = false;
+        }
+    }
+
+    public String getMsStringFromNanos(long nanos)
+    {
+        return String.format("%.3fms", new Object[] {(double)nanos / 1000000f});
+    }
+
+    public final String LANCZOS_SAMPLER_VERTEX_SHADER =
+            "#version 120\n" +
+                    "\n" +
+                    " uniform float texelWidthOffset;\n" +
+                    " uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    " varying vec2 centerTextureCoordinate;\n" +
+                    " varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 oneStepRightTextureCoordinate;\n" +
+                    " varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    " varying vec2 threeStepsRightTextureCoordinate;\n" +
+                    " varying vec2 fourStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     gl_Position = ftransform();\n" +
+                    "\n" +
+                    "     vec2 firstOffset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "     vec2 secondOffset = vec2(2.0 * texelWidthOffset, 2.0 * texelHeightOffset);\n" +
+                    "     vec2 thirdOffset = vec2(3.0 * texelWidthOffset, 3.0 * texelHeightOffset);\n" +
+                    "     vec2 fourthOffset = vec2(4.0 * texelWidthOffset, 4.0 * texelHeightOffset);\n" +
+                    "\n" +
+                    "     vec2 textCoord = gl_MultiTexCoord0.xy;\n" +
+                    "     centerTextureCoordinate = textCoord;\n" +
+                    "     oneStepLeftTextureCoordinate = textCoord - firstOffset;\n" +
+                    "     twoStepsLeftTextureCoordinate = textCoord - secondOffset;\n" +
+                    "     threeStepsLeftTextureCoordinate = textCoord - thirdOffset;\n" +
+                    "     fourStepsLeftTextureCoordinate = textCoord - fourthOffset;\n" +
+                    "     oneStepRightTextureCoordinate = textCoord + firstOffset;\n" +
+                    "     twoStepsRightTextureCoordinate = textCoord + secondOffset;\n" +
+                    "     threeStepsRightTextureCoordinate = textCoord + thirdOffset;\n" +
+                    "     fourStepsRightTextureCoordinate = textCoord + fourthOffset;\n" +
+                    " }\n";
+
+    public final String LANCZOS_SAMPLER_FRAGMENT_SHADER =
+
+            "#version 120\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    " varying vec2 centerTextureCoordinate;\n" +
+                    " varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 oneStepRightTextureCoordinate;\n" +
+                    " varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    " varying vec2 threeStepsRightTextureCoordinate;\n" +
+                    " varying vec2 fourStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    " // sinc(x) * sinc(x/a) = (a * sin(pi * x) * sin(pi * x / a)) / (pi^2 * x^2)\n" +
+                    " // Assuming a Lanczos constant of 2.0, and scaling values to max out at x = +/- 1.5\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.38026;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.27667;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.27667;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.08074;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, threeStepsRightTextureCoordinate) * -0.02612;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, fourStepsRightTextureCoordinate) * -0.02143;\n" +
+                    "\n" +
+                    "     gl_FragColor = fragmentColor;\n" +
+                    " }\n";
 }
