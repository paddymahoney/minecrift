--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -9,19 +9,40 @@
 import com.google.common.util.concurrent.ListenableFutureTask;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mtbs3d.minecrift.api.*;
+import com.mtbs3d.minecrift.gameplay.BowTracker;
+import com.mtbs3d.minecrift.gameplay.VRPlayer;
+import com.mtbs3d.minecrift.provider.*;
+import com.mtbs3d.minecrift.render.FBOParams;
+import com.mtbs3d.minecrift.render.RenderConfigException;
+import com.mtbs3d.minecrift.render.ShaderHelper;
+import com.mtbs3d.minecrift.settings.VRHotkeys;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.TextureSelector;
+
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.*;
 import io.netty.util.concurrent.GenericFutureListener;
+import jopenvr.VR_IVRCompositor_FnTable.ClearLastSubmittedFrame_callback;
+
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.text.DecimalFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -30,26 +51,18 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+
 import javax.imageio.ImageIO;
+import javax.vecmath.Color3f;
+
+import net.aib42.mumblelink.MumbleLink;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityClientPlayerMP;
-import net.minecraft.client.gui.FontRenderer;
-import net.minecraft.client.gui.GuiChat;
-import net.minecraft.client.gui.GuiControls;
-import net.minecraft.client.gui.GuiGameOver;
-import net.minecraft.client.gui.GuiIngame;
-import net.minecraft.client.gui.GuiIngameMenu;
-import net.minecraft.client.gui.GuiMainMenu;
-import net.minecraft.client.gui.GuiMemoryErrorScreen;
-import net.minecraft.client.gui.GuiScreen;
-import net.minecraft.client.gui.GuiSleepMP;
-import net.minecraft.client.gui.GuiWinGame;
-import net.minecraft.client.gui.GuiYesNo;
-import net.minecraft.client.gui.GuiYesNoCallback;
-import net.minecraft.client.gui.ScaledResolution;
+import net.minecraft.client.gui.*;
 import net.minecraft.client.gui.achievement.GuiAchievement;
 import net.minecraft.client.gui.inventory.GuiInventory;
 import net.minecraft.client.gui.stream.GuiStreamUnavailable;
@@ -97,6 +110,7 @@
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.stream.IStream;
 import net.minecraft.client.stream.NullStream;
 import net.minecraft.client.stream.TwitchStream;
@@ -127,6 +141,8 @@
 import net.minecraft.profiler.Profiler;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
+import net.minecraft.src.Config;
+import net.minecraft.src.Reflector;
 import net.minecraft.stats.AchievementList;
 import net.minecraft.stats.IStatStringFormat;
 import net.minecraft.stats.StatFileWriter;
@@ -142,6 +158,7 @@
 import net.minecraft.util.Session;
 import net.minecraft.util.Timer;
 import net.minecraft.util.Util;
+import net.minecraft.util.Vec3;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldProviderHell;
@@ -150,640 +167,936 @@
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
+import org.lwjgl.LWJGLUtil;
 import org.lwjgl.Sys;
+import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
-import org.lwjgl.opengl.ContextCapabilities;
-import org.lwjgl.opengl.Display;
-import org.lwjgl.opengl.DisplayMode;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL20;
-import org.lwjgl.opengl.GLContext;
-import org.lwjgl.opengl.OpenGLException;
-import org.lwjgl.opengl.PixelFormat;
+import org.lwjgl.input.Controllers;
+import org.lwjgl.opengl.*;
 import org.lwjgl.util.glu.GLU;
+import org.lwjgl.util.vector.Quaternion;
+
+import static java.lang.Math.ceil;
 
 public class Minecraft implements IPlayerUsage
 {
-    private static final Logger logger = LogManager.getLogger();
-    private static final ResourceLocation locationMojangPng = new ResourceLocation("textures/gui/title/mojang.png");
-    public static final boolean isRunningOnMac = Util.getOSType() == Util.EnumOS.OSX;
-
-    /** A 10MiB preallocation to ensure the heap is reasonably sized. */
-    public static byte[] memoryReserve = new byte[10485760];
-    private static final List macDisplayModes = Lists.newArrayList(new DisplayMode[] {new DisplayMode(2560, 1600), new DisplayMode(2880, 1800)});
-    private final File fileResourcepacks;
-    private final Multimap twitchDetails;
-    private ServerData currentServerData;
-
-    /** The RenderEngine instance used by Minecraft */
-    private TextureManager renderEngine;
-
-    /**
-     * Set to 'this' in Minecraft constructor; used by some settings get methods
-     */
-    private static Minecraft theMinecraft;
-    public PlayerControllerMP playerController;
-    private boolean fullscreen;
-    private boolean hasCrashed;
-
-    /** Instance of CrashReport. */
-    private CrashReport crashReporter;
-    public int displayWidth;
-    public int displayHeight;
-    private Timer timer = new Timer(20.0F);
-
-    /** Instance of PlayerUsageSnooper. */
-    private PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("client", this, MinecraftServer.getCurrentTimeMillis());
-    public WorldClient theWorld;
-    public RenderGlobal renderGlobal;
-    public EntityClientPlayerMP thePlayer;
-
-    /**
-     * The Entity from which the renderer determines the render viewpoint. Currently is always the parent Minecraft
-     * class's 'thePlayer' instance. Modification of its location, rotation, or other settings at render time will
-     * modify the camera likewise, with the caveat of triggering chunk rebuilds as it moves, making it unsuitable for
-     * changing the viewpoint mid-render.
-     */
-    public EntityLivingBase renderViewEntity;
-    public Entity pointedEntity;
-    public EffectRenderer effectRenderer;
-    private final Session session;
-    private boolean isGamePaused;
-
-    /** The font renderer used for displaying and measuring text */
-    public FontRenderer fontRendererObj;
-    public FontRenderer standardGalacticFontRenderer;
-
-    /** The GuiScreen that's being displayed at the moment. */
-    public GuiScreen currentScreen;
-    public LoadingScreenRenderer loadingScreen;
-    public EntityRenderer entityRenderer;
-
-    /** Mouse left click counter */
-    private int leftClickCounter;
-
-    /** Display width */
-    private int tempDisplayWidth;
-
-    /** Display height */
-    private int tempDisplayHeight;
-
-    /** Instance of IntegratedServer. */
-    private IntegratedServer theIntegratedServer;
-
-    /** Gui achievement */
-    public GuiAchievement guiAchievement;
-    public GuiIngame ingameGUI;
-
-    /** Skip render world */
-    public boolean skipRenderWorld;
-
-    /** The ray trace hit that the mouse is over. */
-    public MovingObjectPosition objectMouseOver;
-
-    /** The game settings that currently hold effect. */
-    public GameSettings gameSettings;
-
-    /** Mouse helper instance. */
-    public MouseHelper mouseHelper;
-    public final File mcDataDir;
-    private final File fileAssets;
-    private final String launchedVersion;
-    private final Proxy proxy;
-    private ISaveFormat saveLoader;
-
-    /**
-     * This is set to fpsCounter every debug screen update, and is shown on the debug screen. It's also sent as part of
-     * the usage snooping.
-     */
-    private static int debugFPS;
-
-    /**
-     * When you place a block, it's set to 6, decremented once per tick, when it's 0, you can place another block.
-     */
-    private int rightClickDelayTimer;
-
-    /**
-     * Checked in Minecraft's while(running) loop, if true it's set to false and the textures refreshed.
-     */
-    private boolean refreshTexturePacksScheduled;
-    private String serverName;
-    private int serverPort;
-
-    /**
-     * Does the actual gameplay have focus. If so then mouse and keys will effect the player instead of menus.
-     */
-    public boolean inGameHasFocus;
-    long systemTime = getSystemTime();
-
-    /** Join player counter */
-    private int joinPlayerCounter;
-    private final boolean jvm64bit;
-    private final boolean isDemo;
-    private NetworkManager myNetworkManager;
-    private boolean integratedServerIsRunning;
-
-    /** The profiler instance */
-    public final Profiler mcProfiler = new Profiler();
-
-    /**
-     * Keeps track of how long the debug crash keycombo (F3+C) has been pressed for, in order to crash after 10 seconds.
-     */
-    private long debugCrashKeyPressTime = -1L;
-    private IReloadableResourceManager mcResourceManager;
-    private final IMetadataSerializer metadataSerializer_ = new IMetadataSerializer();
-    private List defaultResourcePacks = Lists.newArrayList();
-    private DefaultResourcePack mcDefaultResourcePack;
-    private ResourcePackRepository mcResourcePackRepository;
-    private LanguageManager mcLanguageManager;
-    private IStream stream;
-    private Framebuffer framebufferMc;
-    private TextureMap textureMapBlocks;
-    private SoundHandler mcSoundHandler;
-    private MusicTicker mcMusicTicker;
-    private ResourceLocation mojangLogo;
-    private final MinecraftSessionService sessionService;
-    private SkinManager skinManager;
-    private final Queue scheduledTasks = Queues.newArrayDeque();
-    private final Thread mcThread = Thread.currentThread();
-
-    /**
-     * Set to true to keep the game loop running. Set to false by shutdown() to allow the game loop to exit cleanly.
-     */
-    volatile boolean running = true;
-
-    /** String that shows the debug information */
-    public String debug = "";
-
-    /** Approximate time (in ms) of last update to debug string */
-    long debugUpdateTime = getSystemTime();
-
-    /** holds the current fps */
-    int fpsCounter;
-    long prevFrameTime = -1L;
-
-    /** Profiler currently displayed in the debug screen pie chart */
-    private String debugProfilerName = "root";
-    private static final String __OBFID = "CL_00000631";
-
-    public Minecraft(Session sessionIn, int displayWidth, int displayHeight, boolean fullscreen, boolean isDemo, File dataDir, File assetsDir, File resourcePackDir, Proxy proxy, String version, Multimap twitchDetails, String assetsJsonVersion)
-    {
-        theMinecraft = this;
-        this.mcDataDir = dataDir;
-        this.fileAssets = assetsDir;
-        this.fileResourcepacks = resourcePackDir;
-        this.launchedVersion = version;
-        this.twitchDetails = twitchDetails;
-        this.mcDefaultResourcePack = new DefaultResourcePack((new ResourceIndex(assetsDir, assetsJsonVersion)).func_152782_a());
-        this.addDefaultResourcePack();
-        this.proxy = proxy == null ? Proxy.NO_PROXY : proxy;
-        this.sessionService = (new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
-        this.startTimerHackThread();
-        this.session = sessionIn;
-        logger.info("Setting user: " + sessionIn.getUsername());
-        logger.info("(Session ID is " + sessionIn.getSessionID() + ")");
-        this.isDemo = isDemo;
-        this.displayWidth = displayWidth;
-        this.displayHeight = displayHeight;
-        this.tempDisplayWidth = displayWidth;
-        this.tempDisplayHeight = displayHeight;
-        this.fullscreen = fullscreen;
-        this.jvm64bit = isJvm64bit();
-        ImageIO.setUseCache(false);
-        Bootstrap.register();
-    }
-
-    private static boolean isJvm64bit()
-    {
-        String[] var0 = new String[] {"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};
-        String[] var1 = var0;
-        int var2 = var0.length;
-
-        for (int var3 = 0; var3 < var2; ++var3)
-        {
-            String var4 = var1[var3];
-            String var5 = System.getProperty(var4);
-
-            if (var5 != null && var5.contains("64"))
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public Framebuffer getFramebuffer()
-    {
-        return this.framebufferMc;
-    }
-
-    private void startTimerHackThread()
-    {
-        Thread var1 = new Thread("Timer hack thread")
-        {
-            private static final String __OBFID = "CL_00000632";
-            public void run()
-            {
-                while (Minecraft.this.running)
-                {
-                    try
-                    {
-                        Thread.sleep(2147483647L);
-                    }
-                    catch (InterruptedException var2)
-                    {
-                        ;
-                    }
-                }
-            }
-        };
-        var1.setDaemon(true);
-        var1.start();
-    }
-
-    public void crashed(CrashReport crash)
-    {
-        this.hasCrashed = true;
-        this.crashReporter = crash;
-    }
-
-    /**
-     * Wrapper around displayCrashReportInternal
-     */
-    public void displayCrashReport(CrashReport crashReportIn)
-    {
-        File var2 = new File(getMinecraft().mcDataDir, "crash-reports");
-        File var3 = new File(var2, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
-        System.out.println(crashReportIn.getCompleteReport());
-
-        if (crashReportIn.getFile() != null)
-        {
-            System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + crashReportIn.getFile());
-            System.exit(-1);
-        }
-        else if (crashReportIn.saveToFile(var3))
-        {
-            System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + var3.getAbsolutePath());
-            System.exit(-1);
-        }
-        else
-        {
-            System.out.println("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
-        }
-    }
-
-    public void setServer(String serverHostname, int serverPort)
-    {
-        this.serverName = serverHostname;
-        this.serverPort = serverPort;
-    }
-
-    /**
-     * Starts the game: initializes the canvas, the title, the settings, etcetera.
-     */
-    private void startGame() throws LWJGLException
-    {
-        this.gameSettings = new GameSettings(this, this.mcDataDir);
-
-        if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
-        {
-            this.displayWidth = this.gameSettings.overrideWidth;
-            this.displayHeight = this.gameSettings.overrideHeight;
-        }
-
-        if (this.fullscreen)
-        {
-            Display.setFullscreen(true);
-            this.displayWidth = Display.getDisplayMode().getWidth();
-            this.displayHeight = Display.getDisplayMode().getHeight();
-
-            if (this.displayWidth <= 0)
-            {
-                this.displayWidth = 1;
-            }
-
-            if (this.displayHeight <= 0)
-            {
-                this.displayHeight = 1;
-            }
-        }
-        else
-        {
-            Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
-        }
-
-        Display.setResizable(true);
-        Display.setTitle("Minecraft 1.7.10");
-        logger.info("LWJGL Version: " + Sys.getVersion());
-        Util.EnumOS var1 = Util.getOSType();
-
-        if (var1 != Util.EnumOS.OSX)
-        {
-            try
-            {
-                InputStream var2 = this.mcDefaultResourcePack.func_152780_c(new ResourceLocation("icons/icon_16x16.png"));
-                InputStream var3 = this.mcDefaultResourcePack.func_152780_c(new ResourceLocation("icons/icon_32x32.png"));
-
-                if (var2 != null && var3 != null)
-                {
-                    Display.setIcon(new ByteBuffer[] {this.readImageToBuffer(var2), this.readImageToBuffer(var3)});
-                }
-            }
-            catch (IOException var8)
-            {
-                logger.error("Couldn\'t set icon", var8);
-            }
-        }
-
-        try
-        {
-            Display.create((new PixelFormat()).withDepthBits(24));
-        }
-        catch (LWJGLException var7)
-        {
-            logger.error("Couldn\'t set pixel format", var7);
-
-            try
-            {
-                Thread.sleep(1000L);
-            }
-            catch (InterruptedException var6)
-            {
-                ;
-            }
-
-            if (this.fullscreen)
-            {
-                this.updateDisplayMode();
-            }
-
-            Display.create();
-        }
-
-        OpenGlHelper.initializeTextures();
-
-        try
-        {
-            this.stream = new TwitchStream(this, (String)Iterables.getFirst(this.twitchDetails.get("twitch_access_token"), (Object)null));
-        }
-        catch (Throwable var5)
-        {
-            this.stream = new NullStream(var5);
-            logger.error("Couldn\'t initialize twitch stream");
-        }
-
-        this.framebufferMc = new Framebuffer(this.displayWidth, this.displayHeight, true);
-        this.framebufferMc.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
-        this.guiAchievement = new GuiAchievement(this);
-        this.metadataSerializer_.registerMetadataSectionType(new TextureMetadataSectionSerializer(), TextureMetadataSection.class);
-        this.metadataSerializer_.registerMetadataSectionType(new FontMetadataSectionSerializer(), FontMetadataSection.class);
-        this.metadataSerializer_.registerMetadataSectionType(new AnimationMetadataSectionSerializer(), AnimationMetadataSection.class);
-        this.metadataSerializer_.registerMetadataSectionType(new PackMetadataSectionSerializer(), PackMetadataSection.class);
-        this.metadataSerializer_.registerMetadataSectionType(new LanguageMetadataSectionSerializer(), LanguageMetadataSection.class);
-        this.saveLoader = new AnvilSaveConverter(new File(this.mcDataDir, "saves"));
-        this.mcResourcePackRepository = new ResourcePackRepository(this.fileResourcepacks, new File(this.mcDataDir, "server-resource-packs"), this.mcDefaultResourcePack, this.metadataSerializer_, this.gameSettings);
-        this.mcResourceManager = new SimpleReloadableResourceManager(this.metadataSerializer_);
-        this.mcLanguageManager = new LanguageManager(this.metadataSerializer_, this.gameSettings.language);
-        this.mcResourceManager.registerReloadListener(this.mcLanguageManager);
-        this.refreshResources();
-        this.renderEngine = new TextureManager(this.mcResourceManager);
-        this.mcResourceManager.registerReloadListener(this.renderEngine);
-        this.skinManager = new SkinManager(this.renderEngine, new File(this.fileAssets, "skins"), this.sessionService);
-        this.loadScreen();
-        this.mcSoundHandler = new SoundHandler(this.mcResourceManager, this.gameSettings);
-        this.mcResourceManager.registerReloadListener(this.mcSoundHandler);
-        this.mcMusicTicker = new MusicTicker(this);
-        this.fontRendererObj = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii.png"), this.renderEngine, false);
-
-        if (this.gameSettings.language != null)
-        {
-            this.fontRendererObj.setUnicodeFlag(this.isUnicode());
-            this.fontRendererObj.setBidiFlag(this.mcLanguageManager.isCurrentLanguageBidirectional());
-        }
-
-        this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii_sga.png"), this.renderEngine, false);
-        this.mcResourceManager.registerReloadListener(this.fontRendererObj);
-        this.mcResourceManager.registerReloadListener(this.standardGalacticFontRenderer);
-        this.mcResourceManager.registerReloadListener(new GrassColorReloadListener());
-        this.mcResourceManager.registerReloadListener(new FoliageColorReloadListener());
-        RenderManager.instance.itemRenderer = new ItemRenderer(this);
-        this.entityRenderer = new EntityRenderer(this, this.mcResourceManager);
-        this.mcResourceManager.registerReloadListener(this.entityRenderer);
-        AchievementList.openInventory.setStatStringFormatter(new IStatStringFormat()
-        {
-            private static final String __OBFID = "CL_00000639";
-            public String formatString(String p_74535_1_)
-            {
-                try
-                {
-                    return String.format(p_74535_1_, new Object[] {GameSettings.getKeyDisplayString(Minecraft.this.gameSettings.keyBindInventory.getKeyCode())});
-                }
-                catch (Exception var3)
-                {
-                    return "Error: " + var3.getLocalizedMessage();
-                }
-            }
-        });
-        this.mouseHelper = new MouseHelper();
-        this.checkGLError("Pre startup");
-        GL11.glEnable(GL11.GL_TEXTURE_2D);
-        GL11.glShadeModel(GL11.GL_SMOOTH);
-        GL11.glClearDepth(1.0D);
-        GL11.glEnable(GL11.GL_DEPTH_TEST);
-        GL11.glDepthFunc(GL11.GL_LEQUAL);
-        GL11.glEnable(GL11.GL_ALPHA_TEST);
-        GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
-        GL11.glCullFace(GL11.GL_BACK);
-        GL11.glMatrixMode(GL11.GL_PROJECTION);
-        GL11.glLoadIdentity();
-        GL11.glMatrixMode(GL11.GL_MODELVIEW);
-        this.checkGLError("Startup");
-        this.renderGlobal = new RenderGlobal(this);
-        this.textureMapBlocks = new TextureMap(0, "textures/blocks");
-        this.textureMapBlocks.setAnisotropicFiltering(this.gameSettings.anisotropicFiltering);
-        this.textureMapBlocks.setMipmapLevels(this.gameSettings.mipmapLevels);
-        this.renderEngine.loadTextureMap(TextureMap.locationBlocksTexture, this.textureMapBlocks);
-        this.renderEngine.loadTextureMap(TextureMap.locationItemsTexture, new TextureMap(1, "textures/items"));
-        GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
-        this.effectRenderer = new EffectRenderer(this.theWorld, this.renderEngine);
-        this.checkGLError("Post startup");
-        this.ingameGUI = new GuiIngame(this);
-
-        if (this.serverName != null)
-        {
-            this.displayGuiScreen(new GuiConnecting(new GuiMainMenu(), this, this.serverName, this.serverPort));
-        }
-        else
-        {
-            this.displayGuiScreen(new GuiMainMenu());
-        }
-
-        this.renderEngine.deleteTexture(this.mojangLogo);
-        this.mojangLogo = null;
-        this.loadingScreen = new LoadingScreenRenderer(this);
-
-        if (this.gameSettings.fullScreen && !this.fullscreen)
-        {
-            this.toggleFullscreen();
-        }
-
-        try
-        {
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
-        }
-        catch (OpenGLException var4)
-        {
-            this.gameSettings.enableVsync = false;
-            this.gameSettings.saveOptions();
-        }
-    }
-
-    public boolean isUnicode()
-    {
-        return this.mcLanguageManager.isCurrentLocaleUnicode() || this.gameSettings.forceUnicodeFont;
-    }
-
-    public void refreshResources()
-    {
-        ArrayList var1 = Lists.newArrayList(this.defaultResourcePacks);
-        Iterator var2 = this.mcResourcePackRepository.getRepositoryEntries().iterator();
-
-        while (var2.hasNext())
-        {
-            ResourcePackRepository.Entry var3 = (ResourcePackRepository.Entry)var2.next();
-            var1.add(var3.getResourcePack());
-        }
-
-        if (this.mcResourcePackRepository.getResourcePackInstance() != null)
-        {
-            var1.add(this.mcResourcePackRepository.getResourcePackInstance());
-        }
-
-        try
-        {
-            this.mcResourceManager.reloadResources(var1);
-        }
-        catch (RuntimeException var4)
-        {
-            logger.info("Caught error stitching, removing all assigned resourcepacks", var4);
-            var1.clear();
-            var1.addAll(this.defaultResourcePacks);
-            this.mcResourcePackRepository.func_148527_a(Collections.emptyList());
-            this.mcResourceManager.reloadResources(var1);
-            this.gameSettings.resourcePacks.clear();
-            this.gameSettings.saveOptions();
-        }
-
-        this.mcLanguageManager.parseLanguageMetadata(var1);
-
-        if (this.renderGlobal != null)
-        {
-            this.renderGlobal.loadRenderers();
-        }
-    }
-
-    private void addDefaultResourcePack()
-    {
-        this.defaultResourcePacks.add(this.mcDefaultResourcePack);
-    }
-
-    private ByteBuffer readImageToBuffer(InputStream imageStream) throws IOException
-    {
-        BufferedImage var2 = ImageIO.read(imageStream);
-        int[] var3 = var2.getRGB(0, 0, var2.getWidth(), var2.getHeight(), (int[])null, 0, var2.getWidth());
-        ByteBuffer var4 = ByteBuffer.allocate(4 * var3.length);
-        int[] var5 = var3;
-        int var6 = var3.length;
-
-        for (int var7 = 0; var7 < var6; ++var7)
-        {
-            int var8 = var5[var7];
-            var4.putInt(var8 << 8 | var8 >> 24 & 255);
-        }
-
-        var4.flip();
-        return var4;
-    }
-
-    private void updateDisplayMode() throws LWJGLException
-    {
-        HashSet var1 = new HashSet();
-        Collections.addAll(var1, Display.getAvailableDisplayModes());
-        DisplayMode var2 = Display.getDesktopDisplayMode();
-
-        if (!var1.contains(var2) && Util.getOSType() == Util.EnumOS.OSX)
-        {
-            Iterator var3 = macDisplayModes.iterator();
-
-            while (var3.hasNext())
-            {
-                DisplayMode var4 = (DisplayMode)var3.next();
-                boolean var5 = true;
-                Iterator var6 = var1.iterator();
-                DisplayMode var7;
-
-                while (var6.hasNext())
-                {
-                    var7 = (DisplayMode)var6.next();
-
-                    if (var7.getBitsPerPixel() == 32 && var7.getWidth() == var4.getWidth() && var7.getHeight() == var4.getHeight())
-                    {
-                        var5 = false;
-                        break;
-                    }
-                }
-
-                if (!var5)
-                {
-                    var6 = var1.iterator();
-
-                    while (var6.hasNext())
-                    {
-                        var7 = (DisplayMode)var6.next();
-
-                        if (var7.getBitsPerPixel() == 32 && var7.getWidth() == var4.getWidth() / 2 && var7.getHeight() == var4.getHeight() / 2)
-                        {
-                            var2 = var7;
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-
-        Display.setDisplayMode(var2);
-        this.displayWidth = var2.getWidth();
-        this.displayHeight = var2.getHeight();
-    }
-
-    /**
-     * Displays a new screen.
-     */
-    private void loadScreen() throws LWJGLException
-    {
-        ScaledResolution var1 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
-        int var2 = var1.getScaleFactor();
-        Framebuffer var3 = new Framebuffer(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2, true);
-        var3.bindFramebuffer(false);
-        GL11.glMatrixMode(GL11.GL_PROJECTION);
-        GL11.glLoadIdentity();
-        GL11.glOrtho(0.0D, (double)var1.getScaledWidth(), (double)var1.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);
-        GL11.glMatrixMode(GL11.GL_MODELVIEW);
-        GL11.glLoadIdentity();
-        GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
-        GL11.glDisable(GL11.GL_LIGHTING);
-        GL11.glDisable(GL11.GL_FOG);
-        GL11.glDisable(GL11.GL_DEPTH_TEST);
-        GL11.glEnable(GL11.GL_TEXTURE_2D);
-
-        try
+	private static final Logger logger = LogManager.getLogger();
+	private static final ResourceLocation locationMojangPng = new ResourceLocation("textures/gui/title/mojang.png");
+	public static final boolean isRunningOnMac = Util.getOSType() == Util.EnumOS.OSX;
+
+	/** A 10MiB preallocation to ensure the heap is reasonably sized. */
+	public static byte[] memoryReserve = new byte[10485760];
+	private static final List macDisplayModes = Lists.newArrayList(new DisplayMode[] {new DisplayMode(2560, 1600), new DisplayMode(2880, 1800)});
+	private final File fileResourcepacks;
+	private final Multimap twitchDetails;
+	private ServerData currentServerData;
+
+	/** The RenderEngine instance used by Minecraft */
+	/** MINECRIFT FORGE **/
+	public TextureManager renderEngine;
+	/** END MINECRIFT FORGE **/
+	/**
+	 * Set to 'this' in Minecraft constructor; used by some settings get methods
+	 */
+	private static Minecraft theMinecraft;
+	public PlayerControllerMP playerController;
+	private boolean fullscreen;
+	private boolean hasCrashed;
+
+	/** Instance of CrashReport. */
+	private CrashReport crashReporter;
+	public int displayWidth;
+	public int displayHeight;
+	private Timer timer = new Timer(20.0F);
+
+	/** Instance of PlayerUsageSnooper. */
+	private PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("client", this, MinecraftServer.getCurrentTimeMillis());
+	public WorldClient theWorld;
+	public RenderGlobal renderGlobal;
+	public EntityClientPlayerMP thePlayer;
+
+	/**
+	 * The Entity from which the renderer determines the render viewpoint. Currently is always the parent Minecraft
+	 * class's 'thePlayer' instance. Modification of its location, rotation, or other settings at render time will
+	 * modify the camera likewise, with the caveat of triggering chunk rebuilds as it moves, making it unsuitable for
+	 * changing the viewpoint mid-render.
+	 */
+	public EntityLivingBase renderViewEntity;
+	public Entity pointedEntity;
+	public EffectRenderer effectRenderer;
+	private final Session session;
+	private boolean isGamePaused;
+
+	/** The font renderer used for displaying and measuring text */
+	public FontRenderer fontRendererObj;
+	public FontRenderer standardGalacticFontRenderer;
+
+	/** The GuiScreen that's being displayed at the moment. */
+	public GuiScreen currentScreen;
+	public LoadingScreenRenderer loadingScreen;
+	public EntityRenderer entityRenderer;
+
+	/** Mouse left click counter */
+	private int leftClickCounter;
+	
+	/** Drop click counter */
+	private int dropCounter;
+
+	/** Display width */
+	private int tempDisplayWidth;
+
+	/** Display height */
+	private int tempDisplayHeight;
+
+	/** Instance of IntegratedServer. */
+	private IntegratedServer theIntegratedServer;
+
+	/** Gui achievement */
+	public GuiAchievement guiAchievement;
+	public GuiIngame ingameGUI;
+
+	/** Skip render world */
+	public boolean skipRenderWorld;
+
+	/** The ray trace hit that the mouse is over. */
+	public MovingObjectPosition objectMouseOver;
+
+	// VIVE START - teleport movement
+	public VRPlayer vrPlayer = new VRPlayer();
+	// VIVE END - teleport movement
+
+	// VIVE START - vive ui debugging
+	public float guiU;
+	public float guiV;
+	public float intersectDist;
+	public float pointOnPlaneX;
+	public float pointOnPlaneY;
+	public float pointOnPlaneZ;
+	public float guiTopLeftX;
+	public float guiTopLeftY;
+	public float guiTopLeftZ;
+	public float guiTopRightX;
+	public float guiTopRightY;
+	public float guiTopRightZ;
+	public float controllerPosX;
+	public float controllerPosY;
+	public float controllerPosZ;
+	// VIVE END - vive ui debugging
+
+	/** The game settings that currently hold effect. */
+	public GameSettings gameSettings;
+
+	/** Mouse helper instance. */
+	public MouseHelper mouseHelper;
+	public final File mcDataDir;
+	private final File fileAssets;
+	private final String launchedVersion;
+	private final Proxy proxy;
+	private ISaveFormat saveLoader;
+
+	public BowTracker bowTracker = new BowTracker(); 
+	
+	/**
+	 * This is set to fpsCounter every debug screen update, and is shown on the debug screen. It's also sent as part of
+	 * the usage snooping.
+	 */
+	private static int debugFPS;
+
+	/**
+	 * When you place a block, it's set to 6, decremented once per tick, when it's 0, you can place another block.
+	 */
+	private int rightClickDelayTimer;
+
+	/**
+	 * Checked in Minecraft's while(running) loop, if true it's set to false and the textures refreshed.
+	 */
+	private boolean refreshTexturePacksScheduled;
+	private String serverName;
+	private int serverPort;
+
+	/**
+	 * Does the actual gameplay have focus. If so then mouse and keys will effect the player instead of menus.
+	 */
+	public boolean inGameHasFocus;
+	long systemTime = getSystemTime();
+
+	/** Join player counter */
+	private int joinPlayerCounter;
+	private final boolean jvm64bit;
+	private final boolean isDemo;
+	private NetworkManager myNetworkManager;
+	private boolean integratedServerIsRunning;
+
+	/** The profiler instance */
+	public final Profiler mcProfiler = new Profiler();
+
+	/**
+	 * Keeps track of how long the debug crash keycombo (F3+C) has been pressed for, in order to crash after 10 seconds.
+	 */
+	private long debugCrashKeyPressTime = -1L;
+	private IReloadableResourceManager mcResourceManager;
+	private final IMetadataSerializer metadataSerializer_ = new IMetadataSerializer();
+	private List defaultResourcePacks = Lists.newArrayList();
+	private DefaultResourcePack mcDefaultResourcePack;
+	private ResourcePackRepository mcResourcePackRepository;
+	private LanguageManager mcLanguageManager;
+	private IStream stream;
+	private Framebuffer framebufferMc;
+	private TextureMap textureMapBlocks;
+	/** MINECRIFT */
+	public  SoundHandler mcSoundHandler; 
+	/** END MINECRIFT */
+	private MusicTicker mcMusicTicker;
+	public ResourceLocation mojangLogo;
+	private final MinecraftSessionService sessionService;
+	private SkinManager skinManager;
+	private final Queue scheduledTasks = Queues.newArrayDeque();
+	private final Thread mcThread = Thread.currentThread();
+
+	/**
+	 * Set to true to keep the game loop running. Set to false by shutdown() to allow the game loop to exit cleanly.
+	 */
+	volatile boolean running = true;
+
+	/** String that shows the debug information */
+	public String debug = "";
+
+	/** Approximate time (in ms) of last update to debug string */
+	long debugUpdateTime = getSystemTime();
+
+	/** holds the current fps */
+	int fpsCounter;
+	long prevFrameTime = -1L;
+
+	/** Profiler currently displayed in the debug screen pie chart */
+	private String debugProfilerName = "root";
+	private static final String __OBFID = "CL_00000631";
+
+	/** MINECRIFT */
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float)(Math.PI/180);
+	public boolean reinitFramebuffers = true;
+	public Framebuffer[] framebuffers = new Framebuffer[2];
+	public Framebuffer guiFramebuffer = null;
+	public int lastDisplayFBWidth = 0;
+	public int lastDisplayFBHeight = 0;
+	public int displayFBWidth;     /* Actual width of the display buffer */
+	public int displayFBHeight;    /* Actual height of the display buffer */
+	public int mirrorFBWidth;     /* Actual width of the display buffer */
+	public int mirrorFBHeight;    /* Actual height of the display buffer */
+	public int viewPortCount = 2;
+	public ShaderGroup[] shaderGroup = new ShaderGroup[2];
+	public int lastShaderIndex = -1;
+	public Object displayImpl = null;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public IHMDInfo hmdInfo;
+	public IStereoProvider stereoProvider;
+	public IOrientationProvider headTracker;
+	public IEyePositionProvider positionTracker;
+	public IBodyAimController lookaimController;
+	public VRSettings vrSettings;
+	public MumbleLink mumbleLink;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+	public boolean lastEnableVsync = true;
+	public int lastMirrorSetting = -1;
+	//public EyeRenderParams eyeRenderParams = null;
+	public EyeType currentEye = EyeType.ovrEye_Left;
+	public Posef currentEyePose = null;
+	public Cursor nativeMouseCursor = null;
+	public boolean lastShowMouseNative = true;
+	public Cursor invisibleMouseCursor = null;
+	public GLConfig glConfig = new GLConfig();
+	public long lastWindow = 0;
+	public int lastRenderDistanceChunks = -1;
+	public boolean lastFogFancy = true;
+	public boolean lastFogFast = false;
+	public float lastWorldScale = 0f;
+	public int lastDimensionId = -1;
+	public SoundManager sndManager = null;
+	public Sizei[] EyeTextureSize = new Sizei[2];
+	public boolean hydraLibsAvailable = false;
+	public double PredictedDisplayTimeSeconds = 0d;
+	public int _Lanczos_shaderProgramId = -1;
+	public int _LanczosShader_texelWidthOffsetUniform = -1;
+	public int _LanczosShader_texelHeightOffsetUniform = -1;
+	public int _LanczosShader_inputImageTextureUniform = -1;
+	public FBOParams mirrorFB = null;
+	public FBOParams[] fsaaFirstPassResultFBO = new FBOParams[2];
+	public FBOParams[] fsaaSecondPassResultFBO = new FBOParams[2];
+	public Sizei[] distortionRenderTargetSize = new Sizei[2];
+	public final float OCULUS_RED_COLOUR_COMPONENT = (1f/255f)*61f;
+	public final float OCULUS_GREEN_COLOUR_COMPONENT = (1f/255f)*61f;
+	public final float OCULUS_BLUE_COLOUR_COMPONENT = (1f/255f)*61f;
+	public float RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+	public float GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+	public float BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+	public boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	public Framebuffer splash;
+	public float splashFadeAlpha = 0;
+	public int lastGuiScale = -1;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public TextureSelector[] renderTexProvider = new TextureSelector[2];
+	public TextureSelector mirrorTexProvider;
+	public int currentDisplayWidth = 0;
+	public int currentDisplayHeight = 0;
+	public boolean visible = true;
+	public ErrorHelper errorHelper;
+	public static final String RENDER_SETUP_FAILURE_MESSAGE = "Failed to initialise stereo rendering plugin: ";
+	public static final int ERROR_DISPLAY_TIME_SECS = 10;
+
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do not modify here.
+	 * Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "ViveCraft 1.7.10 Vivecraft-jrbudda17";
+	/* end version */
+	/** END MINECRIFT */
+
+	public Minecraft(Session sessionIn, int displayWidth, int displayHeight, boolean fullscreen, boolean isDemo, File dataDir, File assetsDir, File resourcePackDir, Proxy proxy, String version, Multimap twitchDetails, String assetsJsonVersion)
+	{
+		theMinecraft = this;
+		/** MINECRIFT **/
+		displayWidth = 1280;
+		displayHeight = 720;
+		/** END MINECRIFT **/
+		this.mcDataDir = dataDir;
+		this.fileAssets = assetsDir;
+		this.fileResourcepacks = resourcePackDir;
+		this.launchedVersion = version;
+		this.twitchDetails = twitchDetails;
+		this.mcDefaultResourcePack = new DefaultResourcePack((new ResourceIndex(assetsDir, assetsJsonVersion)).func_152782_a());
+		this.addDefaultResourcePack();
+		this.proxy = proxy == null ? Proxy.NO_PROXY : proxy;
+		this.sessionService = (new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
+		this.startTimerHackThread();
+		this.session = sessionIn;
+		logger.info("Setting user: " + sessionIn.getUsername());
+		logger.info("(Session ID is " + sessionIn.getSessionID() + ")");
+		this.isDemo = isDemo;
+		this.displayWidth = displayWidth;
+		this.displayHeight = displayHeight;
+		this.tempDisplayWidth = displayWidth;
+		this.tempDisplayHeight = displayHeight;
+		this.fullscreen = fullscreen;
+		this.jvm64bit = isJvm64bit();
+		ImageIO.setUseCache(false);
+		Bootstrap.register();
+		/** MINECRIFT **/
+		VRSettings.initSettings(this, this.mcDataDir);
+		renderTexProvider[0] = new TextureSelector();
+		renderTexProvider[1] = new TextureSelector();
+		mirrorTexProvider    = new TextureSelector();
+		if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+			vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+			vrSettings.badStereoProviderPluginID = "";
+			vrSettings.saveOptions();
+		}
+		/** END MINECRIFT **/
+	}
+
+	private static boolean isJvm64bit()
+	{
+		String[] var0 = new String[] {"sun.arch.data.model", "com.ibm.vm.bitmode", "os.arch"};
+		String[] var1 = var0;
+		int var2 = var0.length;
+
+		for (int var3 = 0; var3 < var2; ++var3)
+		{
+			String var4 = var1[var3];
+			String var5 = System.getProperty(var4);
+
+			if (var5 != null && var5.contains("64"))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	public Framebuffer getFramebuffer()
+	{
+		return this.framebufferMc;
+	}
+
+	private void startTimerHackThread()
+	{
+		Thread var1 = new Thread("Timer hack thread")
+		{
+			private static final String __OBFID = "CL_00000632";
+			public void run()
+			{
+				while (Minecraft.this.running)
+				{
+					try
+					{
+						Thread.sleep(2147483647L);
+					}
+					catch (InterruptedException var2)
+					{
+						;
+					}
+				}
+			}
+		};
+		var1.setDaemon(true);
+		var1.start();
+	}
+
+	public void crashed(CrashReport crash)
+	{
+		this.hasCrashed = true;
+		this.crashReporter = crash;
+	}
+
+	/**
+	 * Wrapper around displayCrashReportInternal
+	 */
+	public void displayCrashReport(CrashReport crashReportIn)
+	{
+		File var2 = new File(getMinecraft().mcDataDir, "crash-reports");
+		File var3 = new File(var2, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
+		System.out.println(crashReportIn.getCompleteReport());
+		/** MINECRIFT FORGE **/
+		int retVal;
+		if (crashReportIn.getFile() != null)
+		{
+			System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + crashReportIn.getFile());
+			retVal = -1;
+		}
+		else if (crashReportIn.saveToFile(var3))
+		{
+			System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + var3.getAbsolutePath());
+			retVal = -1;
+		}
+		else
+		{
+			System.out.println("#@?@# Game crashed! Crash report could not be saved. #@?@#");
+			retVal = -2;
+		}
+
+		Object fmlCommonHandler = null;
+		if( Reflector.FMLCommonHandler_instance.exists()) {
+			fmlCommonHandler = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+		}
+		if( fmlCommonHandler != null ) {
+			Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_handleExit, new Object[]{retVal});
+		}
+		else {
+			System.exit(retVal);
+		}
+		/** END MINECRIFT FORGE **/
+	}
+
+	public void setServer(String serverHostname, int serverPort)
+	{
+		this.serverName = serverHostname;
+		this.serverPort = serverPort;
+	}
+
+	/**
+	 * Starts the game: initializes the canvas, the title, the settings, etcetera.
+	 */
+	/** MINECRIFT **/
+	private void startGame() throws Exception
+	{
+		//this.gameSettings = new GameSettings(this, this.mcDataDir);    // All settings initialised in Minecraft.minecriftFirstInit()
+		/** END MINECRIFT **/
+
+		if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
+		{
+			this.displayWidth = this.gameSettings.overrideWidth;
+			this.displayHeight = this.gameSettings.overrideHeight;
+		}
+
+		if (this.fullscreen)
+		{
+			Display.setFullscreen(true);
+			this.displayWidth = Display.getDisplayMode().getWidth();
+			this.displayHeight = Display.getDisplayMode().getHeight();
+
+			if (this.displayWidth <= 0)
+			{
+				this.displayWidth = 1;
+			}
+
+			if (this.displayHeight <= 0)
+			{
+				this.displayHeight = 1;
+			}
+		}
+		else
+		{
+			Display.setDisplayMode(new DisplayMode(this.displayWidth, this.displayHeight));
+		}
+
+		Display.setResizable(true);
+		/** MINECRIFT */
+		Display.setTitle(this.minecriftVerString + " VR");
+		/** END MINECRIFT */
+		logger.info("LWJGL Version: " + Sys.getVersion());
+		Util.EnumOS var1 = Util.getOSType();
+
+		if (var1 != Util.EnumOS.OSX)
+		{
+			try
+			{
+				InputStream var2 = this.mcDefaultResourcePack.func_152780_c(new ResourceLocation("icons/icon_16x16.png"));
+				InputStream var3 = this.mcDefaultResourcePack.func_152780_c(new ResourceLocation("icons/icon_32x32.png"));
+
+				if (var2 != null && var3 != null)
+				{
+					Display.setIcon(new ByteBuffer[] {this.readImageToBuffer(var2), this.readImageToBuffer(var3)});
+				}
+			}
+			catch (IOException var8)
+			{
+				logger.error("Couldn\'t set icon", var8);
+			}
+		}
+
+		try
+		{
+			/** MINECRIFT FORGE **/
+			if (Reflector.ForgeHooksClient_createDisplay.exists()) {
+				Reflector.callVoid(Reflector.ForgeHooksClient_createDisplay, new Object[0]);
+			}
+			else {
+				Display.create((new PixelFormat()).withDepthBits(24));
+			}
+			/** END MINECRIFT FORGE **/
+		}
+		catch (LWJGLException var7)
+		{
+			logger.error("Couldn\'t set pixel format", var7);
+
+			try
+			{
+				Thread.sleep(1000L);
+			}
+			catch (InterruptedException var6)
+			{
+				;
+			}
+
+			if (this.fullscreen)
+			{
+				this.updateDisplayMode();
+			}
+
+			Display.create();
+		}
+
+		OpenGlHelper.initializeTextures();
+
+		try
+		{
+			this.stream = new TwitchStream(this, (String)Iterables.getFirst(this.twitchDetails.get("twitch_access_token"), (Object)null));
+		}
+		catch (Throwable var5)
+		{
+			this.stream = new NullStream(var5);
+			logger.error("Couldn\'t initialize twitch stream");
+		}
+
+		this.framebufferMc = new Framebuffer(this.displayWidth, this.displayHeight, true);
+		this.framebufferMc.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
+		this.guiAchievement = new GuiAchievement(this);
+		this.metadataSerializer_.registerMetadataSectionType(new TextureMetadataSectionSerializer(), TextureMetadataSection.class);
+		this.metadataSerializer_.registerMetadataSectionType(new FontMetadataSectionSerializer(), FontMetadataSection.class);
+		this.metadataSerializer_.registerMetadataSectionType(new AnimationMetadataSectionSerializer(), AnimationMetadataSection.class);
+		this.metadataSerializer_.registerMetadataSectionType(new PackMetadataSectionSerializer(), PackMetadataSection.class);
+		this.metadataSerializer_.registerMetadataSectionType(new LanguageMetadataSectionSerializer(), LanguageMetadataSection.class);
+		this.saveLoader = new AnvilSaveConverter(new File(this.mcDataDir, "saves"));
+		this.mcResourcePackRepository = new ResourcePackRepository(this.fileResourcepacks, new File(this.mcDataDir, "server-resource-packs"), this.mcDefaultResourcePack, this.metadataSerializer_, this.gameSettings);
+		this.mcResourceManager = new SimpleReloadableResourceManager(this.metadataSerializer_);
+		this.mcLanguageManager = new LanguageManager(this.metadataSerializer_, this.gameSettings.language);
+		this.mcResourceManager.registerReloadListener(this.mcLanguageManager);
+		/** MINECRIFT FORGE **/
+		Object fmlClientHandler = null;
+		if( Reflector.FMLClientHandler_instance.exists())
+		{
+			fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+		}
+		if( fmlClientHandler != null)
+		{
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_beginMinecraftLoading, new Object[] {this, this.defaultResourcePacks, this.mcResourceManager});
+		}
+		else {
+			this.refreshResources();
+		}
+		/** END MINECRIFT FORGE **/
+		this.renderEngine = new TextureManager(this.mcResourceManager);
+		this.mcResourceManager.registerReloadListener(this.renderEngine);
+		this.skinManager = new SkinManager(this.renderEngine, new File(this.fileAssets, "skins"), this.sessionService);
+		/** MINECRIFT FORGE **/
+		boolean Forge = Reflector.forgeExists();
+		if (Forge) {
+			//cpw.mods.fml.client.SplashProgress.drawVanillaScreen();
+			Reflector.callVoid(Reflector.FMLClientSplashProgress_drawVanillaScreen, new Object[] {});
+		}
+		else {
+			this.loadScreen();
+		}
+		/** END MINECRIFT FORGE **/
+		this.mcSoundHandler = new SoundHandler(this.mcResourceManager, this.gameSettings);
+		this.mcResourceManager.registerReloadListener(this.mcSoundHandler);
+		this.mcMusicTicker = new MusicTicker(this);
+		this.fontRendererObj = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii.png"), this.renderEngine, false);
+
+		if (this.gameSettings.language != null)
+		{
+			this.fontRendererObj.setUnicodeFlag(this.isUnicode());
+			this.fontRendererObj.setBidiFlag(this.mcLanguageManager.isCurrentLanguageBidirectional());
+		}
+		/** MINECRIFT */
+		initMinecrift();
+		/** END MINECRIFT */
+		this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii_sga.png"), this.renderEngine, false);
+		this.mcResourceManager.registerReloadListener(this.fontRendererObj);
+		this.mcResourceManager.registerReloadListener(this.standardGalacticFontRenderer);
+		this.mcResourceManager.registerReloadListener(new GrassColorReloadListener());
+		this.mcResourceManager.registerReloadListener(new FoliageColorReloadListener());
+		/** MINECRIFT FORGE **/
+		Object bar = null;
+		if (Forge) {
+			//cpw.mods.fml.common.ProgressManager.ProgressBar bar = cpw.mods.fml.common.ProgressManager.push("Rendering Setup", 9);
+			//bar.step("Loading Render Manager");
+			bar = Reflector.call(Reflector.FMLCommonProgressManager_push, new Object[] {"Rendering Setup", 9, true});
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Render Manager"});
+		}
+		/** END MINECRIFT FORGE **/
+		RenderManager.instance.itemRenderer = new ItemRenderer(this);
+		/** MINECRIFT FORGE **/
+		if (Forge) {
+			//bar.step("Loading Entity Renderer");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Entity Renderer"});
+		}
+		/** END MINECRIFT FORGE **/		
+		this.entityRenderer = new EntityRenderer(this, this.mcResourceManager);
+		this.mcResourceManager.registerReloadListener(this.entityRenderer);
+		AchievementList.openInventory.setStatStringFormatter(new IStatStringFormat()
+		{
+			private static final String __OBFID = "CL_00000639";
+			public String formatString(String p_74535_1_)
+			{
+				try
+				{
+					return String.format(p_74535_1_, new Object[] {GameSettings.getKeyDisplayString(Minecraft.this.gameSettings.keyBindInventory.getKeyCode())});
+				}
+				catch (Exception var3)
+				{
+					return "Error: " + var3.getLocalizedMessage();
+				}
+			}
+		});
+		/** MINECRIFT FORGE **/
+		if (Forge) {
+			//bar.step("Loading GL properties");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading GL properties"});
+		}
+		/** END MINECRIFT FORGE **/
+		this.mouseHelper = new MouseHelper();
+		this.checkGLError("Pre startup");
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+		GL11.glShadeModel(GL11.GL_SMOOTH);
+		GL11.glClearDepth(1.0D);
+		GL11.glEnable(GL11.GL_DEPTH_TEST);
+		GL11.glDepthFunc(GL11.GL_LEQUAL);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+		GL11.glCullFace(GL11.GL_BACK);
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glLoadIdentity();
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		this.checkGLError("Startup");
+		/** MINECRIFT SHADERS MOD **/
+		if (Reflector.shadersModExists()) {
+			//Shaders.startup(this);
+			Reflector.callVoid(Reflector.ShadersMod_Shaders_startup, new Object[] {this});
+		}
+		/** END MINECRIFT SHADERS MOD **/
+		/** MINECRIFT FORGE **/
+		if (Forge) {
+			//bar.step("Render Global instance");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Render Global instance"});
+		}
+
+		this.renderGlobal = new RenderGlobal(this);
+		if (Forge) {
+			//bar.step("Building Blocks Texture");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Building Blocks Texture"});
+		}
+		if (Forge) {
+			this.textureMapBlocks = new TextureMap(0, "textures/blocks", true);
+		}
+		else {
+			this.textureMapBlocks = new TextureMap(0, "textures/blocks");
+		}
+		if (Forge) {
+			//bar.step("Anisotropy and Mipmaps");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Anisotropy and Mipmaps"});
+		}
+		this.textureMapBlocks.setAnisotropicFiltering(this.gameSettings.anisotropicFiltering);
+		this.textureMapBlocks.setMipmapLevels(this.gameSettings.mipmapLevels);
+		if (Forge) {
+			//bar.step("Loading Blocks Texture");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Entity Renderer"});
+		}
+		this.renderEngine.loadTextureMap(TextureMap.locationBlocksTexture, this.textureMapBlocks);
+		if (Forge) {
+			//bar.step("Loading Items Texture");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Items Texture"});
+		}
+		if (Forge) {
+			this.renderEngine.loadTextureMap(TextureMap.locationItemsTexture, new TextureMap(1, "textures/items", true));
+		}
+		else {
+			this.renderEngine.loadTextureMap(TextureMap.locationItemsTexture, new TextureMap(1, "textures/items"));
+		}
+		if (Forge) {
+			//bar.step("Viewport");
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Viewport"});
+		}
+		GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
+		this.effectRenderer = new EffectRenderer(this.theWorld, this.renderEngine);
+		if( fmlClientHandler != null )
+		{
+			//cpw.mods.fml.common.ProgressManager.pop(bar);
+			Reflector.callVoid(Reflector.FMLCommonProgressManager_pop, new Object[]{bar});
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_finishMinecraftLoading, new Object[0]);
+		}
+		this.checkGLError("Post startup");
+		if( Reflector.ForgeGuiIngame.exists())
+		{
+			try {
+				this.ingameGUI = (GuiIngame)Reflector.ForgeGuiIngame_Constructor.getTargetConstructor().newInstance(new Object[]{this});
+			} catch (IllegalArgumentException e) {
+				e.printStackTrace();
+			} catch (InstantiationException e) {
+				e.printStackTrace();
+			} catch (IllegalAccessException e) {
+				e.printStackTrace();
+			} catch (InvocationTargetException e) {
+				e.printStackTrace();
+			}
+		}
+		else
+		{
+			this.ingameGUI = new GuiIngame(this);
+		}
+
+		if (this.serverName != null)
+		{
+			if( fmlClientHandler != null ) {
+				Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_connectToServerAtStartup, new Object[]{this.serverName, this.serverPort});
+			}
+			else {
+				this.displayGuiScreen(new GuiConnecting(new GuiMainMenu(), this, this.serverName, this.serverPort));
+			}
+		}
+		else if (this.vrSettings.firstLoad) {
+			// VIVE START - don't force options screen, player should try defaults first
+			//this.displayGuiScreen(new GuiMinecriftSettings(new GuiMainMenu(), vrSettings, gameSettings) );
+			this.displayGuiScreen(new GuiMainMenu());
+			// VIVE END - don't force options screen, player should try defaults first
+			this.vrSettings.firstLoad = false;
+		}
+		else
+		{
+			this.displayGuiScreen(new GuiMainMenu());
+		}
+
+		if (Forge) {
+			//cpw.mods.fml.client.SplashProgress.clearVanillaResources(renderEngine, mojangLogo);
+			Reflector.callVoid(Reflector.FMLClientSplashProgress_clearVanillaResources, new Object[] {renderEngine, mojangLogo});
+		}
+		else {
+			this.renderEngine.deleteTexture(this.mojangLogo);
+		}
+		this.mojangLogo = null;
+		this.loadingScreen = new LoadingScreenRenderer(this);
+
+		if( fmlClientHandler != null ) {
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_onInitializationComplete, new Object[0]);
+		}
+		/** END MINECRIFT FORGE **/
+		if (this.gameSettings.fullScreen && !this.fullscreen)
+		{
+			this.toggleFullscreen();
+		}
+
+		try
+		{
+			/** MINECRIFT */
+			//vsync needs to be false that showing the mirror image doesn't slow down the rendering for the rift.
+			//Oculus SDK handles vsync internally
+			Display.setVSyncEnabled(false);
+			/** END MINECRIFT */
+		}
+		catch (OpenGLException var4)
+		{
+			this.gameSettings.enableVsync = false;
+			this.gameSettings.saveOptions();
+		}
+	}
+
+	public boolean isUnicode()
+	{
+		return this.mcLanguageManager.isCurrentLocaleUnicode() || this.gameSettings.forceUnicodeFont;
+	}
+
+	public void refreshResources()
+	{
+		ArrayList var1 = Lists.newArrayList(this.defaultResourcePacks);
+		Iterator var2 = this.mcResourcePackRepository.getRepositoryEntries().iterator();
+
+		while (var2.hasNext())
+		{
+			ResourcePackRepository.Entry var3 = (ResourcePackRepository.Entry)var2.next();
+			var1.add(var3.getResourcePack());
+		}
+
+		if (this.mcResourcePackRepository.getResourcePackInstance() != null)
+		{
+			var1.add(this.mcResourcePackRepository.getResourcePackInstance());
+		}
+
+		try
+		{
+			this.mcResourceManager.reloadResources(var1);
+		}
+		catch (RuntimeException var4)
+		{
+			logger.info("Caught error stitching, removing all assigned resourcepacks", var4);
+			var1.clear();
+			var1.addAll(this.defaultResourcePacks);
+			this.mcResourcePackRepository.func_148527_a(Collections.emptyList());
+			this.mcResourceManager.reloadResources(var1);
+			this.gameSettings.resourcePacks.clear();
+			this.gameSettings.saveOptions();
+		}
+
+		this.mcLanguageManager.parseLanguageMetadata(var1);
+
+		if (this.renderGlobal != null)
+		{
+			this.renderGlobal.loadRenderers();
+		}
+	}
+
+	private void addDefaultResourcePack()
+	{
+		this.defaultResourcePacks.add(this.mcDefaultResourcePack);
+	}
+
+	private ByteBuffer readImageToBuffer(InputStream imageStream) throws IOException
+	{
+		BufferedImage var2 = ImageIO.read(imageStream);
+		int[] var3 = var2.getRGB(0, 0, var2.getWidth(), var2.getHeight(), (int[])null, 0, var2.getWidth());
+		ByteBuffer var4 = ByteBuffer.allocate(4 * var3.length);
+		int[] var5 = var3;
+		int var6 = var3.length;
+
+		for (int var7 = 0; var7 < var6; ++var7)
+		{
+			int var8 = var5[var7];
+			var4.putInt(var8 << 8 | var8 >> 24 & 255);
+		}
+
+		var4.flip();
+		return var4;
+	}
+
+	private void updateDisplayMode() throws LWJGLException
+	{
+		HashSet var1 = new HashSet();
+		Collections.addAll(var1, Display.getAvailableDisplayModes());
+		DisplayMode var2 = Display.getDesktopDisplayMode();
+
+		if (!var1.contains(var2) && Util.getOSType() == Util.EnumOS.OSX)
+		{
+			Iterator var3 = macDisplayModes.iterator();
+
+			while (var3.hasNext())
+			{
+				DisplayMode var4 = (DisplayMode)var3.next();
+				boolean var5 = true;
+				Iterator var6 = var1.iterator();
+				DisplayMode var7;
+
+				while (var6.hasNext())
+				{
+					var7 = (DisplayMode)var6.next();
+
+					if (var7.getBitsPerPixel() == 32 && var7.getWidth() == var4.getWidth() && var7.getHeight() == var4.getHeight())
+					{
+						var5 = false;
+						break;
+					}
+				}
+
+				if (!var5)
+				{
+					var6 = var1.iterator();
+
+					while (var6.hasNext())
+					{
+						var7 = (DisplayMode)var6.next();
+
+						if (var7.getBitsPerPixel() == 32 && var7.getWidth() == var4.getWidth() / 2 && var7.getHeight() == var4.getHeight() / 2)
+						{
+							var2 = var7;
+							break;
+						}
+					}
+				}
+			}
+		}
+
+		Display.setDisplayMode(var2);
+		this.displayWidth = var2.getWidth();
+		this.displayHeight = var2.getHeight();
+	}
+
+	/**
+	 * Displays a new screen.
+	 */
+	private void loadScreen() throws LWJGLException
+	{
+		ScaledResolution var1 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+		int var2 = var1.getScaleFactor();
+		Framebuffer var3 = new Framebuffer(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2, true);
+		var3.bindFramebuffer(false);
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glLoadIdentity();
+		GL11.glOrtho(0.0D, (double)var1.getScaledWidth(), (double)var1.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glLoadIdentity();
+		GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_FOG);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+		/** MINECRIFT */       // TODO REFACTOR! The loadScreen mods here and below are just to clear the screen to white... !
+		/*      try
         {
             this.mojangLogo = this.renderEngine.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(this.mcDefaultResourcePack.getInputStream(locationMojangPng))));
             this.renderEngine.bindTexture(this.mojangLogo);
@@ -791,2348 +1104,3857 @@
         catch (IOException var7)
         {
             logger.error("Unable to load logo: " + locationMojangPng, var7);
-        }
-
-        Tessellator var4 = Tessellator.instance;
-        var4.startDrawingQuads();
-        var4.setColorOpaque_I(16777215);
-        var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
-        var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
-        var4.addVertexWithUV((double)this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
-        var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
-        var4.draw();
-        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-        var4.setColorOpaque_I(16777215);
-        short var5 = 256;
-        short var6 = 256;
-        this.scaledTessellator((var1.getScaledWidth() - var5) / 2, (var1.getScaledHeight() - var6) / 2, 0, 0, var5, var6);
-        GL11.glDisable(GL11.GL_LIGHTING);
-        GL11.glDisable(GL11.GL_FOG);
-        var3.unbindFramebuffer();
-        var3.framebufferRender(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2);
-        GL11.glEnable(GL11.GL_ALPHA_TEST);
-        GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
-        GL11.glFlush();
-        this.resetSize();
-    }
-
-    /**
-     * Loads Tessellator with a scaled resolution
-     */
-    public void scaledTessellator(int width, int height, int width2, int height2, int stdTextureWidth, int stdTextureHeight)
-    {
-        float var7 = 0.00390625F;
-        float var8 = 0.00390625F;
-        Tessellator var9 = Tessellator.instance;
-        var9.startDrawingQuads();
-        var9.addVertexWithUV((double)(width + 0), (double)(height + stdTextureHeight), 0.0D, (double)((float)(width2 + 0) * var7), (double)((float)(height2 + stdTextureHeight) * var8));
-        var9.addVertexWithUV((double)(width + stdTextureWidth), (double)(height + stdTextureHeight), 0.0D, (double)((float)(width2 + stdTextureWidth) * var7), (double)((float)(height2 + stdTextureHeight) * var8));
-        var9.addVertexWithUV((double)(width + stdTextureWidth), (double)(height + 0), 0.0D, (double)((float)(width2 + stdTextureWidth) * var7), (double)((float)(height2 + 0) * var8));
-        var9.addVertexWithUV((double)(width + 0), (double)(height + 0), 0.0D, (double)((float)(width2 + 0) * var7), (double)((float)(height2 + 0) * var8));
-        var9.draw();
-    }
-
-    /**
-     * Returns the save loader that is currently being used
-     */
-    public ISaveFormat getSaveLoader()
-    {
-        return this.saveLoader;
-    }
-
-    /**
-     * Sets the argument GuiScreen as the main (topmost visible) screen.
-     */
-    public void displayGuiScreen(GuiScreen guiScreenIn)
-    {
-        if (this.currentScreen != null)
-        {
-            this.currentScreen.onGuiClosed();
-        }
-
-        if (guiScreenIn == null && this.theWorld == null)
-        {
-            guiScreenIn = new GuiMainMenu();
-        }
-        else if (guiScreenIn == null && this.thePlayer.getHealth() <= 0.0F)
-        {
-            guiScreenIn = new GuiGameOver();
-        }
-
-        if (guiScreenIn instanceof GuiMainMenu)
-        {
-            this.gameSettings.showDebugInfo = false;
-            this.ingameGUI.getChatGUI().clearChatMessages();
-        }
-
-        this.currentScreen = (GuiScreen)guiScreenIn;
-
-        if (guiScreenIn != null)
-        {
-            this.setIngameNotInFocus();
-            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
-            int var3 = var2.getScaledWidth();
-            int var4 = var2.getScaledHeight();
-            ((GuiScreen)guiScreenIn).setWorldAndResolution(this, var3, var4);
-            this.skipRenderWorld = false;
-        }
-        else
-        {
-            this.mcSoundHandler.resumeSounds();
-            this.setIngameFocus();
-        }
-    }
-
-    /**
-     * Checks for an OpenGL error. If there is one, prints the error ID and error string.
-     */
-    private void checkGLError(String message)
-    {
-        int var2 = GL11.glGetError();
-
-        if (var2 != 0)
-        {
-            String var3 = GLU.gluErrorString(var2);
-            logger.error("########## GL ERROR ##########");
-            logger.error("@ " + message);
-            logger.error(var2 + ": " + var3);
-        }
-    }
-
-    /**
-     * Shuts down the minecraft applet by stopping the resource downloads, and clearing up GL stuff; called when the
-     * application (or web page) is exited.
-     */
-    public void shutdownMinecraftApplet()
-    {
-        try
-        {
-            this.stream.shutdownStream();
-            logger.info("Stopping!");
-
-            try
-            {
-                this.loadWorld((WorldClient)null);
-            }
-            catch (Throwable var7)
-            {
-                ;
-            }
-
-            try
-            {
-                GLAllocation.deleteTexturesAndDisplayLists();
-            }
-            catch (Throwable var6)
-            {
-                ;
-            }
-
-            this.mcSoundHandler.unloadSounds();
-        }
-        finally
-        {
-            Display.destroy();
-
-            if (!this.hasCrashed)
-            {
-                System.exit(0);
-            }
-        }
-
-        System.gc();
-    }
-
-    public void run()
-    {
-        this.running = true;
-        CrashReport var2;
-
-        try
-        {
-            this.startGame();
-        }
-        catch (Throwable var11)
-        {
-            var2 = CrashReport.makeCrashReport(var11, "Initializing game");
-            var2.makeCategory("Initialization");
-            this.displayCrashReport(this.addGraphicsAndWorldToCrashReport(var2));
-            return;
-        }
-
-        while (true)
-        {
-            try
-            {
-                while (this.running)
-                {
-                    if (!this.hasCrashed || this.crashReporter == null)
-                    {
-                        try
-                        {
-                            this.runGameLoop();
-                        }
-                        catch (OutOfMemoryError var10)
-                        {
-                            this.freeMemory();
-                            this.displayGuiScreen(new GuiMemoryErrorScreen());
-                            System.gc();
-                        }
-
-                        continue;
-                    }
-
-                    this.displayCrashReport(this.crashReporter);
-                }
-            }
-            catch (MinecraftError var12)
-            {
-                break;
-            }
-            catch (ReportedException var13)
-            {
-                this.addGraphicsAndWorldToCrashReport(var13.getCrashReport());
-                this.freeMemory();
-                logger.fatal("Reported exception thrown!", var13);
-                this.displayCrashReport(var13.getCrashReport());
-                break;
-            }
-            catch (Throwable var14)
-            {
-                var2 = this.addGraphicsAndWorldToCrashReport(new CrashReport("Unexpected error", var14));
-                this.freeMemory();
-                logger.fatal("Unreported exception thrown!", var14);
-                this.displayCrashReport(var2);
-                break;
-            }
-            finally
-            {
-                this.shutdownMinecraftApplet();
-            }
-
-            return;
-        }
-    }
-
-    /**
-     * Called repeatedly from run()
-     */
-    private void runGameLoop()
-    {
-        this.mcProfiler.startSection("root");
-
-        if (Display.isCreated() && Display.isCloseRequested())
-        {
-            this.shutdown();
-        }
-
-        if (this.isGamePaused && this.theWorld != null)
-        {
-            float var1 = this.timer.renderPartialTicks;
-            this.timer.updateTimer();
-            this.timer.renderPartialTicks = var1;
-        }
-        else
-        {
-            this.timer.updateTimer();
-        }
-
-        if ((this.theWorld == null || this.currentScreen == null) && this.refreshTexturePacksScheduled)
-        {
-            this.refreshTexturePacksScheduled = false;
-            this.refreshResources();
-        }
-
-        long var5 = System.nanoTime();
-        this.mcProfiler.startSection("tick");
-
-        for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
-        {
-            this.runTick();
-        }
-
-        this.mcProfiler.endStartSection("preRenderErrors");
-        long var6 = System.nanoTime() - var5;
-        this.checkGLError("Pre render");
-        RenderBlocks.fancyGrass = this.gameSettings.fancyGraphics;
-        this.mcProfiler.endStartSection("sound");
-        this.mcSoundHandler.setListener(this.thePlayer, this.timer.renderPartialTicks);
-        this.mcProfiler.endSection();
-        this.mcProfiler.startSection("render");
-        GL11.glPushMatrix();
-        GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
-        this.framebufferMc.bindFramebuffer(true);
-        this.mcProfiler.startSection("display");
-        GL11.glEnable(GL11.GL_TEXTURE_2D);
-
-        if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
-        {
-            this.gameSettings.thirdPersonView = 0;
-        }
-
-        this.mcProfiler.endSection();
-
-        if (!this.skipRenderWorld)
-        {
-            this.mcProfiler.endStartSection("gameRenderer");
-            this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
-            this.mcProfiler.endSection();
-        }
-
-        GL11.glFlush();
-        this.mcProfiler.endSection();
-
-        if (!Display.isActive() && this.fullscreen)
-        {
-            this.toggleFullscreen();
-        }
-
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)
-        {
-            if (!this.mcProfiler.profilingEnabled)
-            {
-                this.mcProfiler.clearProfiling();
-            }
-
-            this.mcProfiler.profilingEnabled = true;
-            this.displayDebugInfo(var6);
-        }
-        else
-        {
-            this.mcProfiler.profilingEnabled = false;
-            this.prevFrameTime = System.nanoTime();
-        }
-
-        this.guiAchievement.updateAchievementWindow();
-        this.framebufferMc.unbindFramebuffer();
-        GL11.glPopMatrix();
-        GL11.glPushMatrix();
-        this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
-        GL11.glPopMatrix();
-        GL11.glPushMatrix();
-        this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);
-        GL11.glPopMatrix();
-        this.mcProfiler.startSection("root");
-        this.resetSize();
-        Thread.yield();
-        this.mcProfiler.startSection("stream");
-        this.mcProfiler.startSection("update");
-        this.stream.func_152935_j();
-        this.mcProfiler.endStartSection("submit");
-        this.stream.func_152922_k();
-        this.mcProfiler.endSection();
-        this.mcProfiler.endSection();
-        this.checkGLError("Post render");
-        ++this.fpsCounter;
-        this.isGamePaused = this.isSingleplayer() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame() && !this.theIntegratedServer.getPublic();
-
-        while (getSystemTime() >= this.debugUpdateTime + 1000L)
-        {
-            debugFPS = this.fpsCounter;
-            this.debug = debugFPS + " fps, " + WorldRenderer.chunksUpdated + " chunk updates";
-            WorldRenderer.chunksUpdated = 0;
-            this.debugUpdateTime += 1000L;
-            this.fpsCounter = 0;
-            this.usageSnooper.addMemoryStatsToSnooper();
-
-            if (!this.usageSnooper.isSnooperRunning())
-            {
-                this.usageSnooper.startSnooper();
-            }
-        }
-
-        this.mcProfiler.endSection();
-
-        if (this.isFramerateLimitBelowMax())
-        {
-            Display.sync(this.getLimitFramerate());
-        }
-    }
-
-    /**
-     * Called to ensure everything gets drawn right when window size is changed
-     */
-    public void resetSize()
-    {
-        Display.update();
-
-        if (!this.fullscreen && Display.wasResized())
-        {
-            int var1 = this.displayWidth;
-            int var2 = this.displayHeight;
-            this.displayWidth = Display.getWidth();
-            this.displayHeight = Display.getHeight();
-
-            if (this.displayWidth != var1 || this.displayHeight != var2)
-            {
-                if (this.displayWidth <= 0)
-                {
-                    this.displayWidth = 1;
-                }
-
-                if (this.displayHeight <= 0)
-                {
-                    this.displayHeight = 1;
-                }
-
-                this.resize(this.displayWidth, this.displayHeight);
-            }
-        }
-    }
-
-    public int getLimitFramerate()
-    {
-        return this.theWorld == null && this.currentScreen != null ? 30 : this.gameSettings.limitFramerate;
-    }
-
-    public boolean isFramerateLimitBelowMax()
-    {
-        return (float)this.getLimitFramerate() < GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
-    }
-
-    public void freeMemory()
-    {
-        try
-        {
-            memoryReserve = new byte[0];
-            this.renderGlobal.deleteAllDisplayLists();
-        }
-        catch (Throwable var4)
-        {
-            ;
-        }
-
-        try
-        {
-            System.gc();
-        }
-        catch (Throwable var3)
-        {
-            ;
-        }
-
-        try
-        {
-            System.gc();
-            this.loadWorld((WorldClient)null);
-        }
-        catch (Throwable var2)
-        {
-            ;
-        }
-
-        System.gc();
-    }
-
-    /**
-     * Update debugProfilerName in response to number keys in debug screen
-     */
-    private void updateDebugProfilerName(int keyCount)
-    {
-        List var2 = this.mcProfiler.getProfilingData(this.debugProfilerName);
-
-        if (var2 != null && !var2.isEmpty())
-        {
-            Profiler.Result var3 = (Profiler.Result)var2.remove(0);
-
-            if (keyCount == 0)
-            {
-                if (var3.field_76331_c.length() > 0)
-                {
-                    int var4 = this.debugProfilerName.lastIndexOf(".");
-
-                    if (var4 >= 0)
-                    {
-                        this.debugProfilerName = this.debugProfilerName.substring(0, var4);
-                    }
-                }
-            }
-            else
-            {
-                --keyCount;
-
-                if (keyCount < var2.size() && !((Profiler.Result)var2.get(keyCount)).field_76331_c.equals("unspecified"))
-                {
-                    if (this.debugProfilerName.length() > 0)
-                    {
-                        this.debugProfilerName = this.debugProfilerName + ".";
-                    }
-
-                    this.debugProfilerName = this.debugProfilerName + ((Profiler.Result)var2.get(keyCount)).field_76331_c;
-                }
-            }
-        }
-    }
-
-    /**
-     * Parameter appears to be unused\n \n@param elapsedTicksTime The time elapsed for running game tick(s) this
-     * iteration; unused in this method
-     */
-    private void displayDebugInfo(long elapsedTicksTime)
-    {
-        if (this.mcProfiler.profilingEnabled)
-        {
-            List var3 = this.mcProfiler.getProfilingData(this.debugProfilerName);
-            Profiler.Result var4 = (Profiler.Result)var3.remove(0);
-            GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
-            GL11.glMatrixMode(GL11.GL_PROJECTION);
-            GL11.glEnable(GL11.GL_COLOR_MATERIAL);
-            GL11.glLoadIdentity();
-            GL11.glOrtho(0.0D, (double)this.displayWidth, (double)this.displayHeight, 0.0D, 1000.0D, 3000.0D);
-            GL11.glMatrixMode(GL11.GL_MODELVIEW);
-            GL11.glLoadIdentity();
-            GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
-            GL11.glLineWidth(1.0F);
-            GL11.glDisable(GL11.GL_TEXTURE_2D);
-            Tessellator var5 = Tessellator.instance;
-            short var6 = 160;
-            int var7 = this.displayWidth - var6 - 10;
-            int var8 = this.displayHeight - var6 * 2;
-            GL11.glEnable(GL11.GL_BLEND);
-            var5.startDrawingQuads();
-            var5.setColorRGBA_I(0, 200);
-            var5.addVertex((double)((float)var7 - (float)var6 * 1.1F), (double)((float)var8 - (float)var6 * 0.6F - 16.0F), 0.0D);
-            var5.addVertex((double)((float)var7 - (float)var6 * 1.1F), (double)(var8 + var6 * 2), 0.0D);
-            var5.addVertex((double)((float)var7 + (float)var6 * 1.1F), (double)(var8 + var6 * 2), 0.0D);
-            var5.addVertex((double)((float)var7 + (float)var6 * 1.1F), (double)((float)var8 - (float)var6 * 0.6F - 16.0F), 0.0D);
-            var5.draw();
-            GL11.glDisable(GL11.GL_BLEND);
-            double var9 = 0.0D;
-            int var13;
-
-            for (int var11 = 0; var11 < var3.size(); ++var11)
-            {
-                Profiler.Result var12 = (Profiler.Result)var3.get(var11);
-                var13 = MathHelper.floor_double(var12.field_76332_a / 4.0D) + 1;
-                var5.startDrawing(6);
-                var5.setColorOpaque_I(var12.func_76329_a());
-                var5.addVertex((double)var7, (double)var8, 0.0D);
-                int var14;
-                float var15;
-                float var16;
-                float var17;
-
-                for (var14 = var13; var14 >= 0; --var14)
-                {
-                    var15 = (float)((var9 + var12.field_76332_a * (double)var14 / (double)var13) * Math.PI * 2.0D / 100.0D);
-                    var16 = MathHelper.sin(var15) * (float)var6;
-                    var17 = MathHelper.cos(var15) * (float)var6 * 0.5F;
-                    var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17), 0.0D);
-                }
-
-                var5.draw();
-                var5.startDrawing(5);
-                var5.setColorOpaque_I((var12.func_76329_a() & 16711422) >> 1);
-
-                for (var14 = var13; var14 >= 0; --var14)
-                {
-                    var15 = (float)((var9 + var12.field_76332_a * (double)var14 / (double)var13) * Math.PI * 2.0D / 100.0D);
-                    var16 = MathHelper.sin(var15) * (float)var6;
-                    var17 = MathHelper.cos(var15) * (float)var6 * 0.5F;
-                    var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17), 0.0D);
-                    var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17 + 10.0F), 0.0D);
-                }
-
-                var5.draw();
-                var9 += var12.field_76332_a;
-            }
-
-            DecimalFormat var18 = new DecimalFormat("##0.00");
-            GL11.glEnable(GL11.GL_TEXTURE_2D);
-            String var19 = "";
-
-            if (!var4.field_76331_c.equals("unspecified"))
-            {
-                var19 = var19 + "[0] ";
-            }
-
-            if (var4.field_76331_c.length() == 0)
-            {
-                var19 = var19 + "ROOT ";
-            }
-            else
-            {
-                var19 = var19 + var4.field_76331_c + " ";
-            }
-
-            var13 = 16777215;
-            this.fontRendererObj.drawStringWithShadow(var19, var7 - var6, var8 - var6 / 2 - 16, var13);
-            this.fontRendererObj.drawStringWithShadow(var19 = var18.format(var4.field_76330_b) + "%", var7 + var6 - this.fontRendererObj.getStringWidth(var19), var8 - var6 / 2 - 16, var13);
-
-            for (int var20 = 0; var20 < var3.size(); ++var20)
-            {
-                Profiler.Result var21 = (Profiler.Result)var3.get(var20);
-                String var22 = "";
-
-                if (var21.field_76331_c.equals("unspecified"))
-                {
-                    var22 = var22 + "[?] ";
-                }
-                else
-                {
-                    var22 = var22 + "[" + (var20 + 1) + "] ";
-                }
-
-                var22 = var22 + var21.field_76331_c;
-                this.fontRendererObj.drawStringWithShadow(var22, var7 - var6, var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
-                this.fontRendererObj.drawStringWithShadow(var22 = var18.format(var21.field_76332_a) + "%", var7 + var6 - 50 - this.fontRendererObj.getStringWidth(var22), var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
-                this.fontRendererObj.drawStringWithShadow(var22 = var18.format(var21.field_76330_b) + "%", var7 + var6 - this.fontRendererObj.getStringWidth(var22), var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
-            }
-        }
-    }
-
-    /**
-     * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
-     */
-    public void shutdown()
-    {
-        this.running = false;
-    }
-
-    /**
-     * Will set the focus to ingame if the Minecraft window is the active with focus. Also clears any GUI screen
-     * currently displayed
-     */
-    public void setIngameFocus()
-    {
-        if (Display.isActive())
-        {
-            if (!this.inGameHasFocus)
-            {
-                this.inGameHasFocus = true;
-                this.mouseHelper.grabMouseCursor();
-                this.displayGuiScreen((GuiScreen)null);
-                this.leftClickCounter = 10000;
-            }
-        }
-    }
-
-    /**
-     * Resets the player keystate, disables the ingame focus, and ungrabs the mouse cursor.
-     */
-    public void setIngameNotInFocus()
-    {
-        if (this.inGameHasFocus)
-        {
-            KeyBinding.unPressAllKeys();
-            this.inGameHasFocus = false;
-            this.mouseHelper.ungrabMouseCursor();
-        }
-    }
-
-    /**
-     * Displays the ingame menu
-     */
-    public void displayInGameMenu()
-    {
-        if (this.currentScreen == null)
-        {
-            this.displayGuiScreen(new GuiIngameMenu());
-
-            if (this.isSingleplayer() && !this.theIntegratedServer.getPublic())
-            {
-                this.mcSoundHandler.pauseSounds();
-            }
-        }
-    }
-
-    private void sendClickBlockToController(boolean leftClick)
-    {
-        if (!leftClick)
-        {
-            this.leftClickCounter = 0;
-        }
-
-        if (this.leftClickCounter <= 0)
-        {
-            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
-            {
-                int var2 = this.objectMouseOver.blockX;
-                int var3 = this.objectMouseOver.blockY;
-                int var4 = this.objectMouseOver.blockZ;
-
-                if (this.theWorld.getBlock(var2, var3, var4).getMaterial() != Material.air)
-                {
-                    this.playerController.onPlayerDamageBlock(var2, var3, var4, this.objectMouseOver.sideHit);
-
-                    if (this.thePlayer.isCurrentToolAdventureModeExempt(var2, var3, var4))
-                    {
-                        this.effectRenderer.addBlockHitEffects(var2, var3, var4, this.objectMouseOver.sideHit);
-                        this.thePlayer.swingItem();
-                    }
-                }
-            }
-            else
-            {
-                this.playerController.resetBlockRemoving();
-            }
-        }
-    }
-
-    private void clickMouse()
-    {
-        if (this.leftClickCounter <= 0)
-        {
-            this.thePlayer.swingItem();
-
-            if (this.objectMouseOver == null)
-            {
-                logger.error("Null returned as \'hitResult\', this shouldn\'t happen!");
-
-                if (this.playerController.isNotCreative())
-                {
-                    this.leftClickCounter = 10;
-                }
-            }
-            else
-            {
-                switch (Minecraft.SwitchMovingObjectType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
-                {
-                    case 1:
-                        this.playerController.attackEntity(this.thePlayer, this.objectMouseOver.entityHit);
-                        break;
-
-                    case 2:
-                        int var1 = this.objectMouseOver.blockX;
-                        int var2 = this.objectMouseOver.blockY;
-                        int var3 = this.objectMouseOver.blockZ;
-
-                        if (this.theWorld.getBlock(var1, var2, var3).getMaterial() == Material.air)
-                        {
-                            if (this.playerController.isNotCreative())
-                            {
-                                this.leftClickCounter = 10;
-                            }
-                        }
-                        else
-                        {
-                            this.playerController.clickBlock(var1, var2, var3, this.objectMouseOver.sideHit);
-                        }
-                }
-            }
-        }
-    }
-
-    /**
-     * Called when user clicked he's mouse right button (place)
-     */
-    private void rightClickMouse()
-    {
-        this.rightClickDelayTimer = 4;
-        boolean var1 = true;
-        ItemStack var2 = this.thePlayer.inventory.getCurrentItem();
-
-        if (this.objectMouseOver == null)
-        {
-            logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
-        }
-        else
-        {
-            switch (Minecraft.SwitchMovingObjectType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
-            {
-                case 1:
-                    if (this.playerController.interactWithEntitySendPacket(this.thePlayer, this.objectMouseOver.entityHit))
-                    {
-                        var1 = false;
-                    }
-
-                    break;
-
-                case 2:
-                    int var3 = this.objectMouseOver.blockX;
-                    int var4 = this.objectMouseOver.blockY;
-                    int var5 = this.objectMouseOver.blockZ;
-
-                    if (this.theWorld.getBlock(var3, var4, var5).getMaterial() != Material.air)
-                    {
-                        int var6 = var2 != null ? var2.stackSize : 0;
-
-                        if (this.playerController.onPlayerRightClick(this.thePlayer, this.theWorld, var2, var3, var4, var5, this.objectMouseOver.sideHit, this.objectMouseOver.hitVec))
-                        {
-                            var1 = false;
-                            this.thePlayer.swingItem();
-                        }
-
-                        if (var2 == null)
-                        {
-                            return;
-                        }
-
-                        if (var2.stackSize == 0)
-                        {
-                            this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = null;
-                        }
-                        else if (var2.stackSize != var6 || this.playerController.isInCreativeMode())
-                        {
-                            this.entityRenderer.itemRenderer.resetEquippedProgress();
-                        }
-                    }
-            }
-        }
-
-        if (var1)
-        {
-            ItemStack var7 = this.thePlayer.inventory.getCurrentItem();
-
-            if (var7 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var7))
-            {
-                this.entityRenderer.itemRenderer.resetEquippedProgress2();
-            }
-        }
-    }
-
-    /**
-     * Toggles fullscreen mode.
-     */
-    public void toggleFullscreen()
-    {
-        try
-        {
-            this.fullscreen = !this.fullscreen;
-
-            if (this.fullscreen)
-            {
-                this.updateDisplayMode();
-                this.displayWidth = Display.getDisplayMode().getWidth();
-                this.displayHeight = Display.getDisplayMode().getHeight();
-
-                if (this.displayWidth <= 0)
-                {
-                    this.displayWidth = 1;
-                }
-
-                if (this.displayHeight <= 0)
-                {
-                    this.displayHeight = 1;
-                }
-            }
-            else
-            {
-                Display.setDisplayMode(new DisplayMode(this.tempDisplayWidth, this.tempDisplayHeight));
-                this.displayWidth = this.tempDisplayWidth;
-                this.displayHeight = this.tempDisplayHeight;
-
-                if (this.displayWidth <= 0)
-                {
-                    this.displayWidth = 1;
-                }
-
-                if (this.displayHeight <= 0)
-                {
-                    this.displayHeight = 1;
-                }
-            }
-
-            if (this.currentScreen != null)
-            {
-                this.resize(this.displayWidth, this.displayHeight);
-            }
-            else
-            {
-                this.updateFramebufferSize();
-            }
-
-            Display.setFullscreen(this.fullscreen);
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
-            this.resetSize();
-        }
-        catch (Exception var2)
-        {
-            logger.error("Couldn\'t toggle fullscreen", var2);
-        }
-    }
-
-    /**
-     * Called to resize the current screen.
-     */
-    private void resize(int width, int height)
-    {
-        this.displayWidth = width <= 0 ? 1 : width;
-        this.displayHeight = height <= 0 ? 1 : height;
-
-        if (this.currentScreen != null)
-        {
-            ScaledResolution var3 = new ScaledResolution(this, width, height);
-            int var4 = var3.getScaledWidth();
-            int var5 = var3.getScaledHeight();
-            this.currentScreen.setWorldAndResolution(this, var4, var5);
-        }
-
-        this.loadingScreen = new LoadingScreenRenderer(this);
-        this.updateFramebufferSize();
-    }
-
-    private void updateFramebufferSize()
-    {
-        this.framebufferMc.createBindFramebuffer(this.displayWidth, this.displayHeight);
+        }*/
+		/** END MINECRIFT */
+		Tessellator var4 = Tessellator.instance;
+		var4.startDrawingQuads();
+		var4.setColorOpaque_I(16777215);
+		var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV((double)this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+		var4.draw();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		var4.setColorOpaque_I(16777215);
+		short var5 = 256;
+		short var6 = 256;
+		this.scaledTessellator((var1.getScaledWidth() - var5) / 2, (var1.getScaledHeight() - var6) / 2, 0, 0, var5, var6);
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_FOG);
+		var3.unbindFramebuffer();
+		var3.framebufferRender(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+		GL11.glFlush();
+		/** MINECRIFT */
+		Display.update();
+		/** END MINECRIFT */
+		this.resetSize();
+	}
+
+	/**
+	 * Loads Tessellator with a scaled resolution
+	 */
+	public void scaledTessellator(int width, int height, int width2, int height2, int stdTextureWidth, int stdTextureHeight)
+	{
+		float var7 = 0.00390625F;
+		float var8 = 0.00390625F;
+		Tessellator var9 = Tessellator.instance;
+		var9.startDrawingQuads();
+		var9.addVertexWithUV((double)(width + 0), (double)(height + stdTextureHeight), 0.0D, (double)((float)(width2 + 0) * var7), (double)((float)(height2 + stdTextureHeight) * var8));
+		var9.addVertexWithUV((double)(width + stdTextureWidth), (double)(height + stdTextureHeight), 0.0D, (double)((float)(width2 + stdTextureWidth) * var7), (double)((float)(height2 + stdTextureHeight) * var8));
+		var9.addVertexWithUV((double)(width + stdTextureWidth), (double)(height + 0), 0.0D, (double)((float)(width2 + stdTextureWidth) * var7), (double)((float)(height2 + 0) * var8));
+		var9.addVertexWithUV((double)(width + 0), (double)(height + 0), 0.0D, (double)((float)(width2 + 0) * var7), (double)((float)(height2 + 0) * var8));
+		var9.draw();
+	}
+
+	/**
+	 * Returns the save loader that is currently being used
+	 */
+	public ISaveFormat getSaveLoader()
+	{
+		return this.saveLoader;
+	}
+
+	/**
+	 * Sets the argument GuiScreen as the main (topmost visible) screen.
+	 */
+	public void displayGuiScreen(GuiScreen guiScreenIn)
+	{
+		/** MINECRIFT FORGE **/
+		if (!Reflector.forgeExists() && this.currentScreen != null)
+		{
+			this.currentScreen.onGuiClosed();
+		}
+
+		if (guiScreenIn == null && this.theWorld == null)
+		{
+			guiScreenIn = new GuiMainMenu();
+		}
+		else if (guiScreenIn == null && this.thePlayer.getHealth() <= 0.0F)
+		{
+			guiScreenIn = new GuiGameOver();
+		}
+
+		if (Reflector.forgeExists())
+		{
+			GuiScreen old = this.currentScreen;
+			Object event = Reflector.newInstance(Reflector.ForgeGuiOpenEvent_Constructor, new Object[] {guiScreenIn});
+
+			if (Reflector.postForgeBusEvent(event)) return;
+
+			guiScreenIn = (GuiScreen)Reflector.getFieldValue(event, Reflector.ForgeGuiOpenEvent_gui);
+			if (old != null && guiScreenIn != old)
+			{
+				old.onGuiClosed();
+			}
+		}
+		/** END MINECRIFT FORGE **/
+
+		if (guiScreenIn instanceof GuiMainMenu)
+		{
+			this.gameSettings.showDebugInfo = false;
+			this.ingameGUI.getChatGUI().clearChatMessages();
+		}
+
+		// VIVE START - notify stereo provider that we're about to change screen
+		if (Minecraft.getMinecraft().stereoProvider!=null) {
+			Minecraft.getMinecraft().stereoProvider.onGuiScreenChanged(this.currentScreen, guiScreenIn);
+		}
+		// VIVE END - notify stereo provider that we're about to change screen
+
+		Object test = currentScreen;
+		
+		this.currentScreen = (GuiScreen)guiScreenIn;
+
+		if (guiScreenIn != null)
+		{
+			this.setIngameNotInFocus();
+			ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);  /** Minecrift **/
+			int var3 = var2.getScaledWidth();
+			int var4 = var2.getScaledHeight();
+			((GuiScreen)guiScreenIn).setWorldAndResolution(this, var3, var4);
+			this.skipRenderWorld = false;
+		}
+		else
+		{
+			this.mcSoundHandler.resumeSounds();
+			this.setIngameFocus();
+		}
+	}
+
+	/**
+	 * Checks for an OpenGL error. If there is one, prints the error ID and error string.
+	 */
+	/** MINECRIFT */ 
+	public void checkGLError(String message)
+	/** END MINECRIFT */
+	{
+		int var2 = GL11.glGetError();
+
+		if (var2 != 0)
+		{
+			String var3 = GLU.gluErrorString(var2);
+			logger.error("########## GL ERROR ##########");
+			logger.error("@ " + message);
+			logger.error(var2 + ": " + var3);
+		}
+	}
+
+	/**
+	 * Shuts down the minecraft applet by stopping the resource downloads, and clearing up GL stuff; called when the
+	 * application (or web page) is exited.
+	 */
+	public void shutdownMinecraftApplet()
+	{
+		try
+		{
+			this.stream.shutdownStream();
+			logger.info("Stopping!");
+
+			try
+			{
+				this.loadWorld((WorldClient)null);
+			}
+			catch (Throwable var7)
+			{
+				;
+			}
+
+			try
+			{
+				GLAllocation.deleteTexturesAndDisplayLists();
+			}
+			catch (Throwable var6)
+			{
+				;
+			}
+
+			this.mcSoundHandler.unloadSounds();
+		}
+		finally
+		{
+			Display.destroy();
+
+			if (!this.hasCrashed)
+			{
+				System.exit(0);
+			}
+		}
+
+		System.gc();
+	}
+
+	public void run()
+	{
+		this.running = true;
+		CrashReport var2;
+
+		try
+		{
+			this.startGame();
+		}
+		catch (Throwable var11)
+		{
+			var2 = CrashReport.makeCrashReport(var11, "Initializing game");
+			var2.makeCategory("Initialization");
+			this.displayCrashReport(this.addGraphicsAndWorldToCrashReport(var2));
+			return;
+		}
+
+		while (true)
+		{
+			try
+			{
+				while (this.running)
+				{
+					if (!this.hasCrashed || this.crashReporter == null)
+					{
+						try
+						{
+							this.runGameLoop();
+						}
+						catch (OutOfMemoryError var10)
+						{
+							this.freeMemory();
+							this.displayGuiScreen(new GuiMemoryErrorScreen());
+							System.gc();
+						}
+
+						continue;
+					}
+
+					this.displayCrashReport(this.crashReporter);
+					return;
+				}
+			}
+			catch (MinecraftError var12)
+			{
+				;
+			}
+			catch (ReportedException var13)
+			{
+				this.addGraphicsAndWorldToCrashReport(var13.getCrashReport());
+				this.freeMemory();
+				logger.fatal("Reported exception thrown!", var13);
+				this.displayCrashReport(var13.getCrashReport());
+			}
+			catch (Throwable var14)
+			{
+				var2 = this.addGraphicsAndWorldToCrashReport(new CrashReport("Unexpected error", var14));
+				this.freeMemory();
+				logger.fatal("Unreported exception thrown!", var14);
+				this.displayCrashReport(var2);
+			}
+			finally
+			{
+				this.shutdownMinecraftApplet();
+			}
+
+			return;
+		}
+	}
+
+	/**
+	 * Called repeatedly from run()
+	 */
+	/** MINECRIFT */
+	private void runGameLoop() throws Exception
+	/** END MINECRIFT */
+	{
+		try {
+			this.mcProfiler.startSection("root");
+
+			if (Display.isCreated() && Display.isCloseRequested())
+			{
+				this.shutdown();
+			}
+
+			/** MINECRIFT */ // setup the display, render buffers, shaders etc.
+			this.frameIndex++;
+			setupRenderConfiguration();
+			/** END MINECRIFT */
+			if (this.isGamePaused && this.theWorld != null)
+			{
+				float var1 = this.timer.renderPartialTicks;
+				this.timer.updateTimer();
+				this.timer.renderPartialTicks = var1;
+			}
+			else
+			{
+				this.timer.updateTimer();
+			}
+
+			if ((this.theWorld == null || this.currentScreen == null) && this.refreshTexturePacksScheduled)
+			{
+				this.refreshTexturePacksScheduled = false;
+				this.refreshResources();
+			}
+
+			/** MINECRIFT */
+			long var5 = System.nanoTime();
+			long var6 = 0;
+			int ticks = 0;
+
+			if (!this.integratedServerLaunchInProgress)
+			{
+				this.mcProfiler.startSection("tick");
+
+				enableGuiSizeHack();
+
+				for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
+				{
+					this.runTick();
+					ticks++;
+				}
+
+				disableGuiSizeHack();
+
+				var6 = System.nanoTime() - var5;
+
+				// Test to see if render config change is requested. If so,
+				// update framebuffers
+				setupRenderConfiguration();
+			}
+
+			if (vrSettings.smoothTick) {
+				if (ticks > 0) {
+					addRunTickTimeNanos(var6 / ticks);
+				} else {
+					long sleepTimeNanos = getMedianRunTickTimeNanos();
+					sleepNanos(sleepTimeNanos);
+				}
+			}
+
+			var6 = System.nanoTime() - var5;
+			this.mcProfiler.endStartSection("preRenderErrors");
+			//long var6 = System.nanoTime() - var5;
+			//this.checkGLError("Pre render");
+			RenderBlocks.fancyGrass = this.gameSettings.fancyGraphics;
+			this.mcProfiler.endStartSection("sound");
+			this.mcSoundHandler.setListener(this.thePlayer, this.timer.renderPartialTicks);
+			this.mcProfiler.endSection();
+			this.mcProfiler.startSection("render");
+
+			// Render GUI to FBO if necessary
+			this.entityRenderer.drawFramebuffer(this.timer.renderPartialTicks, var6);   // VIVE - added param for debug info
+				
+			// TODO: PollAll can call controller code that updates the GUI.
+			// All controller code should be moved to UpdateTick really. For
+			// now, hack the displaySize so that any gui screens changed use
+			// the correct size...
+			enableGuiSizeHack();
+
+			// Mark beginning of frame AFTER any GUI rendering to allow maximum
+			// latency reduction
+			PluginManager.beginFrameAll(frameIndex);
+
+			// Poll sensors
+			if (!this.vrSettings.testTimewarp) {
+				PluginManager.pollAll(frameIndex);
+				PredictedDisplayTimeSeconds = this.stereoProvider.getFrameTiming();
+			}
+
+			//I dunno where to put this.
+			if(lookaimController instanceof MCOpenVR){
+					bowTracker.doProcess((MCOpenVR) this.lookaimController, thePlayer);
+			}
+
+		
+			// End display size hack
+			disableGuiSizeHack();
+
+			if (minecriftDebug) print("FrameIndex: " + frameIndex);
+			renderTexProvider[0].setFrameIndex(frameIndex);
+			renderTexProvider[1].setFrameIndex(frameIndex);
+
+
+			// VIVE - remember display width
+			int currentDisplayWidth = this.displayWidth;
+			int currentDisplayHeight = this.displayHeight;
+
+			
+			/** Minecrift - main stereo render loop **/
+			for (int i = 0; this.visible && i < viewPortCount; i++)
+			{
+				this.currentEye = this.stereoProvider.eyeRenderOrder(i);
+				this.framebufferMc = framebuffers[this.currentEye.value()];
+
+				this.stereoProvider.setCurrentRenderTextureInfo(
+						this.currentEye.value(),
+						renderTexProvider[this.currentEye.value()].getCurrentSwapIdx(),
+						this.framebufferMc.depthBuffer,
+						this.framebufferMc.framebufferTextureWidth,
+						this.framebufferMc.framebufferTextureHeight);
+				this.framebufferMc.bindFramebuffer(true);
+				this.framebufferMc.selectTexture();
+
+				if (this.entityRenderer != null)
+				{
+					this.entityRenderer.renderpass = i;
+					this.entityRenderer.theShaderGroup = shaderGroup[this.currentEye.value()];
+				}
+
+				this.displayWidth = this.EyeTextureSize[this.currentEye.value()].w;
+				this.displayHeight = this.EyeTextureSize[this.currentEye.value()].h;
+
+				currentEyePose = getEyePose(this.currentEye);
+				//System.out.println("Posef (" + this.currentEye.toString() + "): " + currentEyePose.toString());
+
+				GL11.glPushMatrix();
+				GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				//this.framebufferMc.bindFramebuffer(true);
+				this.mcProfiler.startSection("display");
+				GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+				if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
+				{
+					this.gameSettings.thirdPersonView = 0;
+				}
+
+				// VIVE - comment so endStartSection below works
+				//this.mcProfiler.endSection();
+
+				// Update our orientation and position variables from the sensor polled data
+				this.entityRenderer.updatePositionAndOrientation(this.timer.renderPartialTicks, Display.isActive());
+
+				if (!this.skipRenderWorld)
+				{
+					/** MINECRIFT FORGE **/
+					Object fmlCommonHandler = null;
+					if (Reflector.FMLCommonHandler_instance.exists()) {
+						fmlCommonHandler = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+					}
+					if (fmlCommonHandler != null) {
+						Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickStart, new Object[]{this.timer.renderPartialTicks});
+					}
+					this.mcProfiler.endStartSection("gameRenderer");
+
+					///THIS IS WHERE EVERYTHING IS RENDERED
+					this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
+
+
+					this.mcProfiler.endSection();
+					if (fmlCommonHandler != null) {
+						Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickEnd, new Object[]{this.timer.renderPartialTicks});
+					}
+					/** END MINECRIFT FORGE **/
+				}
+
+				//GL11.glFlush();
+				//this.mcProfiler.endSection();
+
+				//if (!Display.isActive() && this.fullscreen)
+				//{
+				//    this.toggleFullscreen();
+				//}
+
+				if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)    // <-- TODO: Move; needs to be overlayed over GUI FBO
+				{
+					// VIVE - since we're starting profiling halfway through the game loop, need to start these sections so they can be ended
+					boolean wasProfiling = this.mcProfiler.profilingEnabled;
+
+					if (!this.mcProfiler.profilingEnabled)
+					{
+						this.mcProfiler.clearProfiling();
+					}
+
+					this.mcProfiler.profilingEnabled = true;
+					// VIVE - commented this out, it's done above in renderVrGUI so it appears in the HUD FBO
+					//this.displayDebugInfo(var6);
+
+					// VIVE - since we're starting profiling halfway through the game loop, need to start these sections so they can be ended
+					if (!wasProfiling)
+					{
+						this.mcProfiler.startSection("root");
+						this.mcProfiler.startSection("render");
+					}
+				}
+				else
+				{
+					this.mcProfiler.profilingEnabled = false;
+					this.prevFrameTime = System.nanoTime();
+				}
+
+				//this.guiAchievement.updateAchievementWindow();  // <-- TODO: Move; needs to be overlayed over GUI FBO
+				//this.framebufferMc.unbindFramebuffer();
+				GL11.glPopMatrix();
+				GL11.glPushMatrix();
+				//this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+
+				doPostProcessing(frameIndex, this.currentEye);
+
+				GL11.glPopMatrix();
+				GL11.glPushMatrix();
+				//this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);   // <-- TODO: What does this do? Some sort of stream status overlay? REENABLE, move to GUI FBO?
+				GL11.glPopMatrix();
+				
+			} //end per eye rendering.
+
+			// VIVE - restore display width
+			this.displayWidth = currentDisplayWidth;
+			this.displayHeight = currentDisplayHeight;
+
+	
+
+			this.visible = endFrame();
+
+			// VIVE - added endSection for "render", doesn't seem to have one?
+			this.mcProfiler.endSection();
+
+			copyToMirror();
+			//this.checkGLError("endFrame");
+			this.mcProfiler.startSection("root");
+			//this.resetSize();  // Now handled in setup setupRenderConfiguration
+			Thread.yield();
+			this.mcProfiler.startSection("stream");
+			this.mcProfiler.startSection("update");
+			this.stream.func_152935_j();
+			this.mcProfiler.endStartSection("submit");
+			this.stream.func_152922_k();
+			this.mcProfiler.endSection();
+			this.mcProfiler.endSection();
+			//this.checkGLError("Post render");
+			++this.fpsCounter;
+			this.isGamePaused = this.isSingleplayer() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame() && !this.theIntegratedServer.getPublic();
+			/** END MINECRIFT */
+
+			while (getSystemTime() >= this.debugUpdateTime + 1000L)
+			{
+				debugFPS = this.fpsCounter;
+				this.debug = debugFPS + " fps, " + WorldRenderer.chunksUpdated + " chunk updates";
+				WorldRenderer.chunksUpdated = 0;
+				this.debugUpdateTime += 1000L;
+				this.fpsCounter = 0;
+				this.usageSnooper.addMemoryStatsToSnooper();
+
+				if (!this.usageSnooper.isSnooperRunning())
+				{
+					this.usageSnooper.startSnooper();
+				}
+			}
+
+			this.mcProfiler.endSection();
+
+			// VIVE - added endSection to make profiler sections clear out.. not sure where the leak is coming from
+			this.mcProfiler.endSection();
+			/** MINECRIFT */
+			//        if (this.isFramerateLimitBelowMax())
+			//        {
+			//            Display.sync(this.getLimitFramerate());  // <-- Minecrift - Don't limit fps
+			//        }
+		}
+		catch (RenderConfigException e) {
+			// set mono provider
+			vrSettings.badStereoProviderPluginID = stereoProvider.getID();
+			vrSettings.stereoProviderPluginID = "mono";
+			vrSettings.saveOptions();
+			try {
+				stereoProvider = PluginManager.configureStereoProvider(vrSettings.stereoProviderPluginID);
+			}
+			catch (Exception ex) {
+				ex.printStackTrace();
+			}
+
+			// set error
+			this.errorHelper = new ErrorHelper(e.title, e.error, "Reverted to mono renderer!", ERROR_DISPLAY_TIME_SECS);
+			e.printStackTrace();
+		}
+		/** END MINECRIFT */
+	}
+
+	/**
+	 * Called to ensure everything gets drawn right when window size is changed
+	 */
+	public void resetSize()
+	{
+		/** MINECRIFT */
+		this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+		//        Display.update();
+		//
+		//        if (!this.fullscreen && Display.wasResized())
+		//        {
+		//            int i = this.displayWidth;
+		//            int j = this.displayHeight;
+		//            this.displayWidth = Display.getWidth();
+		//            this.displayHeight = Display.getHeight();
+		//
+		//            if (this.displayWidth != i || this.displayHeight != j)
+		//            {
+		//                if (this.displayWidth <= 0)
+		//                {
+		//                    this.displayWidth = 1;
+		//                }
+		//
+		//                if (this.displayHeight <= 0)
+		//                {
+		//                    this.displayHeight = 1;
+		//                }
+		//
+		//                this.resize(this.displayWidth, this.displayHeight);
+		//            }
+		//        }
+		/** END MINECRIFT */
+	}
+
+	public int getLimitFramerate()
+	{
+		/** MINECRIFT */
+		return this.gameSettings.limitFramerate;   // Do not limit the framerate in menus!
+		/** END MINECRIFT */
+	}
+
+	public boolean isFramerateLimitBelowMax()
+	{
+		return (float)this.getLimitFramerate() < GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+	}
+
+	public void freeMemory()
+	{
+		try
+		{
+			memoryReserve = new byte[0];
+			this.renderGlobal.deleteAllDisplayLists();
+		}
+		catch (Throwable var4)
+		{
+			;
+		}
+
+		try
+		{
+			System.gc();
+		}
+		catch (Throwable var3)
+		{
+			;
+		}
+
+		try
+		{
+			System.gc();
+			this.loadWorld((WorldClient)null);
+		}
+		catch (Throwable var2)
+		{
+			;
+		}
+
+		System.gc();
+	}
+
+	/**
+	 * Update debugProfilerName in response to number keys in debug screen
+	 */
+	private void updateDebugProfilerName(int keyCount)
+	{
+		List var2 = this.mcProfiler.getProfilingData(this.debugProfilerName);
+
+		if (var2 != null && !var2.isEmpty())
+		{
+			Profiler.Result var3 = (Profiler.Result)var2.remove(0);
+
+			if (keyCount == 0)
+			{
+				if (var3.field_76331_c.length() > 0)
+				{
+					int var4 = this.debugProfilerName.lastIndexOf(".");
+
+					if (var4 >= 0)
+					{
+						this.debugProfilerName = this.debugProfilerName.substring(0, var4);
+					}
+				}
+			}
+			else
+			{
+				--keyCount;
+
+				if (keyCount < var2.size() && !((Profiler.Result)var2.get(keyCount)).field_76331_c.equals("unspecified"))
+				{
+					if (this.debugProfilerName.length() > 0)
+					{
+						this.debugProfilerName = this.debugProfilerName + ".";
+					}
+
+					this.debugProfilerName = this.debugProfilerName + ((Profiler.Result)var2.get(keyCount)).field_76331_c;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Parameter appears to be unused\n \n@param elapsedTicksTime The time elapsed for running game tick(s) this
+	 * iteration; unused in this method
+	 */
+	public void displayDebugInfo(long elapsedTicksTime)     // VIVE - made public
+	{
+		if (this.mcProfiler.profilingEnabled)
+		{
+			List var3 = this.mcProfiler.getProfilingData(this.debugProfilerName);
+			Profiler.Result var4 = (Profiler.Result)var3.remove(0);
+			GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glEnable(GL11.GL_COLOR_MATERIAL);
+			GL11.glLoadIdentity();
+			GL11.glOrtho(0.0D, (double)this.displayWidth, (double)this.displayHeight, 0.0D, 1000.0D, 3000.0D);
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glLoadIdentity();
+			GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+			GL11.glLineWidth(1.0F);
+			GL11.glDisable(GL11.GL_TEXTURE_2D);
+			Tessellator var5 = Tessellator.instance;
+			short var6 = 160;
+			int var7 = this.displayWidth - var6 - 10;
+			int var8 = this.displayHeight - var6 * 2;
+			GL11.glEnable(GL11.GL_BLEND);
+			var5.startDrawingQuads();
+			var5.setColorRGBA_I(0, 200);
+			var5.addVertex((double)((float)var7 - (float)var6 * 1.1F), (double)((float)var8 - (float)var6 * 0.6F - 16.0F), 0.0D);
+			var5.addVertex((double)((float)var7 - (float)var6 * 1.1F), (double)(var8 + var6 * 2), 0.0D);
+			var5.addVertex((double)((float)var7 + (float)var6 * 1.1F), (double)(var8 + var6 * 2), 0.0D);
+			var5.addVertex((double)((float)var7 + (float)var6 * 1.1F), (double)((float)var8 - (float)var6 * 0.6F - 16.0F), 0.0D);
+			var5.draw();
+			GL11.glDisable(GL11.GL_BLEND);
+			double var9 = 0.0D;
+			int var13;
+
+			for (int var11 = 0; var11 < var3.size(); ++var11)
+			{
+				Profiler.Result var12 = (Profiler.Result)var3.get(var11);
+				var13 = MathHelper.floor_double(var12.field_76332_a / 4.0D) + 1;
+				var5.startDrawing(6);
+				var5.setColorOpaque_I(var12.func_76329_a());
+				var5.addVertex((double)var7, (double)var8, 0.0D);
+				int var14;
+				float var15;
+				float var16;
+				float var17;
+
+				for (var14 = var13; var14 >= 0; --var14)
+				{
+					var15 = (float)((var9 + var12.field_76332_a * (double)var14 / (double)var13) * Math.PI * 2.0D / 100.0D);
+					var16 = MathHelper.sin(var15) * (float)var6;
+					var17 = MathHelper.cos(var15) * (float)var6 * 0.5F;
+					var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17), 0.0D);
+				}
+
+				var5.draw();
+				var5.startDrawing(5);
+				var5.setColorOpaque_I((var12.func_76329_a() & 16711422) >> 1);
+
+				for (var14 = var13; var14 >= 0; --var14)
+				{
+					var15 = (float)((var9 + var12.field_76332_a * (double)var14 / (double)var13) * Math.PI * 2.0D / 100.0D);
+					var16 = MathHelper.sin(var15) * (float)var6;
+					var17 = MathHelper.cos(var15) * (float)var6 * 0.5F;
+					var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17), 0.0D);
+					var5.addVertex((double)((float)var7 + var16), (double)((float)var8 - var17 + 10.0F), 0.0D);
+				}
+
+				var5.draw();
+				var9 += var12.field_76332_a;
+			}
+
+			DecimalFormat var18 = new DecimalFormat("##0.00");
+			GL11.glEnable(GL11.GL_TEXTURE_2D);
+			String var19 = "";
+
+			if (!var4.field_76331_c.equals("unspecified"))
+			{
+				var19 = var19 + "[0] ";
+			}
+
+			if (var4.field_76331_c.length() == 0)
+			{
+				var19 = var19 + "ROOT ";
+			}
+			else
+			{
+				var19 = var19 + var4.field_76331_c + " ";
+			}
+
+			var13 = 16777215;
+			this.fontRendererObj.drawStringWithShadow(var19, var7 - var6, var8 - var6 / 2 - 16, var13);
+			this.fontRendererObj.drawStringWithShadow(var19 = var18.format(var4.field_76330_b) + "%", var7 + var6 - this.fontRendererObj.getStringWidth(var19), var8 - var6 / 2 - 16, var13);
+
+			for (int var20 = 0; var20 < var3.size(); ++var20)
+			{
+				Profiler.Result var21 = (Profiler.Result)var3.get(var20);
+				String var22 = "";
+
+				if (var21.field_76331_c.equals("unspecified"))
+				{
+					var22 = var22 + "[?] ";
+				}
+				else
+				{
+					var22 = var22 + "[" + (var20 + 1) + "] ";
+				}
+
+				var22 = var22 + var21.field_76331_c;
+				this.fontRendererObj.drawStringWithShadow(var22, var7 - var6, var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
+				this.fontRendererObj.drawStringWithShadow(var22 = var18.format(var21.field_76332_a) + "%", var7 + var6 - 50 - this.fontRendererObj.getStringWidth(var22), var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
+				this.fontRendererObj.drawStringWithShadow(var22 = var18.format(var21.field_76330_b) + "%", var7 + var6 - this.fontRendererObj.getStringWidth(var22), var8 + var6 / 2 + var20 * 8 + 20, var21.func_76329_a());
+			}
+		}
+	}
+
+	/**
+	 * Called when the window is closing. Sets 'running' to false which allows the game loop to exit cleanly.
+	 */
+	public void shutdown()
+	{
+		this.running = false;
+	}
+
+	/**
+	 * Will set the focus to ingame if the Minecraft window is the active with focus. Also clears any GUI screen
+	 * currently displayed
+	 */
+	public void setIngameFocus()
+	{
+		if (Display.isActive())
+		{
+			if (!this.inGameHasFocus)
+			{
+				this.inGameHasFocus = true;
+				this.mouseHelper.grabMouseCursor();
+				this.displayGuiScreen((GuiScreen)null);
+				this.leftClickCounter = 10000;
+			}
+		}
+	}
+
+	/**
+	 * Resets the player keystate, disables the ingame focus, and ungrabs the mouse cursor.
+	 */
+	public void setIngameNotInFocus()
+	{
+		if (this.inGameHasFocus)
+		{
+			KeyBinding.unPressAllKeys();
+			this.inGameHasFocus = false;
+			this.mouseHelper.ungrabMouseCursor();
+		}
+	}
+
+	/**
+	 * Displays the ingame menu
+	 */
+	public void displayInGameMenu()
+	{
+		if (this.currentScreen == null)
+		{
+			this.displayGuiScreen(new GuiIngameMenu());
+
+			if (this.isSingleplayer() && !this.theIntegratedServer.getPublic())
+			{
+				this.mcSoundHandler.pauseSounds();
+			}
+		}
+	}
+
+	// VIVE START - only clear block counter on un-press, to support real life swinging attacks
+	private boolean lastClick = false;
+	// VIVE END - only clear block counter on un-press, to support real life swinging attacks
+	private int moveModeSwitchcount;
+
+	private void sendClickBlockToController(boolean leftClick)
+	{
+		if (leftClick && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
+		{
+			int var2 = this.objectMouseOver.blockX;
+			int var3 = this.objectMouseOver.blockY;
+			int var4 = this.objectMouseOver.blockZ;
+
+			if (this.theWorld.getBlock(var2, var3, var4).getMaterial() != Material.air)
+			{
+				this.playerController.onPlayerDamageBlock(var2, var3, var4, this.objectMouseOver.sideHit);
+
+				if (this.thePlayer.isCurrentToolAdventureModeExempt(var2, var3, var4))
+				{
+					this.effectRenderer.addBlockHitEffects(var2, var3, var4, this.objectMouseOver.sideHit);
+					this.thePlayer.swingItem();
+				}
+			}
+		}
+	}
+
+	/** MINECRIFT */
+	public void clickMouse()
+	/** END MINECRIFT */
+	{
+		if (this.leftClickCounter <= 0)
+		{
+
+			this.thePlayer.swingItem();
+
+			if (this.objectMouseOver == null)
+			{
+				this.leftClickCounter =  this.playerController.isNotCreative() ? 10 : 0;
+			}
+			else
+			{
+				switch (Minecraft.SwitchMovingObjectType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
+				{
+				case 1:
+					this.playerController.attackEntity(this.thePlayer, this.objectMouseOver.entityHit);
+					break;
+				case 2:
+					int var1 = this.objectMouseOver.blockX;
+					int var2 = this.objectMouseOver.blockY;
+					int var3 = this.objectMouseOver.blockZ;
+
+					if (this.theWorld.getBlock(var1, var2, var3).getMaterial() == Material.air)
+					{
+						this.leftClickCounter =  this.playerController.isNotCreative() ? 10 : 0;
+					}
+					else
+					{
+						this.playerController.clickBlock(var1, var2, var3, this.objectMouseOver.sideHit);
+						this.leftClickCounter =  this.playerController.isNotCreative() ? 0 : 10;
+						if (!this.playerController.isNotCreative()) this.sendClickBlockToController(this.currentScreen == null);
+					}
+				}
+			}
+		}
+
+		if (this.playerController.isNotCreative()) 	this.sendClickBlockToController(this.currentScreen == null);
+
+	}
+
+	/**
+	 * Called when user clicked he's mouse right button (place)
+	 */
+	/** MINECRIFT */ 
+	public void rightClickMouse()
+	/** END MINECRIFT */
+	{
+		if (rightClickDelayTimer <= 0){
+
+			this.rightClickDelayTimer = 12; //JRBUDDA (was 4)
+			boolean var1 = true;
+			ItemStack var2 = this.thePlayer.inventory.getCurrentItem();
+
+			if (this.objectMouseOver == null)
+			{
+				/** MINECRIFT */
+				//logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
+				/** END MINECRIFT */
+			}
+			else
+			{
+				switch (Minecraft.SwitchMovingObjectType.field_152390_a[this.objectMouseOver.typeOfHit.ordinal()])
+				{
+				case 1:
+					if (this.playerController.interactWithEntitySendPacket(this.thePlayer, this.objectMouseOver.entityHit))
+					{
+						var1 = false;
+					}
+
+					break;
+
+				case 2:
+					int var3 = this.objectMouseOver.blockX;
+					int var4 = this.objectMouseOver.blockY;
+					int var5 = this.objectMouseOver.blockZ;
+
+					if (this.theWorld.getBlock(var3, var4, var5).getMaterial() != Material.air)
+					{
+						int var6 = var2 != null ? var2.stackSize : 0;
+
+						boolean result = true;
+						/** MINECRIFT FORGE **/
+						if (Reflector.forgeExists()) {
+							Object event = Reflector.call(Reflector.ForgeEventFactory_onPlayerInteract, new Object[] {thePlayer, Reflector.ForgePlayerInteractEvent_Action_RIGHT_CLICK_BLOCK.getValue(), var3, var4, var5, this.objectMouseOver.sideHit, this.theWorld});
+							result = !Reflector.callBoolean(event, Reflector.ForgeEvent_isCanceled, new Object[0]);
+						}
+						/** END MINECRIFT FORGE **/
+						if (result && this.playerController.onPlayerRightClick(this.thePlayer, this.theWorld, var2, var3, var4, var5, this.objectMouseOver.sideHit, this.objectMouseOver.hitVec))
+						{
+							var1 = false;
+							this.thePlayer.swingItem();
+						}
+
+						if (var2 == null)
+						{
+							return;
+						}
+
+						if (var2.stackSize == 0)
+						{
+							this.thePlayer.inventory.mainInventory[this.thePlayer.inventory.currentItem] = null;
+						}
+						else if (var2.stackSize != var6 || this.playerController.isInCreativeMode())
+						{
+							this.entityRenderer.itemRenderer.resetEquippedProgress();
+						}
+					}
+				}
+			}
+
+			if (var1)
+			{
+				ItemStack var7 = this.thePlayer.inventory.getCurrentItem();
+
+				boolean result = true;
+				/** MINECRIFT FORGE **/
+				if (Reflector.forgeExists()) {
+					Object event = Reflector.call(Reflector.ForgeEventFactory_onPlayerInteract, new Object[] {thePlayer, Reflector.ForgePlayerInteractEvent_Action_RIGHT_CLICK_AIR.getValue(), 0, 0, 0, -1, this.theWorld});
+					result = !Reflector.callBoolean(event, Reflector.ForgeEvent_isCanceled, new Object[0]);
+				}
+				/** END MINECRIFT FORGE **/
+				if (result && var7 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var7))
+				{
+					this.entityRenderer.itemRenderer.resetEquippedProgress2();
+				}
+			}
+
+		}
+	}
+
+	/**
+	 * Toggles fullscreen mode.
+	 */
+	public void toggleFullscreen()
+	{
+		try
+		{
+			this.fullscreen = !this.fullscreen;
+
+			if (this.fullscreen)
+			{
+				this.updateDisplayMode();
+				this.displayWidth = Display.getDisplayMode().getWidth();
+				this.displayHeight = Display.getDisplayMode().getHeight();
+
+				if (this.displayWidth <= 0)
+				{
+					this.displayWidth = 1;
+				}
+
+				if (this.displayHeight <= 0)
+				{
+					this.displayHeight = 1;
+				}
+			}
+			else
+			{
+				Display.setDisplayMode(new DisplayMode(this.tempDisplayWidth, this.tempDisplayHeight));
+				this.displayWidth = this.tempDisplayWidth;
+				this.displayHeight = this.tempDisplayHeight;
+
+				if (this.displayWidth <= 0)
+				{
+					this.displayWidth = 1;
+				}
+
+				if (this.displayHeight <= 0)
+				{
+					this.displayHeight = 1;
+				}
+			}
+
+			if (this.currentScreen != null)
+			{
+				this.resize(this.displayWidth, this.displayHeight);
+			}
+			else
+			{
+				this.updateFramebufferSize();
+			}
+
+			Display.setFullscreen(this.fullscreen);
+			/** MINECRIFT */
+			Display.setVSyncEnabled(false);
+			this.resetSize();
+			/** END MINECRIFT */
+		}
+		catch (Exception var2)
+		{
+			logger.error("Couldn\'t toggle fullscreen", var2);
+		}
+	}
+
+	/**
+	 * Called to resize the current screen.
+	 */
+	private void resize(int width, int height)
+	{
+		/** MINECRIFT */
+		this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+		/** END MINECRIFT */
+
+	}
+
+	private void updateFramebufferSize()
+	{
+		/** MINECRIFT */
+		this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+		/*      this.framebufferMc.createBindFramebuffer(this.displayWidth, this.displayHeight);
 
         if (this.entityRenderer != null)
         {
             this.entityRenderer.updateShaderGroupSize(this.displayWidth, this.displayHeight);
-        }
-    }
-
-    /**
-     * Runs the current tick.
-     */
-    public void runTick()
-    {
-        this.mcProfiler.startSection("scheduledExecutables");
-        Queue var1 = this.scheduledTasks;
-
-        synchronized (this.scheduledTasks)
-        {
-            while (!this.scheduledTasks.isEmpty())
-            {
-                ((FutureTask)this.scheduledTasks.poll()).run();
-            }
-        }
-
-        this.mcProfiler.endSection();
-
-        if (this.rightClickDelayTimer > 0)
-        {
-            --this.rightClickDelayTimer;
-        }
-
-        this.mcProfiler.startSection("gui");
-
-        if (!this.isGamePaused)
-        {
-            this.ingameGUI.updateTick();
-        }
-
-        this.mcProfiler.endStartSection("pick");
-        this.entityRenderer.getMouseOver(1.0F);
-        this.mcProfiler.endStartSection("gameMode");
-
-        if (!this.isGamePaused && this.theWorld != null)
-        {
-            this.playerController.updateController();
-        }
-
-        this.mcProfiler.endStartSection("textures");
-
-        if (!this.isGamePaused)
-        {
-            this.renderEngine.tick();
-        }
-
-        if (this.currentScreen == null && this.thePlayer != null)
-        {
-            if (this.thePlayer.getHealth() <= 0.0F)
-            {
-                this.displayGuiScreen((GuiScreen)null);
-            }
-            else if (this.thePlayer.isPlayerSleeping() && this.theWorld != null)
-            {
-                this.displayGuiScreen(new GuiSleepMP());
-            }
-        }
-        else if (this.currentScreen != null && this.currentScreen instanceof GuiSleepMP && !this.thePlayer.isPlayerSleeping())
-        {
-            this.displayGuiScreen((GuiScreen)null);
-        }
-
-        if (this.currentScreen != null)
-        {
-            this.leftClickCounter = 10000;
-        }
-
-        CrashReport var2;
-        CrashReportCategory var3;
-
-        if (this.currentScreen != null)
-        {
-            try
-            {
-                this.currentScreen.handleInput();
-            }
-            catch (Throwable var6)
-            {
-                var2 = CrashReport.makeCrashReport(var6, "Updating screen events");
-                var3 = var2.makeCategory("Affected screen");
-                var3.addCrashSectionCallable("Screen name", new Callable()
-                {
-                    private static final String __OBFID = "CL_00000640";
-                    public String call()
-                    {
-                        return Minecraft.this.currentScreen.getClass().getCanonicalName();
-                    }
-                });
-                throw new ReportedException(var2);
-            }
-
-            if (this.currentScreen != null)
-            {
-                try
-                {
-                    this.currentScreen.updateScreen();
-                }
-                catch (Throwable var5)
-                {
-                    var2 = CrashReport.makeCrashReport(var5, "Ticking screen");
-                    var3 = var2.makeCategory("Affected screen");
-                    var3.addCrashSectionCallable("Screen name", new Callable()
-                    {
-                        private static final String __OBFID = "CL_00000642";
-                        public String call()
-                        {
-                            return Minecraft.this.currentScreen.getClass().getCanonicalName();
-                        }
-                    });
-                    throw new ReportedException(var2);
-                }
-            }
-        }
-
-        if (this.currentScreen == null || this.currentScreen.allowUserInput)
-        {
-            this.mcProfiler.endStartSection("mouse");
-            int var9;
-
-            while (Mouse.next())
-            {
-                var9 = Mouse.getEventButton();
-                KeyBinding.setKeyBindState(var9 - 100, Mouse.getEventButtonState());
-
-                if (Mouse.getEventButtonState())
-                {
-                    KeyBinding.onTick(var9 - 100);
-                }
-
-                long var11 = getSystemTime() - this.systemTime;
-
-                if (var11 <= 200L)
-                {
-                    int var4 = Mouse.getEventDWheel();
-
-                    if (var4 != 0)
-                    {
-                        this.thePlayer.inventory.changeCurrentItem(var4);
-
-                        if (this.gameSettings.noclip)
-                        {
-                            if (var4 > 0)
-                            {
-                                var4 = 1;
-                            }
-
-                            if (var4 < 0)
-                            {
-                                var4 = -1;
-                            }
-
-                            this.gameSettings.noclipRate += (float)var4 * 0.25F;
-                        }
-                    }
-
-                    if (this.currentScreen == null)
-                    {
-                        if (!this.inGameHasFocus && Mouse.getEventButtonState())
-                        {
-                            this.setIngameFocus();
-                        }
-                    }
-                    else if (this.currentScreen != null)
-                    {
-                        this.currentScreen.handleMouseInput();
-                    }
-                }
-            }
-
-            if (this.leftClickCounter > 0)
-            {
-                --this.leftClickCounter;
-            }
-
-            this.mcProfiler.endStartSection("keyboard");
-            boolean var10;
-
-            while (Keyboard.next())
-            {
-                KeyBinding.setKeyBindState(Keyboard.getEventKey(), Keyboard.getEventKeyState());
-
-                if (Keyboard.getEventKeyState())
-                {
-                    KeyBinding.onTick(Keyboard.getEventKey());
-                }
-
-                if (this.debugCrashKeyPressTime > 0L)
-                {
-                    if (getSystemTime() - this.debugCrashKeyPressTime >= 6000L)
-                    {
-                        throw new ReportedException(new CrashReport("Manually triggered debug crash", new Throwable()));
-                    }
-
-                    if (!Keyboard.isKeyDown(46) || !Keyboard.isKeyDown(61))
-                    {
-                        this.debugCrashKeyPressTime = -1L;
-                    }
-                }
-                else if (Keyboard.isKeyDown(46) && Keyboard.isKeyDown(61))
-                {
-                    this.debugCrashKeyPressTime = getSystemTime();
-                }
-
-                this.dispatchKeypresses();
-
-                if (Keyboard.getEventKeyState())
-                {
-                    if (Keyboard.getEventKey() == 62 && this.entityRenderer != null)
-                    {
-                        this.entityRenderer.deactivateShader();
-                    }
-
-                    if (this.currentScreen != null)
-                    {
-                        this.currentScreen.handleKeyboardInput();
-                    }
-                    else
-                    {
-                        if (Keyboard.getEventKey() == 1)
-                        {
-                            this.displayInGameMenu();
-                        }
-
-                        if (Keyboard.getEventKey() == 31 && Keyboard.isKeyDown(61))
-                        {
-                            this.refreshResources();
-                        }
-
-                        if (Keyboard.getEventKey() == 20 && Keyboard.isKeyDown(61))
-                        {
-                            this.refreshResources();
-                        }
-
-                        if (Keyboard.getEventKey() == 33 && Keyboard.isKeyDown(61))
-                        {
-                            var10 = Keyboard.isKeyDown(42) | Keyboard.isKeyDown(54);
-                            this.gameSettings.setOptionValue(GameSettings.Options.RENDER_DISTANCE, var10 ? -1 : 1);
-                        }
-
-                        if (Keyboard.getEventKey() == 30 && Keyboard.isKeyDown(61))
-                        {
-                            this.renderGlobal.loadRenderers();
-                        }
-
-                        if (Keyboard.getEventKey() == 35 && Keyboard.isKeyDown(61))
-                        {
-                            this.gameSettings.advancedItemTooltips = !this.gameSettings.advancedItemTooltips;
-                            this.gameSettings.saveOptions();
-                        }
-
-                        if (Keyboard.getEventKey() == 48 && Keyboard.isKeyDown(61))
-                        {
-                            RenderManager.debugBoundingBox = !RenderManager.debugBoundingBox;
-                        }
-
-                        if (Keyboard.getEventKey() == 25 && Keyboard.isKeyDown(61))
-                        {
-                            this.gameSettings.pauseOnLostFocus = !this.gameSettings.pauseOnLostFocus;
-                            this.gameSettings.saveOptions();
-                        }
-
-                        if (Keyboard.getEventKey() == 59)
-                        {
-                            this.gameSettings.hideGUI = !this.gameSettings.hideGUI;
-                        }
-
-                        if (Keyboard.getEventKey() == 61)
-                        {
-                            this.gameSettings.showDebugInfo = !this.gameSettings.showDebugInfo;
-                            this.gameSettings.showDebugProfilerChart = GuiScreen.isShiftKeyDown();
-                        }
-
-                        if (this.gameSettings.keyBindTogglePerspective.isPressed())
-                        {
-                            ++this.gameSettings.thirdPersonView;
-
-                            if (this.gameSettings.thirdPersonView > 2)
-                            {
-                                this.gameSettings.thirdPersonView = 0;
-                            }
-                        }
-
-                        if (this.gameSettings.keyBindSmoothCamera.isPressed())
-                        {
-                            this.gameSettings.smoothCamera = !this.gameSettings.smoothCamera;
-                        }
-                    }
-
-                    if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)
-                    {
-                        if (Keyboard.getEventKey() == 11)
-                        {
-                            this.updateDebugProfilerName(0);
-                        }
-
-                        for (var9 = 0; var9 < 9; ++var9)
-                        {
-                            if (Keyboard.getEventKey() == 2 + var9)
-                            {
-                                this.updateDebugProfilerName(var9 + 1);
-                            }
-                        }
-                    }
-                }
-            }
-
-            for (var9 = 0; var9 < 9; ++var9)
-            {
-                if (this.gameSettings.keyBindsHotbar[var9].isPressed())
-                {
-                    this.thePlayer.inventory.currentItem = var9;
-                }
-            }
-
-            var10 = this.gameSettings.chatVisibility != EntityPlayer.EnumChatVisibility.HIDDEN;
-
-            while (this.gameSettings.keyBindInventory.isPressed())
-            {
-                if (this.playerController.isRidingHorse())
-                {
-                    this.thePlayer.sendHorseInteraction();
-                }
-                else
-                {
-                    this.getNetHandler().addToSendQueue(new C16PacketClientStatus(C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT));
-                    this.displayGuiScreen(new GuiInventory(this.thePlayer));
-                }
-            }
-
-            while (this.gameSettings.keyBindDrop.isPressed())
-            {
-                this.thePlayer.dropOneItem(GuiScreen.isCtrlKeyDown());
-            }
-
-            while (this.gameSettings.keyBindChat.isPressed() && var10)
-            {
-                this.displayGuiScreen(new GuiChat());
-            }
-
-            if (this.currentScreen == null && this.gameSettings.keyBindCommand.isPressed() && var10)
-            {
-                this.displayGuiScreen(new GuiChat("/"));
-            }
-
-            if (this.thePlayer.isUsingItem())
-            {
-                if (!this.gameSettings.keyBindUseItem.getIsKeyPressed())
-                {
-                    this.playerController.onStoppedUsingItem(this.thePlayer);
-                }
-
-                label391:
-
-                while (true)
-                {
-                    if (!this.gameSettings.keyBindAttack.isPressed())
-                    {
-                        while (this.gameSettings.keyBindUseItem.isPressed())
-                        {
-                            ;
-                        }
-
-                        while (true)
-                        {
-                            if (this.gameSettings.keyBindPickBlock.isPressed())
-                            {
-                                continue;
-                            }
-
-                            break label391;
-                        }
-                    }
-                }
-            }
-            else
-            {
-                while (this.gameSettings.keyBindAttack.isPressed())
-                {
-                    this.clickMouse();
-                }
-
-                while (this.gameSettings.keyBindUseItem.isPressed())
-                {
-                    this.rightClickMouse();
-                }
-
-                while (this.gameSettings.keyBindPickBlock.isPressed())
-                {
-                    this.middleClickMouse();
-                }
-            }
-
-            if (this.gameSettings.keyBindUseItem.getIsKeyPressed() && this.rightClickDelayTimer == 0 && !this.thePlayer.isUsingItem())
-            {
-                this.rightClickMouse();
-            }
-
-            this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.getIsKeyPressed() && this.inGameHasFocus);
-        }
-
-        if (this.theWorld != null)
-        {
-            if (this.thePlayer != null)
-            {
-                ++this.joinPlayerCounter;
-
-                if (this.joinPlayerCounter == 30)
-                {
-                    this.joinPlayerCounter = 0;
-                    this.theWorld.joinEntityInSurroundings(this.thePlayer);
-                }
-            }
-
-            this.mcProfiler.endStartSection("gameRenderer");
-
-            if (!this.isGamePaused)
-            {
-                this.entityRenderer.updateRenderer();
-            }
-
-            this.mcProfiler.endStartSection("levelRenderer");
-
-            if (!this.isGamePaused)
-            {
-                this.renderGlobal.updateClouds();
-            }
-
-            this.mcProfiler.endStartSection("level");
-
-            if (!this.isGamePaused)
-            {
-                if (this.theWorld.lastLightningBolt > 0)
-                {
-                    --this.theWorld.lastLightningBolt;
-                }
-
-                this.theWorld.updateEntities();
-            }
-        }
-
-        if (!this.isGamePaused)
-        {
-            this.mcMusicTicker.update();
-            this.mcSoundHandler.update();
-        }
-
-        if (this.theWorld != null)
-        {
-            if (!this.isGamePaused)
-            {
-                this.theWorld.setAllowedSpawnTypes(this.theWorld.difficultySetting != EnumDifficulty.PEACEFUL, true);
-
-                try
-                {
-                    this.theWorld.tick();
-                }
-                catch (Throwable var7)
-                {
-                    var2 = CrashReport.makeCrashReport(var7, "Exception in world tick");
-
-                    if (this.theWorld == null)
-                    {
-                        var3 = var2.makeCategory("Affected level");
-                        var3.addCrashSection("Problem", "Level is null!");
-                    }
-                    else
-                    {
-                        this.theWorld.addWorldInfoToCrashReport(var2);
-                    }
-
-                    throw new ReportedException(var2);
-                }
-            }
-
-            this.mcProfiler.endStartSection("animateTick");
-
-            if (!this.isGamePaused && this.theWorld != null)
-            {
-                this.theWorld.doVoidFogParticles(MathHelper.floor_double(this.thePlayer.posX), MathHelper.floor_double(this.thePlayer.posY), MathHelper.floor_double(this.thePlayer.posZ));
-            }
-
-            this.mcProfiler.endStartSection("particles");
-
-            if (!this.isGamePaused)
-            {
-                this.effectRenderer.updateEffects();
-            }
-        }
-        else if (this.myNetworkManager != null)
-        {
-            this.mcProfiler.endStartSection("pendingConnection");
-            this.myNetworkManager.processReceivedPackets();
-        }
-
-        this.mcProfiler.endSection();
-        this.systemTime = getSystemTime();
-    }
-
-    /**
-     * Arguments: World foldername,  World ingame name, WorldSettings
-     */
-    public void launchIntegratedServer(String folderName, String worldName, WorldSettings worldSettingsIn)
-    {
-        this.loadWorld((WorldClient)null);
-        System.gc();
-        ISaveHandler var4 = this.saveLoader.getSaveLoader(folderName, false);
-        WorldInfo var5 = var4.loadWorldInfo();
-
-        if (var5 == null && worldSettingsIn != null)
-        {
-            var5 = new WorldInfo(worldSettingsIn, folderName);
-            var4.saveWorldInfo(var5);
-        }
-
-        if (worldSettingsIn == null)
-        {
-            worldSettingsIn = new WorldSettings(var5);
-        }
-
-        try
-        {
-            this.theIntegratedServer = new IntegratedServer(this, folderName, worldName, worldSettingsIn);
-            this.theIntegratedServer.startServerThread();
-            this.integratedServerIsRunning = true;
-        }
-        catch (Throwable var10)
-        {
-            CrashReport var7 = CrashReport.makeCrashReport(var10, "Starting integrated server");
-            CrashReportCategory var8 = var7.makeCategory("Starting integrated server");
-            var8.addCrashSection("Level ID", folderName);
-            var8.addCrashSection("Level Name", worldName);
-            throw new ReportedException(var7);
-        }
-
-        this.loadingScreen.displaySavingString(I18n.format("menu.loadingLevel", new Object[0]));
-
-        while (!this.theIntegratedServer.serverIsInRunLoop())
-        {
-            String var6 = this.theIntegratedServer.getUserMessage();
-
-            if (var6 != null)
-            {
-                this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
-            }
-            else
-            {
-                this.loadingScreen.displayLoadingString("");
-            }
-
-            try
-            {
-                Thread.sleep(200L);
-            }
-            catch (InterruptedException var9)
-            {
-                ;
-            }
-        }
-
-        this.displayGuiScreen((GuiScreen)null);
-        SocketAddress var11 = this.theIntegratedServer.getNetworkSystem().addLocalEndpoint();
-        NetworkManager var12 = NetworkManager.provideLocalClient(var11);
-        var12.setNetHandler(new NetHandlerLoginClient(var12, this, (GuiScreen)null));
-        var12.scheduleOutboundPacket(new C00Handshake(5, var11.toString(), 0, EnumConnectionState.LOGIN), new GenericFutureListener[0]);
-        var12.scheduleOutboundPacket(new C00PacketLoginStart(this.getSession().getProfile()), new GenericFutureListener[0]);
-        this.myNetworkManager = var12;
-    }
-
-    /**
-     * unloads the current world first
-     */
-    public void loadWorld(WorldClient worldClientIn)
-    {
-        this.loadWorld(worldClientIn, "");
-    }
-
-    /**
-     * par2Str is displayed on the loading screen to the user unloads the current world first
-     */
-    public void loadWorld(WorldClient worldClientIn, String loadingMessage)
-    {
-        if (worldClientIn == null)
-        {
-            NetHandlerPlayClient var3 = this.getNetHandler();
-
-            if (var3 != null)
-            {
-                var3.cleanup();
-            }
-
-            if (this.theIntegratedServer != null)
-            {
-                this.theIntegratedServer.initiateShutdown();
-            }
-
-            this.theIntegratedServer = null;
-            this.guiAchievement.clearAchievements();
-            this.entityRenderer.getMapItemRenderer().func_148249_a();
-        }
-
-        this.renderViewEntity = null;
-        this.myNetworkManager = null;
-
-        if (this.loadingScreen != null)
-        {
-            this.loadingScreen.resetProgressAndMessage(loadingMessage);
-            this.loadingScreen.displayLoadingString("");
-        }
-
-        if (worldClientIn == null && this.theWorld != null)
-        {
-            if (this.mcResourcePackRepository.getResourcePackInstance() != null)
-            {
-                this.scheduleResourcesRefresh();
-            }
-
-            this.mcResourcePackRepository.func_148529_f();
-            this.setServerData((ServerData)null);
-            this.integratedServerIsRunning = false;
-        }
-
-        this.mcSoundHandler.stopSounds();
-        this.theWorld = worldClientIn;
-
-        if (worldClientIn != null)
-        {
-            if (this.renderGlobal != null)
-            {
-                this.renderGlobal.setWorldAndLoadRenderers(worldClientIn);
-            }
-
-            if (this.effectRenderer != null)
-            {
-                this.effectRenderer.clearEffects(worldClientIn);
-            }
-
-            if (this.thePlayer == null)
-            {
-                this.thePlayer = this.playerController.createPlayer(worldClientIn, new StatFileWriter());
-                this.playerController.flipPlayer(this.thePlayer);
-            }
-
-            this.thePlayer.preparePlayerToSpawn();
-            worldClientIn.spawnEntityInWorld(this.thePlayer);
-            this.thePlayer.movementInput = new MovementInputFromOptions(this.gameSettings);
-            this.playerController.setPlayerCapabilities(this.thePlayer);
-            this.renderViewEntity = this.thePlayer;
-        }
-        else
-        {
-            this.saveLoader.flushCache();
-            this.thePlayer = null;
-        }
-
-        System.gc();
-        this.systemTime = 0L;
-    }
-
-    /**
-     * A String of renderGlobal.getDebugInfoRenders
-     */
-    public String debugInfoRenders()
-    {
-        return this.renderGlobal.getDebugInfoRenders();
-    }
-
-    /**
-     * Gets the information in the F3 menu about how many entities are infront/around you
-     */
-    public String getEntityDebug()
-    {
-        return this.renderGlobal.getDebugInfoEntities();
-    }
-
-    /**
-     * Gets the name of the world's current chunk provider
-     */
-    public String getWorldProviderName()
-    {
-        return this.theWorld.getProviderName();
-    }
-
-    /**
-     * A String of how many entities are in the world
-     */
-    public String debugInfoEntities()
-    {
-        return "P: " + this.effectRenderer.getStatistics() + ". T: " + this.theWorld.getDebugLoadedEntities();
-    }
-
-    public void setDimensionAndSpawnPlayer(int dimension)
-    {
-        this.theWorld.setSpawnLocation();
-        this.theWorld.removeAllEntities();
-        int var2 = 0;
-        String var3 = null;
-
-        if (this.thePlayer != null)
-        {
-            var2 = this.thePlayer.getEntityId();
-            this.theWorld.removeEntity(this.thePlayer);
-            var3 = this.thePlayer.getClientBrand();
-        }
-
-        this.renderViewEntity = null;
-        this.thePlayer = this.playerController.createPlayer(this.theWorld, this.thePlayer == null ? new StatFileWriter() : this.thePlayer.getStatFileWriter());
-        this.thePlayer.dimension = dimension;
-        this.renderViewEntity = this.thePlayer;
-        this.thePlayer.preparePlayerToSpawn();
-        this.thePlayer.setClientBrand(var3);
-        this.theWorld.spawnEntityInWorld(this.thePlayer);
-        this.playerController.flipPlayer(this.thePlayer);
-        this.thePlayer.movementInput = new MovementInputFromOptions(this.gameSettings);
-        this.thePlayer.setEntityId(var2);
-        this.playerController.setPlayerCapabilities(this.thePlayer);
-
-        if (this.currentScreen instanceof GuiGameOver)
-        {
-            this.displayGuiScreen((GuiScreen)null);
-        }
-    }
-
-    /**
-     * Gets whether this is a demo or not.
-     */
-    public final boolean isDemo()
-    {
-        return this.isDemo;
-    }
-
-    public NetHandlerPlayClient getNetHandler()
-    {
-        return this.thePlayer != null ? this.thePlayer.sendQueue : null;
-    }
-
-    public static boolean isGuiEnabled()
-    {
-        return theMinecraft == null || !theMinecraft.gameSettings.hideGUI;
-    }
-
-    public static boolean isFancyGraphicsEnabled()
-    {
-        return theMinecraft != null && theMinecraft.gameSettings.fancyGraphics;
-    }
-
-    /**
-     * Returns if ambient occlusion is enabled
-     */
-    public static boolean isAmbientOcclusionEnabled()
-    {
-        return theMinecraft != null && theMinecraft.gameSettings.ambientOcclusion != 0;
-    }
-
-    /**
-     * Called when user clicked he's mouse middle button (pick block)
-     */
-    private void middleClickMouse()
-    {
-        if (this.objectMouseOver != null)
-        {
-            boolean var1 = this.thePlayer.capabilities.isCreativeMode;
-            int var3 = 0;
-            boolean var4 = false;
-            Item var2;
-            int var5;
-
-            if (this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
-            {
-                var5 = this.objectMouseOver.blockX;
-                int var6 = this.objectMouseOver.blockY;
-                int var7 = this.objectMouseOver.blockZ;
-                Block var8 = this.theWorld.getBlock(var5, var6, var7);
-
-                if (var8.getMaterial() == Material.air)
-                {
-                    return;
-                }
-
-                var2 = var8.getItem(this.theWorld, var5, var6, var7);
-
-                if (var2 == null)
-                {
-                    return;
-                }
-
-                var4 = var2.getHasSubtypes();
-                Block var9 = var2 instanceof ItemBlock && !var8.isFlowerPot() ? Block.getBlockFromItem(var2) : var8;
-                var3 = var9.getDamageValue(this.theWorld, var5, var6, var7);
-            }
-            else
-            {
-                if (this.objectMouseOver.typeOfHit != MovingObjectPosition.MovingObjectType.ENTITY || this.objectMouseOver.entityHit == null || !var1)
-                {
-                    return;
-                }
-
-                if (this.objectMouseOver.entityHit instanceof EntityPainting)
-                {
-                    var2 = Items.painting;
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityLeashKnot)
-                {
-                    var2 = Items.lead;
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityItemFrame)
-                {
-                    EntityItemFrame var10 = (EntityItemFrame)this.objectMouseOver.entityHit;
-                    ItemStack var12 = var10.getDisplayedItem();
-
-                    if (var12 == null)
-                    {
-                        var2 = Items.item_frame;
-                    }
-                    else
-                    {
-                        var2 = var12.getItem();
-                        var3 = var12.getMetadata();
-                        var4 = true;
-                    }
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityMinecart)
-                {
-                    EntityMinecart var11 = (EntityMinecart)this.objectMouseOver.entityHit;
-
-                    if (var11.getMinecartType() == 2)
-                    {
-                        var2 = Items.furnace_minecart;
-                    }
-                    else if (var11.getMinecartType() == 1)
-                    {
-                        var2 = Items.chest_minecart;
-                    }
-                    else if (var11.getMinecartType() == 3)
-                    {
-                        var2 = Items.tnt_minecart;
-                    }
-                    else if (var11.getMinecartType() == 5)
-                    {
-                        var2 = Items.hopper_minecart;
-                    }
-                    else if (var11.getMinecartType() == 6)
-                    {
-                        var2 = Items.command_block_minecart;
-                    }
-                    else
-                    {
-                        var2 = Items.minecart;
-                    }
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityBoat)
-                {
-                    var2 = Items.boat;
-                }
-                else
-                {
-                    var2 = Items.spawn_egg;
-                    var3 = EntityList.getEntityID(this.objectMouseOver.entityHit);
-                    var4 = true;
-
-                    if (var3 <= 0 || !EntityList.entityEggs.containsKey(Integer.valueOf(var3)))
-                    {
-                        return;
-                    }
-                }
-            }
-
-            this.thePlayer.inventory.setCurrentItem(var2, var3, var4, var1);
-
-            if (var1)
-            {
-                var5 = this.thePlayer.inventoryContainer.inventorySlots.size() - 9 + this.thePlayer.inventory.currentItem;
-                this.playerController.sendSlotPacket(this.thePlayer.inventory.getStackInSlot(this.thePlayer.inventory.currentItem), var5);
-            }
-        }
-    }
-
-    /**
-     * adds core server Info (GL version , Texture pack, isModded, type), and the worldInfo to the crash report
-     */
-    public CrashReport addGraphicsAndWorldToCrashReport(CrashReport theCrash)
-    {
-        theCrash.getCategory().addCrashSectionCallable("Launched Version", new Callable()
-        {
-            private static final String __OBFID = "CL_00000643";
-            public String call()
-            {
-                return Minecraft.this.launchedVersion;
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("LWJGL", new Callable()
-        {
-            private static final String __OBFID = "CL_00000644";
-            public String call()
-            {
-                return Sys.getVersion();
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("OpenGL", new Callable()
-        {
-            private static final String __OBFID = "CL_00000645";
-            public String call()
-            {
-                return GL11.glGetString(GL11.GL_RENDERER) + " GL version " + GL11.glGetString(GL11.GL_VERSION) + ", " + GL11.glGetString(GL11.GL_VENDOR);
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("GL Caps", new Callable()
-        {
-            private static final String __OBFID = "CL_00000646";
-            public String call()
-            {
-                return OpenGlHelper.func_153172_c();
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Is Modded", new Callable()
-        {
-            private static final String __OBFID = "CL_00000647";
-            public String call()
-            {
-                String var1 = ClientBrandRetriever.getClientModName();
-                return !var1.equals("vanilla") ? "Definitely; Client brand changed to \'" + var1 + "\'" : (Minecraft.class.getSigners() == null ? "Very likely; Jar signature invalidated" : "Probably not. Jar signature remains and client brand is untouched.");
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Type", new Callable()
-        {
-            private static final String __OBFID = "CL_00000633";
-            public String call()
-            {
-                return "Client (map_client.txt)";
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Resource Packs", new Callable()
-        {
-            private static final String __OBFID = "CL_00000634";
-            public String call()
-            {
-                return Minecraft.this.gameSettings.resourcePacks.toString();
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Current Language", new Callable()
-        {
-            private static final String __OBFID = "CL_00000635";
-            public String call()
-            {
-                return Minecraft.this.mcLanguageManager.getCurrentLanguage().toString();
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Profiler Position", new Callable()
-        {
-            private static final String __OBFID = "CL_00000636";
-            public String call()
-            {
-                return Minecraft.this.mcProfiler.profilingEnabled ? Minecraft.this.mcProfiler.getNameOfLastSection() : "N/A (disabled)";
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Vec3 Pool Size", new Callable()
-        {
-            private static final String __OBFID = "CL_00000637";
-            public String call()
-            {
-                byte var1 = 0;
-                int var2 = 56 * var1;
-                int var3 = var2 / 1024 / 1024;
-                byte var4 = 0;
-                int var5 = 56 * var4;
-                int var6 = var5 / 1024 / 1024;
-                return var1 + " (" + var2 + " bytes; " + var3 + " MB) allocated, " + var4 + " (" + var5 + " bytes; " + var6 + " MB) used";
-            }
-        });
-        theCrash.getCategory().addCrashSectionCallable("Anisotropic Filtering", new Callable()
-        {
-            private static final String __OBFID = "CL_00001853";
-            public String func_152388_a()
-            {
-                return Minecraft.this.gameSettings.anisotropicFiltering == 1 ? "Off (1)" : "On (" + Minecraft.this.gameSettings.anisotropicFiltering + ")";
-            }
-            public Object call()
-            {
-                return this.func_152388_a();
-            }
-        });
-
-        if (this.theWorld != null)
-        {
-            this.theWorld.addWorldInfoToCrashReport(theCrash);
-        }
-
-        return theCrash;
-    }
-
-    /**
-     * Return the singleton Minecraft instance for the game
-     */
-    public static Minecraft getMinecraft()
-    {
-        return theMinecraft;
-    }
-
-    public void scheduleResourcesRefresh()
-    {
-        this.refreshTexturePacksScheduled = true;
-    }
-
-    public void addServerStatsToSnooper(PlayerUsageSnooper playerSnooper)
-    {
-        playerSnooper.addClientStat("fps", Integer.valueOf(debugFPS));
-        playerSnooper.addClientStat("vsync_enabled", Boolean.valueOf(this.gameSettings.enableVsync));
-        playerSnooper.addClientStat("display_frequency", Integer.valueOf(Display.getDisplayMode().getFrequency()));
-        playerSnooper.addClientStat("display_type", this.fullscreen ? "fullscreen" : "windowed");
-        playerSnooper.addClientStat("run_time", Long.valueOf((MinecraftServer.getCurrentTimeMillis() - playerSnooper.getMinecraftStartTimeMillis()) / 60L * 1000L));
-        playerSnooper.addClientStat("resource_packs", Integer.valueOf(this.mcResourcePackRepository.getRepositoryEntries().size()));
-        int var2 = 0;
-        Iterator var3 = this.mcResourcePackRepository.getRepositoryEntries().iterator();
-
-        while (var3.hasNext())
-        {
-            ResourcePackRepository.Entry var4 = (ResourcePackRepository.Entry)var3.next();
-            playerSnooper.addClientStat("resource_pack[" + var2++ + "]", var4.getResourcePackName());
-        }
-
-        if (this.theIntegratedServer != null && this.theIntegratedServer.getPlayerUsageSnooper() != null)
-        {
-            playerSnooper.addClientStat("snooper_partner", this.theIntegratedServer.getPlayerUsageSnooper().getUniqueID());
-        }
-    }
-
-    public void addServerTypeToSnooper(PlayerUsageSnooper playerSnooper)
-    {
-        playerSnooper.addStatToSnooper("opengl_version", GL11.glGetString(GL11.GL_VERSION));
-        playerSnooper.addStatToSnooper("opengl_vendor", GL11.glGetString(GL11.GL_VENDOR));
-        playerSnooper.addStatToSnooper("client_brand", ClientBrandRetriever.getClientModName());
-        playerSnooper.addStatToSnooper("launched_version", this.launchedVersion);
-        ContextCapabilities var2 = GLContext.getCapabilities();
-        playerSnooper.addStatToSnooper("gl_caps[ARB_arrays_of_arrays]", Boolean.valueOf(var2.GL_ARB_arrays_of_arrays));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_base_instance]", Boolean.valueOf(var2.GL_ARB_base_instance));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_blend_func_extended]", Boolean.valueOf(var2.GL_ARB_blend_func_extended));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_clear_buffer_object]", Boolean.valueOf(var2.GL_ARB_clear_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_color_buffer_float]", Boolean.valueOf(var2.GL_ARB_color_buffer_float));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_compatibility]", Boolean.valueOf(var2.GL_ARB_compatibility));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_compressed_texture_pixel_storage]", Boolean.valueOf(var2.GL_ARB_compressed_texture_pixel_storage));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_compute_shader]", Boolean.valueOf(var2.GL_ARB_compute_shader));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_copy_buffer]", Boolean.valueOf(var2.GL_ARB_copy_buffer));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_copy_image]", Boolean.valueOf(var2.GL_ARB_copy_image));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_depth_buffer_float]", Boolean.valueOf(var2.GL_ARB_depth_buffer_float));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_compute_shader]", Boolean.valueOf(var2.GL_ARB_compute_shader));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_copy_buffer]", Boolean.valueOf(var2.GL_ARB_copy_buffer));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_copy_image]", Boolean.valueOf(var2.GL_ARB_copy_image));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_depth_buffer_float]", Boolean.valueOf(var2.GL_ARB_depth_buffer_float));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_depth_clamp]", Boolean.valueOf(var2.GL_ARB_depth_clamp));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_depth_texture]", Boolean.valueOf(var2.GL_ARB_depth_texture));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_draw_buffers]", Boolean.valueOf(var2.GL_ARB_draw_buffers));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_draw_buffers_blend]", Boolean.valueOf(var2.GL_ARB_draw_buffers_blend));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_draw_elements_base_vertex]", Boolean.valueOf(var2.GL_ARB_draw_elements_base_vertex));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_draw_indirect]", Boolean.valueOf(var2.GL_ARB_draw_indirect));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_draw_instanced]", Boolean.valueOf(var2.GL_ARB_draw_instanced));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_explicit_attrib_location]", Boolean.valueOf(var2.GL_ARB_explicit_attrib_location));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_explicit_uniform_location]", Boolean.valueOf(var2.GL_ARB_explicit_uniform_location));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_layer_viewport]", Boolean.valueOf(var2.GL_ARB_fragment_layer_viewport));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_program]", Boolean.valueOf(var2.GL_ARB_fragment_program));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_shader]", Boolean.valueOf(var2.GL_ARB_fragment_shader));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_program_shadow]", Boolean.valueOf(var2.GL_ARB_fragment_program_shadow));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_framebuffer_object]", Boolean.valueOf(var2.GL_ARB_framebuffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_framebuffer_sRGB]", Boolean.valueOf(var2.GL_ARB_framebuffer_sRGB));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_geometry_shader4]", Boolean.valueOf(var2.GL_ARB_geometry_shader4));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_gpu_shader5]", Boolean.valueOf(var2.GL_ARB_gpu_shader5));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_half_float_pixel]", Boolean.valueOf(var2.GL_ARB_half_float_pixel));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_half_float_vertex]", Boolean.valueOf(var2.GL_ARB_half_float_vertex));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_instanced_arrays]", Boolean.valueOf(var2.GL_ARB_instanced_arrays));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_map_buffer_alignment]", Boolean.valueOf(var2.GL_ARB_map_buffer_alignment));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_map_buffer_range]", Boolean.valueOf(var2.GL_ARB_map_buffer_range));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_multisample]", Boolean.valueOf(var2.GL_ARB_multisample));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_multitexture]", Boolean.valueOf(var2.GL_ARB_multitexture));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_occlusion_query2]", Boolean.valueOf(var2.GL_ARB_occlusion_query2));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_pixel_buffer_object]", Boolean.valueOf(var2.GL_ARB_pixel_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_seamless_cube_map]", Boolean.valueOf(var2.GL_ARB_seamless_cube_map));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_shader_objects]", Boolean.valueOf(var2.GL_ARB_shader_objects));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_shader_stencil_export]", Boolean.valueOf(var2.GL_ARB_shader_stencil_export));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_shader_texture_lod]", Boolean.valueOf(var2.GL_ARB_shader_texture_lod));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_shadow]", Boolean.valueOf(var2.GL_ARB_shadow));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_shadow_ambient]", Boolean.valueOf(var2.GL_ARB_shadow_ambient));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_stencil_texturing]", Boolean.valueOf(var2.GL_ARB_stencil_texturing));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_sync]", Boolean.valueOf(var2.GL_ARB_sync));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_tessellation_shader]", Boolean.valueOf(var2.GL_ARB_tessellation_shader));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_texture_border_clamp]", Boolean.valueOf(var2.GL_ARB_texture_border_clamp));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_texture_buffer_object]", Boolean.valueOf(var2.GL_ARB_texture_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_texture_cube_map]", Boolean.valueOf(var2.GL_ARB_texture_cube_map));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_texture_cube_map_array]", Boolean.valueOf(var2.GL_ARB_texture_cube_map_array));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_texture_non_power_of_two]", Boolean.valueOf(var2.GL_ARB_texture_non_power_of_two));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_uniform_buffer_object]", Boolean.valueOf(var2.GL_ARB_uniform_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_blend]", Boolean.valueOf(var2.GL_ARB_vertex_blend));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_buffer_object]", Boolean.valueOf(var2.GL_ARB_vertex_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_program]", Boolean.valueOf(var2.GL_ARB_vertex_program));
-        playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_shader]", Boolean.valueOf(var2.GL_ARB_vertex_shader));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_bindable_uniform]", Boolean.valueOf(var2.GL_EXT_bindable_uniform));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_blend_equation_separate]", Boolean.valueOf(var2.GL_EXT_blend_equation_separate));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_blend_func_separate]", Boolean.valueOf(var2.GL_EXT_blend_func_separate));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_blend_minmax]", Boolean.valueOf(var2.GL_EXT_blend_minmax));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_blend_subtract]", Boolean.valueOf(var2.GL_EXT_blend_subtract));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_draw_instanced]", Boolean.valueOf(var2.GL_EXT_draw_instanced));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_multisample]", Boolean.valueOf(var2.GL_EXT_framebuffer_multisample));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_object]", Boolean.valueOf(var2.GL_EXT_framebuffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_sRGB]", Boolean.valueOf(var2.GL_EXT_framebuffer_sRGB));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_geometry_shader4]", Boolean.valueOf(var2.GL_EXT_geometry_shader4));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_gpu_program_parameters]", Boolean.valueOf(var2.GL_EXT_gpu_program_parameters));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_gpu_shader4]", Boolean.valueOf(var2.GL_EXT_gpu_shader4));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_multi_draw_arrays]", Boolean.valueOf(var2.GL_EXT_multi_draw_arrays));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_packed_depth_stencil]", Boolean.valueOf(var2.GL_EXT_packed_depth_stencil));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_paletted_texture]", Boolean.valueOf(var2.GL_EXT_paletted_texture));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_rescale_normal]", Boolean.valueOf(var2.GL_EXT_rescale_normal));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_separate_shader_objects]", Boolean.valueOf(var2.GL_EXT_separate_shader_objects));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_shader_image_load_store]", Boolean.valueOf(var2.GL_EXT_shader_image_load_store));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_shadow_funcs]", Boolean.valueOf(var2.GL_EXT_shadow_funcs));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_shared_texture_palette]", Boolean.valueOf(var2.GL_EXT_shared_texture_palette));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_clear_tag]", Boolean.valueOf(var2.GL_EXT_stencil_clear_tag));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_two_side]", Boolean.valueOf(var2.GL_EXT_stencil_two_side));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_wrap]", Boolean.valueOf(var2.GL_EXT_stencil_wrap));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_3d]", Boolean.valueOf(var2.GL_EXT_texture_3d));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_array]", Boolean.valueOf(var2.GL_EXT_texture_array));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_buffer_object]", Boolean.valueOf(var2.GL_EXT_texture_buffer_object));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_filter_anisotropic]", Boolean.valueOf(var2.GL_EXT_texture_filter_anisotropic));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_integer]", Boolean.valueOf(var2.GL_EXT_texture_integer));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_lod_bias]", Boolean.valueOf(var2.GL_EXT_texture_lod_bias));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_texture_sRGB]", Boolean.valueOf(var2.GL_EXT_texture_sRGB));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_vertex_shader]", Boolean.valueOf(var2.GL_EXT_vertex_shader));
-        playerSnooper.addStatToSnooper("gl_caps[EXT_vertex_weighting]", Boolean.valueOf(var2.GL_EXT_vertex_weighting));
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_uniforms]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_UNIFORM_COMPONENTS)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_fragment_uniforms]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_FRAGMENT_UNIFORM_COMPONENTS)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_attribs]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_ATTRIBS)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_texture_image_units]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_texture_image_units]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_TEXTURE_IMAGE_UNITS)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_caps[gl_max_texture_image_units]", Integer.valueOf(GL11.glGetInteger(35071)));
-        GL11.glGetError();
-        playerSnooper.addStatToSnooper("gl_max_texture_size", Integer.valueOf(getGLMaximumTextureSize()));
-    }
-
-    /**
-     * Used in the usage snooper.
-     */
-    public static int getGLMaximumTextureSize()
-    {
-        for (int var0 = 16384; var0 > 0; var0 >>= 1)
-        {
-            GL11.glTexImage2D(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_RGBA, var0, var0, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)null);
-            int var1 = GL11.glGetTexLevelParameteri(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
-
-            if (var1 != 0)
-            {
-                return var0;
-            }
-        }
-
-        return -1;
-    }
-
-    /**
-     * Returns whether snooping is enabled or not.
-     */
-    public boolean isSnooperEnabled()
-    {
-        return this.gameSettings.snooperEnabled;
-    }
-
-    /**
-     * Set the current ServerData instance.
-     */
-    public void setServerData(ServerData serverDataIn)
-    {
-        this.currentServerData = serverDataIn;
-    }
-
-    public ServerData getCurrentServerData()
-    {
-        return this.currentServerData;
-    }
-
-    public boolean isIntegratedServerRunning()
-    {
-        return this.integratedServerIsRunning;
-    }
-
-    /**
-     * Returns true if there is only one player playing, and the current server is the integrated one.
-     */
-    public boolean isSingleplayer()
-    {
-        return this.integratedServerIsRunning && this.theIntegratedServer != null;
-    }
-
-    /**
-     * Returns the currently running integrated server
-     */
-    public IntegratedServer getIntegratedServer()
-    {
-        return this.theIntegratedServer;
-    }
-
-    public static void stopIntegratedServer()
-    {
-        if (theMinecraft != null)
-        {
-            IntegratedServer var0 = theMinecraft.getIntegratedServer();
-
-            if (var0 != null)
-            {
-                var0.stopServer();
-            }
-        }
-    }
-
-    /**
-     * Returns the PlayerUsageSnooper instance.
-     */
-    public PlayerUsageSnooper getPlayerUsageSnooper()
-    {
-        return this.usageSnooper;
-    }
-
-    /**
-     * Gets the system time in milliseconds.
-     */
-    public static long getSystemTime()
-    {
-        return Sys.getTime() * 1000L / Sys.getTimerResolution();
-    }
-
-    /**
-     * Returns whether we're in full screen or not.
-     */
-    public boolean isFullScreen()
-    {
-        return this.fullscreen;
-    }
-
-    public Session getSession()
-    {
-        return this.session;
-    }
-
-    public Multimap getTwitchDetails()
-    {
-        return this.twitchDetails;
-    }
-
-    public Proxy getProxy()
-    {
-        return this.proxy;
-    }
-
-    public TextureManager getTextureManager()
-    {
-        return this.renderEngine;
-    }
-
-    public IResourceManager getResourceManager()
-    {
-        return this.mcResourceManager;
-    }
-
-    public ResourcePackRepository getResourcePackRepository()
-    {
-        return this.mcResourcePackRepository;
-    }
-
-    public LanguageManager getLanguageManager()
-    {
-        return this.mcLanguageManager;
-    }
-
-    public TextureMap getTextureMapBlocks()
-    {
-        return this.textureMapBlocks;
-    }
-
-    public boolean isJava64bit()
-    {
-        return this.jvm64bit;
-    }
-
-    public boolean isGamePaused()
-    {
-        return this.isGamePaused;
-    }
-
-    public SoundHandler getSoundHandler()
-    {
-        return this.mcSoundHandler;
-    }
-
-    public MusicTicker.MusicType getAmbientMusicType()
-    {
-        return this.currentScreen instanceof GuiWinGame ? MusicTicker.MusicType.CREDITS : (this.thePlayer != null ? (this.thePlayer.worldObj.provider instanceof WorldProviderHell ? MusicTicker.MusicType.NETHER : (this.thePlayer.worldObj.provider instanceof WorldProviderEnd ? (BossStatus.bossName != null && BossStatus.statusBarTime > 0 ? MusicTicker.MusicType.END_BOSS : MusicTicker.MusicType.END) : (this.thePlayer.capabilities.isCreativeMode && this.thePlayer.capabilities.allowFlying ? MusicTicker.MusicType.CREATIVE : MusicTicker.MusicType.GAME))) : MusicTicker.MusicType.MENU);
-    }
-
-    public IStream getTwitchStream()
-    {
-        return this.stream;
-    }
-
-    public void dispatchKeypresses()
-    {
-        int var1 = Keyboard.getEventKey();
-
-        if (var1 != 0 && !Keyboard.isRepeatEvent())
-        {
-            if (!(this.currentScreen instanceof GuiControls) || ((GuiControls)this.currentScreen).time <= getSystemTime() - 20L)
-            {
-                if (Keyboard.getEventKeyState())
-                {
-                    if (var1 == this.gameSettings.keyBindStreamStartStop.getKeyCode())
-                    {
-                        if (this.getTwitchStream().func_152934_n())
-                        {
-                            this.getTwitchStream().func_152914_u();
-                        }
-                        else if (this.getTwitchStream().func_152924_m())
-                        {
-                            this.displayGuiScreen(new GuiYesNo(new GuiYesNoCallback()
-                            {
-                                private static final String __OBFID = "CL_00001852";
-                                public void confirmClicked(boolean result, int id)
-                                {
-                                    if (result)
-                                    {
-                                        Minecraft.this.getTwitchStream().func_152930_t();
-                                    }
-
-                                    Minecraft.this.displayGuiScreen((GuiScreen)null);
-                                }
-                            }, I18n.format("stream.confirm_start", new Object[0]), "", 0));
-                        }
-                        else if (this.getTwitchStream().func_152928_D() && this.getTwitchStream().func_152936_l())
-                        {
-                            if (this.theWorld != null)
-                            {
-                                this.ingameGUI.getChatGUI().printChatMessage(new ChatComponentText("Not ready to start streaming yet!"));
-                            }
-                        }
-                        else
-                        {
-                            GuiStreamUnavailable.func_152321_a(this.currentScreen);
-                        }
-                    }
-                    else if (var1 == this.gameSettings.keyBindStreamPauseUnpause.getKeyCode())
-                    {
-                        if (this.getTwitchStream().func_152934_n())
-                        {
-                            if (this.getTwitchStream().isPaused())
-                            {
-                                this.getTwitchStream().func_152933_r();
-                            }
-                            else
-                            {
-                                this.getTwitchStream().func_152916_q();
-                            }
-                        }
-                    }
-                    else if (var1 == this.gameSettings.keyBindStreamCommercials.getKeyCode())
-                    {
-                        if (this.getTwitchStream().func_152934_n())
-                        {
-                            this.getTwitchStream().func_152931_p();
-                        }
-                    }
-                    else if (var1 == this.gameSettings.keyBindStreamToggleMic.getKeyCode())
-                    {
-                        this.stream.func_152910_a(true);
-                    }
-                    else if (var1 == this.gameSettings.keyBindFullscreen.getKeyCode())
-                    {
-                        this.toggleFullscreen();
-                    }
-                    else if (var1 == this.gameSettings.keyBindScreenshot.getKeyCode())
-                    {
-                        this.ingameGUI.getChatGUI().printChatMessage(ScreenShotHelper.saveScreenshot(this.mcDataDir, this.displayWidth, this.displayHeight, this.framebufferMc));
-                    }
-                }
-                else if (var1 == this.gameSettings.keyBindStreamToggleMic.getKeyCode())
-                {
-                    this.stream.func_152910_a(false);
-                }
-            }
-        }
-    }
-
-    public ListenableFuture addScheduledTask(Callable callableToSchedule)
-    {
-        Validate.notNull(callableToSchedule);
-
-        if (!this.isCallingFromMinecraftThread())
-        {
-            ListenableFutureTask var2 = ListenableFutureTask.create(callableToSchedule);
-            Queue var3 = this.scheduledTasks;
-
-            synchronized (this.scheduledTasks)
-            {
-                this.scheduledTasks.add(var2);
-                return var2;
-            }
-        }
-        else
-        {
-            try
-            {
-                return Futures.immediateFuture(callableToSchedule.call());
-            }
-            catch (Exception var6)
-            {
-                return Futures.immediateFailedCheckedFuture(var6);
-            }
-        }
-    }
-
-    public ListenableFuture addScheduledTask(Runnable runnableToSchedule)
-    {
-        Validate.notNull(runnableToSchedule);
-        return this.addScheduledTask(Executors.callable(runnableToSchedule));
-    }
-
-    public boolean isCallingFromMinecraftThread()
-    {
-        return Thread.currentThread() == this.mcThread;
-    }
-
-    public MinecraftSessionService getSessionService()
-    {
-        return this.sessionService;
-    }
-
-    public SkinManager getSkinManager()
-    {
-        return this.skinManager;
-    }
-
-    static final class SwitchMovingObjectType
-    {
-        static final int[] field_152390_a = new int[MovingObjectPosition.MovingObjectType.values().length];
-        private static final String __OBFID = "CL_00000638";
-
-        static
-        {
-            try
-            {
-                field_152390_a[MovingObjectPosition.MovingObjectType.ENTITY.ordinal()] = 1;
-            }
-            catch (NoSuchFieldError var2)
-            {
-                ;
-            }
-
-            try
-            {
-                field_152390_a[MovingObjectPosition.MovingObjectType.BLOCK.ordinal()] = 2;
-            }
-            catch (NoSuchFieldError var1)
-            {
-                ;
-            }
-        }
-    }
+        }*/
+		/** END MINECRIFT */
+	}
+
+	/**
+	 * Runs the current tick.
+	 */
+	public void runTick()
+	{
+		this.mcProfiler.startSection("scheduledExecutables");
+		Queue var1 = this.scheduledTasks;
+
+		synchronized (this.scheduledTasks)
+		{
+			while (!this.scheduledTasks.isEmpty())
+			{
+				((FutureTask)this.scheduledTasks.poll()).run();
+			}
+		}
+
+		this.mcProfiler.endSection();
+
+		if (this.rightClickDelayTimer > 0)
+		{
+			--this.rightClickDelayTimer;
+		}
+		/** MINECRIFT FORGE **/
+		Object fmlCommonHandler = null;
+		if( Reflector.FMLCommonHandler_instance.exists()) {
+			fmlCommonHandler = Reflector.call( Reflector.FMLCommonHandler_instance, new Object[0]);
+		}
+		if( fmlCommonHandler != null) {
+			Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPreClientTick, new Object[0]);
+		}
+		/** END MINECRIFT FORGE **/
+
+		this.mcProfiler.startSection("gui");
+
+		if (!this.isGamePaused)
+		{
+			/** MINECRIFT */
+			//            if( JoystickAim.selectedJoystickMode != null )
+			//                JoystickAim.selectedJoystickMode.updateTick();
+			/** END MINECRIFT */
+			this.ingameGUI.updateTick();
+		}
+
+		this.mcProfiler.endStartSection("pick");
+		this.entityRenderer.getMouseOver(1.0F);
+		this.mcProfiler.endStartSection("gameMode");
+
+		if (!this.isGamePaused && this.theWorld != null)
+		{
+			this.playerController.updateController();
+		}
+
+		this.mcProfiler.endStartSection("textures");
+
+		if (!this.isGamePaused)
+		{
+			this.renderEngine.tick();
+		}
+
+		if (this.currentScreen == null && this.thePlayer != null)
+		{
+			/** MINECRIFT */
+			this.thePlayer.stepHeight = this.vrSettings.walkUpBlocks ? 1f : 0.5f;
+			if (!vrPlayer.getFreeMoveMode()) this.thePlayer.stepHeight = 0.0f;
+			/** END MINECRIFT */
+
+			if (this.thePlayer.getHealth() <= 0.0F)
+			{
+				this.displayGuiScreen((GuiScreen)null);
+			}
+			else if (this.thePlayer.isPlayerSleeping() && this.theWorld != null)
+			{
+				this.displayGuiScreen(new GuiSleepMP());
+			}
+		}
+		else if (this.currentScreen != null && this.currentScreen instanceof GuiSleepMP && !this.thePlayer.isPlayerSleeping())
+		{
+			this.displayGuiScreen((GuiScreen)null);
+		}
+
+		if (this.currentScreen != null)
+		{
+			this.leftClickCounter = 10000;
+		}
+
+		CrashReport var2;
+		CrashReportCategory var3;
+
+		if (this.currentScreen != null)
+		{
+			try
+			{
+				this.currentScreen.handleInput();
+			}
+			catch (Throwable var6)
+			{
+				var2 = CrashReport.makeCrashReport(var6, "Updating screen events");
+				var3 = var2.makeCategory("Affected screen");
+				var3.addCrashSectionCallable("Screen name", new Callable()
+				{
+					private static final String __OBFID = "CL_00000640";
+					public String call()
+					{
+						return Minecraft.this.currentScreen.getClass().getCanonicalName();
+					}
+				});
+				throw new ReportedException(var2);
+			}
+
+			if (this.currentScreen != null)
+			{
+				try
+				{
+					this.currentScreen.updateScreen();
+				}
+				catch (Throwable var5)
+				{
+					var2 = CrashReport.makeCrashReport(var5, "Ticking screen");
+					var3 = var2.makeCategory("Affected screen");
+					var3.addCrashSectionCallable("Screen name", new Callable()
+					{
+						private static final String __OBFID = "CL_00000642";
+						public String call()
+						{
+							return Minecraft.this.currentScreen.getClass().getCanonicalName();
+						}
+					});
+					throw new ReportedException(var2);
+				}
+			}
+		}
+
+		if (this.currentScreen == null || this.currentScreen.allowUserInput)
+		{
+			int var9;
+			doMouseInput(fmlCommonHandler);
+
+			doKeyboardInput(fmlCommonHandler);
+
+		}
+		/** MINECRIFT */
+		else
+		{
+			VRHotkeys.handleKeyboardInputs(this);
+		}
+		/** END MINECRIFT */
+
+		if (this.theWorld != null)
+		{
+			if (this.thePlayer != null)
+			{
+				++this.joinPlayerCounter;
+
+				if (this.joinPlayerCounter == 30)
+				{
+					this.joinPlayerCounter = 0;
+					this.theWorld.joinEntityInSurroundings(this.thePlayer);
+				}
+			}
+
+			this.mcProfiler.endStartSection("gameRenderer");
+
+			if (!this.isGamePaused)
+			{
+				this.entityRenderer.updateRenderer();
+			}
+
+			this.mcProfiler.endStartSection("levelRenderer");
+
+			if (!this.isGamePaused)
+			{
+				this.renderGlobal.updateClouds();
+			}
+
+			this.mcProfiler.endStartSection("level");
+
+			if (!this.isGamePaused)
+			{
+				if (this.theWorld.lastLightningBolt > 0)
+				{
+					--this.theWorld.lastLightningBolt;
+				}
+
+				this.theWorld.updateEntities();
+			}
+		}
+
+		if (!this.isGamePaused)
+		{
+			this.mcMusicTicker.update();
+			this.mcSoundHandler.update();
+		}
+
+		if (this.theWorld != null)
+		{
+			if (!this.isGamePaused)
+			{
+				this.theWorld.setAllowedSpawnTypes(this.theWorld.difficultySetting != EnumDifficulty.PEACEFUL, true);
+
+				try
+				{
+					this.theWorld.tick();
+				}
+				catch (Throwable var7)
+				{
+					var2 = CrashReport.makeCrashReport(var7, "Exception in world tick");
+
+					if (this.theWorld == null)
+					{
+						var3 = var2.makeCategory("Affected level");
+						var3.addCrashSection("Problem", "Level is null!");
+					}
+					else
+					{
+						this.theWorld.addWorldInfoToCrashReport(var2);
+					}
+
+					throw new ReportedException(var2);
+				}
+			}
+
+			this.mcProfiler.endStartSection("animateTick");
+
+			if (!this.isGamePaused && this.theWorld != null)
+			{
+				this.theWorld.doVoidFogParticles(MathHelper.floor_double(this.thePlayer.posX), MathHelper.floor_double(this.thePlayer.posY), MathHelper.floor_double(this.thePlayer.posZ));
+			}
+
+			this.mcProfiler.endStartSection("particles");
+
+			if (!this.isGamePaused)
+			{
+				this.effectRenderer.updateEffects();
+			}
+		}
+		else if (this.myNetworkManager != null)
+		{
+			this.mcProfiler.endStartSection("pendingConnection");
+			this.myNetworkManager.processReceivedPackets();
+		}
+		/** MINECRIFT FORGE **/
+		if( fmlCommonHandler != null) {
+			Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPostClientTick, new Object[0]);
+		}
+		/** END MINECRIFT FORGE **/
+		this.mcProfiler.endSection();
+		this.systemTime = getSystemTime();
+	}
+
+	private void doKeyboardInput(Object fmlCommonHandler) {
+		int var9;
+		this.mcProfiler.endStartSection("keyboard");
+		boolean var10;
+
+		while (Keyboard.next())
+		{
+   			KeyBinding.setKeyBindState(Keyboard.getEventKey(), Keyboard.getEventKeyState());
+			
+			if (Keyboard.getEventKeyState())
+			{
+				dropCounter++;
+				KeyBinding.onTick(Keyboard.getEventKey());
+			}
+
+			if (this.debugCrashKeyPressTime > 0L)
+			{
+				if (getSystemTime() - this.debugCrashKeyPressTime >= 6000L)
+				{
+					throw new ReportedException(new CrashReport("Manually triggered debug crash", new Throwable()));
+				}
+
+				if (!Keyboard.isKeyDown(46) || !Keyboard.isKeyDown(61))
+				{
+					this.debugCrashKeyPressTime = -1L;
+				}
+			}
+			else if (Keyboard.isKeyDown(46) && Keyboard.isKeyDown(61))
+			{
+				this.debugCrashKeyPressTime = getSystemTime();
+			}
+
+			this.dispatchKeypresses();
+
+			if (Keyboard.getEventKeyState())
+			{
+				if (Keyboard.getEventKey() == 62 && this.entityRenderer != null)
+				{
+					this.entityRenderer.deactivateShader();
+				}
+
+				if (this.currentScreen != null)
+				{
+					this.currentScreen.handleKeyboardInput();
+				}
+				else
+				{
+					/** MINECRIFT */
+					VRHotkeys.handleKeyboardInputs(this);
+					/** END MINECRIFT */
+
+					if (Keyboard.getEventKey() == 1)
+					{
+						this.displayInGameMenu();
+					}
+
+					if (Keyboard.getEventKey() == 31 && Keyboard.isKeyDown(61))
+					{
+						this.refreshResources();
+					}
+
+					if (Keyboard.getEventKey() == 20 && Keyboard.isKeyDown(61))
+					{
+						this.refreshResources();
+					}
+
+					if (Keyboard.getEventKey() == 33 && Keyboard.isKeyDown(61))
+					{
+						var10 = Keyboard.isKeyDown(42) | Keyboard.isKeyDown(54);
+						this.gameSettings.setOptionValue(GameSettings.Options.RENDER_DISTANCE, var10 ? -1 : 1);
+					}
+
+					if (Keyboard.getEventKey() == 30 && Keyboard.isKeyDown(61))
+					{
+						this.renderGlobal.loadRenderers();
+					}
+
+					if (Keyboard.getEventKey() == 35 && Keyboard.isKeyDown(61))
+					{
+						this.gameSettings.advancedItemTooltips = !this.gameSettings.advancedItemTooltips;
+						this.gameSettings.saveOptions();
+					}
+
+					if (Keyboard.getEventKey() == 48 && Keyboard.isKeyDown(61))
+					{
+						RenderManager.debugBoundingBox = !RenderManager.debugBoundingBox;
+					}
+
+					if (Keyboard.getEventKey() == 25 && Keyboard.isKeyDown(61))
+					{
+						this.gameSettings.pauseOnLostFocus = !this.gameSettings.pauseOnLostFocus;
+						this.gameSettings.saveOptions();
+					}
+
+					/** MINECRIFT **/
+					if (Keyboard.getEventKey() == 59)
+					{
+						this.vrSettings.hideGui = !this.vrSettings.hideGui;
+					}
+					/** END MINECRIFT **/
+
+					if (Keyboard.getEventKey() == 61)
+					{
+						this.gameSettings.showDebugInfo = !this.gameSettings.showDebugInfo;
+						this.gameSettings.showDebugProfilerChart = GuiScreen.isShiftKeyDown();
+					}
+
+					if (this.gameSettings.keyBindTogglePerspective.isPressed())
+					{
+						++this.gameSettings.thirdPersonView;
+
+						if (this.gameSettings.thirdPersonView > 2)
+						{
+							this.gameSettings.thirdPersonView = 0;
+						}
+					}
+
+					if (this.gameSettings.keyBindSmoothCamera.isPressed())
+					{
+						this.gameSettings.smoothCamera = !this.gameSettings.smoothCamera;
+					}
+				}
+
+				if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)
+				{
+					if (Keyboard.getEventKey() == 11)
+					{
+						this.updateDebugProfilerName(0);
+					}
+
+					for (var9 = 0; var9 < 9; ++var9)
+					{
+						if (Keyboard.getEventKey() == 2 + var9)
+						{
+							this.updateDebugProfilerName(var9 + 1);
+						}
+					}
+				}
+			}
+			/** MINECRIFT FORGE **/
+			if( fmlCommonHandler != null) {
+				Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_fireKeyInput, new Object[0]);
+			}
+			/** END MINECRIFT FORGE **/
+		}
+
+		for (var9 = 0; var9 < 9; ++var9)
+		{
+			if (this.gameSettings.keyBindsHotbar[var9].isPressed())
+			{
+				this.thePlayer.inventory.currentItem = var9;
+			}
+		}
+
+		var10 = this.gameSettings.chatVisibility != EntityPlayer.EnumChatVisibility.HIDDEN;
+
+		while (this.gameSettings.keyBindInventory.isPressed())
+		{
+			if (this.playerController.isRidingHorse())
+			{
+				this.thePlayer.sendHorseInteraction();
+			}
+			else
+			{
+				this.getNetHandler().addToSendQueue(new C16PacketClientStatus(C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT));
+				
+				if(this.lookaimController instanceof MCOpenVR){
+					((MCOpenVR) this.lookaimController).startedOpeningInventory = getCurrentTimeSecs();	//prevent immediately closing it
+				}
+				
+				this.displayGuiScreen(new GuiInventory(this.thePlayer));
+			}
+		}
+
+		while (this.gameSettings.keyBindDrop.isPressed())
+		{
+			this.thePlayer.dropOneItem(GuiScreen.isCtrlKeyDown());		
+		}
+
+		while (this.gameSettings.keyBindChat.isPressed() && var10)
+		{
+			this.displayGuiScreen(new GuiChat());
+		}
+
+		if (this.currentScreen == null && this.gameSettings.keyBindCommand.isPressed() && var10)
+		{
+			this.displayGuiScreen(new GuiChat("/"));
+		}
+
+		if (this.thePlayer.isUsingItem())
+		{
+			if (!this.gameSettings.keyBindUseItem.getIsKeyPressed() && bowTracker.isActive(thePlayer) == false)
+			{
+				this.playerController.onStoppedUsingItem(this.thePlayer);
+			}
+
+			label391:
+
+				while (true)
+				{
+					if (!this.gameSettings.keyBindAttack.isPressed())
+					{
+						while (this.gameSettings.keyBindUseItem.isPressed())
+						{
+							;
+						}
+
+						while (true)
+						{
+							if (this.gameSettings.keyBindPickBlock.isPressed())
+							{
+								continue;
+							}
+
+							break label391;
+						}
+					}
+				}
+		}
+		else
+		{
+			if (this.gameSettings.keyBindAttack.getIsKeyPressed())
+			{
+				this.clickMouse();
+				lastClick = true;
+
+			} else {
+				this.leftClickCounter = 0;
+				if (lastClick)
+				{
+					this.playerController.resetBlockRemoving();
+				}
+				lastClick = false;
+			}
+
+			if (this.gameSettings.keyBindUseItem.getIsKeyPressed())
+			{
+				this.rightClickMouse();
+			} else {this.rightClickDelayTimer = 0;}
+
+			
+			//JRBUDDA MODE SWITCH CODE
+			if (this.gameSettings.keyBindPickBlock.getIsKeyPressed())
+			{
+				this.middleClickMouse();
+				
+				moveModeSwitchcount++;
+				if (moveModeSwitchcount >= 40 * 4) {
+					moveModeSwitchcount = 0;
+					vrPlayer.setFreeMoveMode(!vrPlayer.getFreeMoveMode());
+					printChatMessage("Free movement mode set to: " + vrPlayer.getFreeMoveMode());
+				
+			} else  moveModeSwitchcount = 0;
+				
+			}
+			/////		
+		}
+	}
+
+	private void doMouseInput(Object fmlCommonHandler) {
+		this.mcProfiler.endStartSection("mouse");
+		int var9;
+
+		while (Mouse.next())
+		{
+			/** MINECRIFT FORGE **/
+			if (Reflector.ForgeHooksClient_postMouseEvent.exists()) {
+				if (Reflector.callBoolean(Reflector.ForgeHooksClient_postMouseEvent, new Object[0])) continue;
+			}
+			/** END MINECRIFT FORGE **/
+
+			var9 = Mouse.getEventButton();
+			KeyBinding.setKeyBindState(var9 - 100, Mouse.getEventButtonState());
+
+			if (Mouse.getEventButtonState())
+			{
+				dropCounter++;
+				KeyBinding.onTick(var9 - 100);
+			}
+			
+			if (lookaimController instanceof MCOpenVR){
+				if(!((MCOpenVR)lookaimController).controllerMouseValid){
+					if (mouseHelper.deltaX > 0 || mouseHelper.deltaY> 0 )
+						((MCOpenVR) lookaimController).controllerMouseValid = true;
+					}
+				}
+				
+			long var11 = getSystemTime() - this.systemTime;
+
+			if (var11 <= 200L)
+			{
+				int var4 = Mouse.getEventDWheel();
+
+				if (var4 != 0)
+				{
+					/** MINECRIFT **/
+					if (Minecraft.getMinecraft().vrSettings.isComfortYawTransitionKeyAllowed()) {
+						this.triggerYawTransition(var4 > 0 ? false : true);
+					}
+					else {
+						this.thePlayer.inventory.changeCurrentItem(var4);
+
+						if (this.gameSettings.noclip)
+						{
+							if (var4 > 0)
+							{
+								var4 = 1;
+							}
+
+							if (var4 < 0)
+							{
+								var4 = -1;
+							}
+
+							this.gameSettings.noclipRate += (float)var4 * 0.25F;
+						}
+					}
+					/** END MINECRIFT **/
+				}
+
+				if (this.currentScreen == null)
+				{
+					if (!this.inGameHasFocus && Mouse.getEventButtonState())
+					{
+						this.setIngameFocus();
+					}
+				}
+				else if (this.currentScreen != null)
+				{
+					this.currentScreen.handleMouseInput();
+				}
+			}
+			/** MINECRIFT FORGE **/
+			if( fmlCommonHandler != null) {
+				Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_fireMouseInput, new Object[0]);
+			}
+			/** END MINECRIFT FORGE **/
+		}
+
+		if (this.leftClickCounter > 0)
+		{
+			--this.leftClickCounter;
+		}
+	}
+
+	/**
+	 * Arguments: World foldername,  World ingame name, WorldSettings
+	 */
+	public void launchIntegratedServer(String folderName, String worldName, WorldSettings worldSettingsIn)
+	{
+		/** MINECRIFT FORGE **/
+		Object fmlClientHandler = null;
+		if( Reflector.FMLClientHandler_instance.exists()) {
+			fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+		}
+		if( fmlClientHandler != null) {
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_startIntegratedServer, new Object[] {folderName, worldName, worldSettingsIn});
+		}
+		/** END MINECRIFT FORGE **/
+		this.loadWorld((WorldClient)null);
+		System.gc();
+		ISaveHandler var4 = this.saveLoader.getSaveLoader(folderName, false);
+		WorldInfo var5 = var4.loadWorldInfo();
+
+		if (var5 == null && worldSettingsIn != null)
+		{
+			var5 = new WorldInfo(worldSettingsIn, folderName);
+			var4.saveWorldInfo(var5);
+		}
+
+		if (worldSettingsIn == null)
+		{
+			worldSettingsIn = new WorldSettings(var5);
+		}
+
+		try
+		{
+			this.theIntegratedServer = new IntegratedServer(this, folderName, worldName, worldSettingsIn);
+			this.theIntegratedServer.startServerThread();
+			this.integratedServerIsRunning = true;
+		}
+		catch (Throwable var10)
+		{
+			CrashReport var7 = CrashReport.makeCrashReport(var10, "Starting integrated server");
+			CrashReportCategory var8 = var7.makeCategory("Starting integrated server");
+			var8.addCrashSection("Level ID", folderName);
+			var8.addCrashSection("Level Name", worldName);
+			throw new ReportedException(var7);
+		}
+
+		this.loadingScreen.displaySavingString(I18n.format("menu.loadingLevel", new Object[0]));
+
+		/** MINECRIFT */
+		// Exit now. Server launch progress will be checked periodically.
+		this.lastIntegratedServerLaunchCheck = System.currentTimeMillis();
+		this.integratedServerLaunchInProgress = true;
+	}
+
+	public boolean isIntegratedServerLaunching()
+	{
+		if (!this.integratedServerLaunchInProgress)
+			return false;
+
+		if (!this.theIntegratedServer.serverIsInRunLoop())
+		{
+			long currentTime = System.currentTimeMillis();
+
+			if (currentTime - lastIntegratedServerLaunchCheck > 200L)
+			{
+				this.lastIntegratedServerLaunchCheck = currentTime;
+				/** MINECRIFT FORGE **/
+				if (Reflector.FMLStartupQuery_check.exists())
+				{
+					if (!Reflector.callBoolean(Reflector.FMLStartupQuery_check, new Object[0]))
+					{
+						loadWorld(null);
+						displayGuiScreen(null);
+						this.lastIntegratedServerLaunchCheck = 0;
+						this.integratedServerLaunchInProgress = false;
+						return false;
+					}
+				}
+				/** END MINECRIFT FORGE **/
+
+				String var6 = this.theIntegratedServer.getUserMessage();
+
+				if (var6 != null)
+				{
+					this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
+				}
+				else
+				{
+					this.loadingScreen.displayLoadingString("");
+				}
+
+				// Wait & loop not used
+				//try
+				//{
+				//    Thread.sleep(200L);
+				//}
+				//catch (InterruptedException interruptedexception)
+				//{
+				//    ;
+				//}
+			}
+
+			return true;
+		}
+		else
+		{
+			this.lastIntegratedServerLaunchCheck = 0;
+			this.integratedServerLaunchInProgress = false;
+
+			// Ideally the network stuff below would also be part of the integrated server
+			// launch, i.e. on it's own thread
+			this.displayGuiScreen((GuiScreen) null);
+			SocketAddress var11 = this.theIntegratedServer.getNetworkSystem().addLocalEndpoint();
+			NetworkManager var12 = NetworkManager.provideLocalClient(var11);
+			var12.setNetHandler(new NetHandlerLoginClient(var12, this, (GuiScreen)null));
+			var12.scheduleOutboundPacket(new C00Handshake(5, var11.toString(), 0, EnumConnectionState.LOGIN), new GenericFutureListener[0]);
+			var12.scheduleOutboundPacket(new C00PacketLoginStart(this.getSession().getProfile()), new GenericFutureListener[0]);
+			this.myNetworkManager = var12;
+
+			return false;
+		}
+	}
+	/** END MINECRIFT */
+
+	/**
+	 * unloads the current world first
+	 */
+	public void loadWorld(WorldClient worldClientIn)
+	{
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0);
+		// VIVE END - reset room origin
+		this.loadWorld(worldClientIn, "");
+	}
+
+	/**
+	 * par2Str is displayed on the loading screen to the user unloads the current world first
+	 */
+	public void loadWorld(WorldClient worldClientIn, String loadingMessage)
+	{
+		/** MINECRIFT FORGE **/
+		if (worldClientIn != null && Reflector.EventBus.exists())
+		{
+			Reflector.postForgeBusEvent(Reflector.ForgeWorldEvent_Unload_Constructor, new Object[] {this.theWorld});
+		}
+		/** END MINECRIFT FORGE **/
+
+		if (worldClientIn == null)
+		{
+			NetHandlerPlayClient var3 = this.getNetHandler();
+
+			if (var3 != null)
+			{
+				var3.cleanup();
+			}
+
+			if (this.theIntegratedServer != null)
+			{
+				this.theIntegratedServer.initiateShutdown();
+				/** MINECRIFT FORGE **/
+				if (Reflector.ForgeIntegratedServer_isServerStopped.exists())
+				{
+					if (loadingScreen != null)
+					{
+						this.loadingScreen.resetProgressAndMessage(I18n.format("forge.client.shutdown.internal"));
+					}
+					while (!Reflector.callBoolean(Reflector.ForgeIntegratedServer_isServerStopped, new Object[0]))
+					{
+						try
+						{
+							Thread.sleep(10);
+						}
+						catch (InterruptedException ie) {}
+					}				
+				}
+				/** END MINECRIFT FORGE **/
+			}
+
+			this.theIntegratedServer = null;
+			this.guiAchievement.clearAchievements();
+			this.entityRenderer.getMapItemRenderer().func_148249_a();
+		}
+
+		this.renderViewEntity = null;
+		this.myNetworkManager = null;
+
+		if (this.loadingScreen != null)
+		{
+			this.loadingScreen.resetProgressAndMessage(loadingMessage);
+			this.loadingScreen.displayLoadingString("");
+		}
+
+		if (worldClientIn == null && this.theWorld != null)
+		{
+			if (this.mcResourcePackRepository.getResourcePackInstance() != null)
+			{
+				this.scheduleResourcesRefresh();
+			}
+
+			this.mcResourcePackRepository.func_148529_f();
+			this.setServerData((ServerData)null);
+			this.integratedServerIsRunning = false;
+			/** MINECRIFT FORGE **/
+			Object fmlClientHandler = null;
+			if( Reflector.FMLClientHandler_instance.exists()) {
+				fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+			}
+			if( fmlClientHandler != null) {
+				Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_handleClientWorldClosing, new Object[]{this.theWorld});
+			}
+			/** END MINECRIFT FORGE **/
+		}
+
+		this.mcSoundHandler.stopSounds();
+		this.theWorld = worldClientIn;
+
+		if (worldClientIn != null)
+		{
+			if (this.renderGlobal != null)
+			{
+				this.renderGlobal.setWorldAndLoadRenderers(worldClientIn);
+			}
+
+			if (this.effectRenderer != null)
+			{
+				this.effectRenderer.clearEffects(worldClientIn);
+			}
+
+			if (this.thePlayer == null)
+			{
+				this.thePlayer = this.playerController.createPlayer(worldClientIn, new StatFileWriter());
+				this.playerController.flipPlayer(this.thePlayer);
+			}
+
+			this.thePlayer.preparePlayerToSpawn();
+			worldClientIn.spawnEntityInWorld(this.thePlayer);
+			this.thePlayer.movementInput = new MovementInputFromOptions(this.gameSettings);
+			this.playerController.setPlayerCapabilities(this.thePlayer);
+			this.renderViewEntity = this.thePlayer;
+		}
+		else
+		{
+			this.saveLoader.flushCache();
+			this.thePlayer = null;
+		}
+
+		System.gc();
+		this.systemTime = 0L;
+	}
+
+	/**
+	 * A String of renderGlobal.getDebugInfoRenders
+	 */
+	public String debugInfoRenders()
+	{
+		return this.renderGlobal.getDebugInfoRenders();
+	}
+
+	/**
+	 * Gets the information in the F3 menu about how many entities are infront/around you
+	 */
+	public String getEntityDebug()
+	{
+		return this.renderGlobal.getDebugInfoEntities();
+	}
+
+	/**
+	 * Gets the name of the world's current chunk provider
+	 */
+	public String getWorldProviderName()
+	{
+		return this.theWorld.getProviderName();
+	}
+
+	/**
+	 * A String of how many entities are in the world
+	 */
+	public String debugInfoEntities()
+	{
+		return "P: " + this.effectRenderer.getStatistics() + ". T: " + this.theWorld.getDebugLoadedEntities();
+	}
+
+	public void setDimensionAndSpawnPlayer(int dimension)
+	{
+		this.theWorld.setSpawnLocation();
+		this.theWorld.removeAllEntities();
+		int var2 = 0;
+		String var3 = null;
+
+		if (this.thePlayer != null)
+		{
+			var2 = this.thePlayer.getEntityId();
+			this.theWorld.removeEntity(this.thePlayer);
+			var3 = this.thePlayer.getClientBrand();
+		}
+
+		this.renderViewEntity = null;
+		this.thePlayer = this.playerController.createPlayer(this.theWorld, this.thePlayer == null ? new StatFileWriter() : this.thePlayer.getStatFileWriter());
+		this.thePlayer.dimension = dimension;
+		this.renderViewEntity = this.thePlayer;
+		this.thePlayer.preparePlayerToSpawn();
+		this.thePlayer.setClientBrand(var3);
+		this.theWorld.spawnEntityInWorld(this.thePlayer);
+		this.playerController.flipPlayer(this.thePlayer);
+		this.thePlayer.movementInput = new MovementInputFromOptions(this.gameSettings);
+		this.thePlayer.setEntityId(var2);
+		this.playerController.setPlayerCapabilities(this.thePlayer);
+
+		if (this.currentScreen instanceof GuiGameOver)
+		{
+			this.displayGuiScreen((GuiScreen)null);
+		}
+	}
+
+	/**
+	 * Gets whether this is a demo or not.
+	 */
+	public final boolean isDemo()
+	{
+		return this.isDemo;
+	}
+
+	public NetHandlerPlayClient getNetHandler()
+	{
+		return this.thePlayer != null ? this.thePlayer.sendQueue : null;
+	}
+
+	/** MINECRIFT **/
+	public static boolean isGuiEnabled()
+	{
+		return theMinecraft == null || !theMinecraft.vrSettings.hideGui;
+	}
+	/** END MINECRIFT **/
+
+	public static boolean isFancyGraphicsEnabled()
+	{
+		return theMinecraft != null && theMinecraft.gameSettings.fancyGraphics;
+	}
+
+	/**
+	 * Returns if ambient occlusion is enabled
+	 */
+	public static boolean isAmbientOcclusionEnabled()
+	{
+		return theMinecraft != null && theMinecraft.gameSettings.ambientOcclusion != 0;
+	}
+
+	/**
+	 * Called when user clicked he's mouse middle button (pick block)
+	 */
+	/* JRBUDDA*/
+	public void middleClickMouse()
+	/* /JRBUDDA */
+	{
+		if (this.objectMouseOver != null)
+		{
+			boolean var1 = this.thePlayer.capabilities.isCreativeMode;
+			int var3 = 0;
+			boolean var4 = false;
+			Item var2;
+			int var5;
+
+			/** MINECRIFT FORGE **/
+			if (!Reflector.ForgeHooks_onPickBlock.exists())
+			{
+				if (this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
+				{
+					var5 = this.objectMouseOver.blockX;
+					int var6 = this.objectMouseOver.blockY;
+					int var7 = this.objectMouseOver.blockZ;
+					Block var8 = this.theWorld.getBlock(var5, var6, var7);
+
+					if (var8.getMaterial() == Material.air)
+					{
+						return;
+					}
+
+					var2 = var8.getItem(this.theWorld, var5, var6, var7);
+
+					if (var2 == null)
+					{
+						return;
+					}
+
+					var4 = var2.getHasSubtypes();
+					Block var9 = var2 instanceof ItemBlock && !var8.isFlowerPot() ? Block.getBlockFromItem(var2) : var8;
+					var3 = var9.getDamageValue(this.theWorld, var5, var6, var7);
+				}
+				else
+				{
+					if (this.objectMouseOver.typeOfHit != MovingObjectPosition.MovingObjectType.ENTITY || this.objectMouseOver.entityHit == null || !var1)
+					{
+						return;
+					}
+
+					if (this.objectMouseOver.entityHit instanceof EntityPainting)
+					{
+						var2 = Items.painting;
+					}
+					else if (this.objectMouseOver.entityHit instanceof EntityLeashKnot)
+					{
+						var2 = Items.lead;
+					}
+					else if (this.objectMouseOver.entityHit instanceof EntityItemFrame)
+					{
+						EntityItemFrame var10 = (EntityItemFrame)this.objectMouseOver.entityHit;
+						ItemStack var12 = var10.getDisplayedItem();
+
+						if (var12 == null)
+						{
+							var2 = Items.item_frame;
+						}
+						else
+						{
+							var2 = var12.getItem();
+							var3 = var12.getMetadata();
+							var4 = true;
+						}
+					}
+					else if (this.objectMouseOver.entityHit instanceof EntityMinecart)
+					{
+						EntityMinecart var11 = (EntityMinecart)this.objectMouseOver.entityHit;
+
+						if (var11.getMinecartType() == 2)
+						{
+							var2 = Items.furnace_minecart;
+						}
+						else if (var11.getMinecartType() == 1)
+						{
+							var2 = Items.chest_minecart;
+						}
+						else if (var11.getMinecartType() == 3)
+						{
+							var2 = Items.tnt_minecart;
+						}
+						else if (var11.getMinecartType() == 5)
+						{
+							var2 = Items.hopper_minecart;
+						}
+						else if (var11.getMinecartType() == 6)
+						{
+							var2 = Items.command_block_minecart;
+						}
+						else
+						{
+							var2 = Items.minecart;
+						}
+					}
+					else if (this.objectMouseOver.entityHit instanceof EntityBoat)
+					{
+						var2 = Items.boat;
+					}
+					else
+					{
+						var2 = Items.spawn_egg;
+						var3 = EntityList.getEntityID(this.objectMouseOver.entityHit);
+						var4 = true;
+
+						if (var3 <= 0 || !EntityList.entityEggs.containsKey(Integer.valueOf(var3)))
+						{
+							return;
+						}
+					}
+				}
+
+				this.thePlayer.inventory.setCurrentItem(var2, var3, var4, var1);
+			}
+			else if (!Reflector.callBoolean(Reflector.ForgeHooks_onPickBlock, new Object[]{this.objectMouseOver,this.thePlayer,this.theWorld}))
+			{
+				// We delete this code wholly instead of commenting it out, to make sure we detect changes in it between MC versions
+				return;
+			}
+			/** END MINECRIFT FORGE **/
+
+			if (var1)
+			{
+				var5 = this.thePlayer.inventoryContainer.inventorySlots.size() - 9 + this.thePlayer.inventory.currentItem;
+				this.playerController.sendSlotPacket(this.thePlayer.inventory.getStackInSlot(this.thePlayer.inventory.currentItem), var5);
+			}
+		}
+	}
+
+	/**
+	 * adds core server Info (GL version , Texture pack, isModded, type), and the worldInfo to the crash report
+	 */
+	public CrashReport addGraphicsAndWorldToCrashReport(CrashReport theCrash)
+	{
+		theCrash.getCategory().addCrashSectionCallable("Launched Version", new Callable()
+		{
+			private static final String __OBFID = "CL_00000643";
+			public String call()
+			{
+				return Minecraft.this.launchedVersion;
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("LWJGL", new Callable()
+		{
+			private static final String __OBFID = "CL_00000644";
+			public String call()
+			{
+				return Sys.getVersion();
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("OpenGL", new Callable()
+		{
+			private static final String __OBFID = "CL_00000645";
+			public String call()
+			{
+				return GL11.glGetString(GL11.GL_RENDERER) + " GL version " + GL11.glGetString(GL11.GL_VERSION) + ", " + GL11.glGetString(GL11.GL_VENDOR);
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("GL Caps", new Callable()
+		{
+			private static final String __OBFID = "CL_00000646";
+			public String call()
+			{
+				return OpenGlHelper.func_153172_c();
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Is Modded", new Callable()
+		{
+			private static final String __OBFID = "CL_00000647";
+			public String call()
+			{
+				String var1 = ClientBrandRetriever.getClientModName();
+				return !var1.equals("vanilla") ? "Definitely; Client brand changed to \'" + var1 + "\'" : (Minecraft.class.getSigners() == null ? "Very likely; Jar signature invalidated" : "Probably not. Jar signature remains and client brand is untouched.");
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Type", new Callable()
+		{
+			private static final String __OBFID = "CL_00000633";
+			public String call()
+			{
+				return "Client (map_client.txt)";
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Resource Packs", new Callable()
+		{
+			private static final String __OBFID = "CL_00000634";
+			public String call()
+			{
+				return Minecraft.this.gameSettings.resourcePacks.toString();
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Current Language", new Callable()
+		{
+			private static final String __OBFID = "CL_00000635";
+			public String call()
+			{
+				return Minecraft.this.mcLanguageManager.getCurrentLanguage().toString();
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Profiler Position", new Callable()
+		{
+			private static final String __OBFID = "CL_00000636";
+			public String call()
+			{
+				return Minecraft.this.mcProfiler.profilingEnabled ? Minecraft.this.mcProfiler.getNameOfLastSection() : "N/A (disabled)";
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Vec3 Pool Size", new Callable()
+		{
+			private static final String __OBFID = "CL_00000637";
+			public String call()
+			{
+				byte var1 = 0;
+				int var2 = 56 * var1;
+				int var3 = var2 / 1024 / 1024;
+				byte var4 = 0;
+				int var5 = 56 * var4;
+				int var6 = var5 / 1024 / 1024;
+				return var1 + " (" + var2 + " bytes; " + var3 + " MB) allocated, " + var4 + " (" + var5 + " bytes; " + var6 + " MB) used";
+			}
+		});
+		theCrash.getCategory().addCrashSectionCallable("Anisotropic Filtering", new Callable()
+		{
+			private static final String __OBFID = "CL_00001853";
+			public String func_152388_a()
+			{
+				return Minecraft.this.gameSettings.anisotropicFiltering == 1 ? "Off (1)" : "On (" + Minecraft.this.gameSettings.anisotropicFiltering + ")";
+			}
+			public Object call()
+			{
+				return this.func_152388_a();
+			}
+		});
+
+		if (this.theWorld != null)
+		{
+			this.theWorld.addWorldInfoToCrashReport(theCrash);
+		}
+
+		return theCrash;
+	}
+
+	/**
+	 * Return the singleton Minecraft instance for the game
+	 */
+	public static Minecraft getMinecraft()
+	{
+		return theMinecraft;
+	}
+
+	public void scheduleResourcesRefresh()
+	{
+		this.refreshTexturePacksScheduled = true;
+	}
+
+	public void addServerStatsToSnooper(PlayerUsageSnooper playerSnooper)
+	{
+		playerSnooper.addClientStat("fps", Integer.valueOf(debugFPS));
+		playerSnooper.addClientStat("vsync_enabled", Boolean.valueOf(this.gameSettings.enableVsync));
+		playerSnooper.addClientStat("display_frequency", Integer.valueOf(Display.getDisplayMode().getFrequency()));
+		playerSnooper.addClientStat("display_type", this.fullscreen ? "fullscreen" : "windowed");
+		playerSnooper.addClientStat("run_time", Long.valueOf((MinecraftServer.getCurrentTimeMillis() - playerSnooper.getMinecraftStartTimeMillis()) / 60L * 1000L));
+		playerSnooper.addClientStat("resource_packs", Integer.valueOf(this.mcResourcePackRepository.getRepositoryEntries().size()));
+		int var2 = 0;
+		Iterator var3 = this.mcResourcePackRepository.getRepositoryEntries().iterator();
+
+		while (var3.hasNext())
+		{
+			ResourcePackRepository.Entry var4 = (ResourcePackRepository.Entry)var3.next();
+			playerSnooper.addClientStat("resource_pack[" + var2++ + "]", var4.getResourcePackName());
+		}
+
+		if (this.theIntegratedServer != null && this.theIntegratedServer.getPlayerUsageSnooper() != null)
+		{
+			playerSnooper.addClientStat("snooper_partner", this.theIntegratedServer.getPlayerUsageSnooper().getUniqueID());
+		}
+	}
+
+	public void addServerTypeToSnooper(PlayerUsageSnooper playerSnooper)
+	{
+		playerSnooper.addStatToSnooper("opengl_version", GL11.glGetString(GL11.GL_VERSION));
+		playerSnooper.addStatToSnooper("opengl_vendor", GL11.glGetString(GL11.GL_VENDOR));
+		playerSnooper.addStatToSnooper("client_brand", ClientBrandRetriever.getClientModName());
+		playerSnooper.addStatToSnooper("launched_version", this.launchedVersion);
+		ContextCapabilities var2 = GLContext.getCapabilities();
+		playerSnooper.addStatToSnooper("gl_caps[ARB_arrays_of_arrays]", Boolean.valueOf(var2.GL_ARB_arrays_of_arrays));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_base_instance]", Boolean.valueOf(var2.GL_ARB_base_instance));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_blend_func_extended]", Boolean.valueOf(var2.GL_ARB_blend_func_extended));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_clear_buffer_object]", Boolean.valueOf(var2.GL_ARB_clear_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_color_buffer_float]", Boolean.valueOf(var2.GL_ARB_color_buffer_float));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_compatibility]", Boolean.valueOf(var2.GL_ARB_compatibility));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_compressed_texture_pixel_storage]", Boolean.valueOf(var2.GL_ARB_compressed_texture_pixel_storage));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_compute_shader]", Boolean.valueOf(var2.GL_ARB_compute_shader));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_copy_buffer]", Boolean.valueOf(var2.GL_ARB_copy_buffer));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_copy_image]", Boolean.valueOf(var2.GL_ARB_copy_image));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_depth_buffer_float]", Boolean.valueOf(var2.GL_ARB_depth_buffer_float));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_compute_shader]", Boolean.valueOf(var2.GL_ARB_compute_shader));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_copy_buffer]", Boolean.valueOf(var2.GL_ARB_copy_buffer));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_copy_image]", Boolean.valueOf(var2.GL_ARB_copy_image));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_depth_buffer_float]", Boolean.valueOf(var2.GL_ARB_depth_buffer_float));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_depth_clamp]", Boolean.valueOf(var2.GL_ARB_depth_clamp));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_depth_texture]", Boolean.valueOf(var2.GL_ARB_depth_texture));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_draw_buffers]", Boolean.valueOf(var2.GL_ARB_draw_buffers));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_draw_buffers_blend]", Boolean.valueOf(var2.GL_ARB_draw_buffers_blend));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_draw_elements_base_vertex]", Boolean.valueOf(var2.GL_ARB_draw_elements_base_vertex));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_draw_indirect]", Boolean.valueOf(var2.GL_ARB_draw_indirect));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_draw_instanced]", Boolean.valueOf(var2.GL_ARB_draw_instanced));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_explicit_attrib_location]", Boolean.valueOf(var2.GL_ARB_explicit_attrib_location));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_explicit_uniform_location]", Boolean.valueOf(var2.GL_ARB_explicit_uniform_location));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_layer_viewport]", Boolean.valueOf(var2.GL_ARB_fragment_layer_viewport));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_program]", Boolean.valueOf(var2.GL_ARB_fragment_program));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_shader]", Boolean.valueOf(var2.GL_ARB_fragment_shader));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_fragment_program_shadow]", Boolean.valueOf(var2.GL_ARB_fragment_program_shadow));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_framebuffer_object]", Boolean.valueOf(var2.GL_ARB_framebuffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_framebuffer_sRGB]", Boolean.valueOf(var2.GL_ARB_framebuffer_sRGB));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_geometry_shader4]", Boolean.valueOf(var2.GL_ARB_geometry_shader4));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_gpu_shader5]", Boolean.valueOf(var2.GL_ARB_gpu_shader5));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_half_float_pixel]", Boolean.valueOf(var2.GL_ARB_half_float_pixel));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_half_float_vertex]", Boolean.valueOf(var2.GL_ARB_half_float_vertex));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_instanced_arrays]", Boolean.valueOf(var2.GL_ARB_instanced_arrays));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_map_buffer_alignment]", Boolean.valueOf(var2.GL_ARB_map_buffer_alignment));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_map_buffer_range]", Boolean.valueOf(var2.GL_ARB_map_buffer_range));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_multisample]", Boolean.valueOf(var2.GL_ARB_multisample));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_multitexture]", Boolean.valueOf(var2.GL_ARB_multitexture));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_occlusion_query2]", Boolean.valueOf(var2.GL_ARB_occlusion_query2));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_pixel_buffer_object]", Boolean.valueOf(var2.GL_ARB_pixel_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_seamless_cube_map]", Boolean.valueOf(var2.GL_ARB_seamless_cube_map));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_shader_objects]", Boolean.valueOf(var2.GL_ARB_shader_objects));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_shader_stencil_export]", Boolean.valueOf(var2.GL_ARB_shader_stencil_export));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_shader_texture_lod]", Boolean.valueOf(var2.GL_ARB_shader_texture_lod));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_shadow]", Boolean.valueOf(var2.GL_ARB_shadow));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_shadow_ambient]", Boolean.valueOf(var2.GL_ARB_shadow_ambient));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_stencil_texturing]", Boolean.valueOf(var2.GL_ARB_stencil_texturing));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_sync]", Boolean.valueOf(var2.GL_ARB_sync));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_tessellation_shader]", Boolean.valueOf(var2.GL_ARB_tessellation_shader));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_texture_border_clamp]", Boolean.valueOf(var2.GL_ARB_texture_border_clamp));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_texture_buffer_object]", Boolean.valueOf(var2.GL_ARB_texture_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_texture_cube_map]", Boolean.valueOf(var2.GL_ARB_texture_cube_map));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_texture_cube_map_array]", Boolean.valueOf(var2.GL_ARB_texture_cube_map_array));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_texture_non_power_of_two]", Boolean.valueOf(var2.GL_ARB_texture_non_power_of_two));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_uniform_buffer_object]", Boolean.valueOf(var2.GL_ARB_uniform_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_blend]", Boolean.valueOf(var2.GL_ARB_vertex_blend));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_buffer_object]", Boolean.valueOf(var2.GL_ARB_vertex_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_program]", Boolean.valueOf(var2.GL_ARB_vertex_program));
+		playerSnooper.addStatToSnooper("gl_caps[ARB_vertex_shader]", Boolean.valueOf(var2.GL_ARB_vertex_shader));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_bindable_uniform]", Boolean.valueOf(var2.GL_EXT_bindable_uniform));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_blend_equation_separate]", Boolean.valueOf(var2.GL_EXT_blend_equation_separate));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_blend_func_separate]", Boolean.valueOf(var2.GL_EXT_blend_func_separate));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_blend_minmax]", Boolean.valueOf(var2.GL_EXT_blend_minmax));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_blend_subtract]", Boolean.valueOf(var2.GL_EXT_blend_subtract));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_draw_instanced]", Boolean.valueOf(var2.GL_EXT_draw_instanced));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_multisample]", Boolean.valueOf(var2.GL_EXT_framebuffer_multisample));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_object]", Boolean.valueOf(var2.GL_EXT_framebuffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_framebuffer_sRGB]", Boolean.valueOf(var2.GL_EXT_framebuffer_sRGB));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_geometry_shader4]", Boolean.valueOf(var2.GL_EXT_geometry_shader4));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_gpu_program_parameters]", Boolean.valueOf(var2.GL_EXT_gpu_program_parameters));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_gpu_shader4]", Boolean.valueOf(var2.GL_EXT_gpu_shader4));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_multi_draw_arrays]", Boolean.valueOf(var2.GL_EXT_multi_draw_arrays));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_packed_depth_stencil]", Boolean.valueOf(var2.GL_EXT_packed_depth_stencil));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_paletted_texture]", Boolean.valueOf(var2.GL_EXT_paletted_texture));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_rescale_normal]", Boolean.valueOf(var2.GL_EXT_rescale_normal));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_separate_shader_objects]", Boolean.valueOf(var2.GL_EXT_separate_shader_objects));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_shader_image_load_store]", Boolean.valueOf(var2.GL_EXT_shader_image_load_store));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_shadow_funcs]", Boolean.valueOf(var2.GL_EXT_shadow_funcs));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_shared_texture_palette]", Boolean.valueOf(var2.GL_EXT_shared_texture_palette));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_clear_tag]", Boolean.valueOf(var2.GL_EXT_stencil_clear_tag));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_two_side]", Boolean.valueOf(var2.GL_EXT_stencil_two_side));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_stencil_wrap]", Boolean.valueOf(var2.GL_EXT_stencil_wrap));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_3d]", Boolean.valueOf(var2.GL_EXT_texture_3d));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_array]", Boolean.valueOf(var2.GL_EXT_texture_array));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_buffer_object]", Boolean.valueOf(var2.GL_EXT_texture_buffer_object));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_filter_anisotropic]", Boolean.valueOf(var2.GL_EXT_texture_filter_anisotropic));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_integer]", Boolean.valueOf(var2.GL_EXT_texture_integer));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_lod_bias]", Boolean.valueOf(var2.GL_EXT_texture_lod_bias));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_texture_sRGB]", Boolean.valueOf(var2.GL_EXT_texture_sRGB));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_vertex_shader]", Boolean.valueOf(var2.GL_EXT_vertex_shader));
+		playerSnooper.addStatToSnooper("gl_caps[EXT_vertex_weighting]", Boolean.valueOf(var2.GL_EXT_vertex_weighting));
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_uniforms]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_UNIFORM_COMPONENTS)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_fragment_uniforms]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_FRAGMENT_UNIFORM_COMPONENTS)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_attribs]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_ATTRIBS)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_vertex_texture_image_units]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_texture_image_units]", Integer.valueOf(GL11.glGetInteger(GL20.GL_MAX_TEXTURE_IMAGE_UNITS)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_caps[gl_max_texture_image_units]", Integer.valueOf(GL11.glGetInteger(35071)));
+		GL11.glGetError();
+		playerSnooper.addStatToSnooper("gl_max_texture_size", Integer.valueOf(getGLMaximumTextureSize()));
+	}
+
+	/** MINECRIFT */ // From Forge: Adds a optimization to the getGLMaximumTextureSize, only calculate it once.
+	private static int max_texture_size = -1;
+	/**
+	 * Used in the usage snooper.
+	 */
+	public static int getGLMaximumTextureSize()
+	{
+		if (max_texture_size != -1)
+		{
+			return max_texture_size;
+		}
+
+		for (int var0 = 16384; var0 > 0; var0 >>= 1)
+		{
+			GL11.glTexImage2D(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_RGBA, var0, var0, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)null);
+			int var1 = GL11.glGetTexLevelParameteri(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
+
+			if (var1 != 0)
+			{
+				max_texture_size = var0;
+				return var0;
+			}
+		}
+
+		return -1;
+	}
+	/** END MINECRIFT */
+
+	/**
+	 * Returns whether snooping is enabled or not.
+	 */
+	public boolean isSnooperEnabled()
+	{
+		return this.gameSettings.snooperEnabled;
+	}
+
+	/**
+	 * Set the current ServerData instance.
+	 */
+	public void setServerData(ServerData serverDataIn)
+	{
+		this.currentServerData = serverDataIn;
+	}
+
+	public ServerData getCurrentServerData()
+	{
+		return this.currentServerData;
+	}
+
+	public boolean isIntegratedServerRunning()
+	{
+		return this.integratedServerIsRunning;
+	}
+
+	/**
+	 * Returns true if there is only one player playing, and the current server is the integrated one.
+	 */
+	public boolean isSingleplayer()
+	{
+		return this.integratedServerIsRunning && this.theIntegratedServer != null;
+	}
+
+	/**
+	 * Returns the currently running integrated server
+	 */
+	public IntegratedServer getIntegratedServer()
+	{
+		return this.theIntegratedServer;
+	}
+
+	public static void stopIntegratedServer()
+	{
+		if (theMinecraft != null)
+		{
+			IntegratedServer var0 = theMinecraft.getIntegratedServer();
+
+			if (var0 != null)
+			{
+				var0.stopServer();
+			}
+		}
+	}
+
+	/**
+	 * Returns the PlayerUsageSnooper instance.
+	 */
+	public PlayerUsageSnooper getPlayerUsageSnooper()
+	{
+		return this.usageSnooper;
+	}
+
+	/**
+	 * Gets the system time in milliseconds.
+	 */
+	public static long getSystemTime()
+	{
+		return Sys.getTime() * 1000L / Sys.getTimerResolution();
+	}
+
+	/**
+	 * Returns whether we're in full screen or not.
+	 */
+	public boolean isFullScreen()
+	{
+		return this.fullscreen;
+	}
+
+	public Session getSession()
+	{
+		return this.session;
+	}
+
+	public Multimap getTwitchDetails()
+	{
+		return this.twitchDetails;
+	}
+
+	public Proxy getProxy()
+	{
+		return this.proxy;
+	}
+
+	public TextureManager getTextureManager()
+	{
+		return this.renderEngine;
+	}
+
+	public IResourceManager getResourceManager()
+	{
+		return this.mcResourceManager;
+	}
+
+	public ResourcePackRepository getResourcePackRepository()
+	{
+		return this.mcResourcePackRepository;
+	}
+
+	public LanguageManager getLanguageManager()
+	{
+		return this.mcLanguageManager;
+	}
+
+	public TextureMap getTextureMapBlocks()
+	{
+		return this.textureMapBlocks;
+	}
+
+	public boolean isJava64bit()
+	{
+		return this.jvm64bit;
+	}
+
+	public boolean isGamePaused()
+	{
+		return this.isGamePaused;
+	}
+
+	public SoundHandler getSoundHandler()
+	{
+		return this.mcSoundHandler;
+	}
+
+	public MusicTicker.MusicType getAmbientMusicType()
+	{
+		return this.currentScreen instanceof GuiWinGame ? MusicTicker.MusicType.CREDITS : (this.thePlayer != null ? (this.thePlayer.worldObj.provider instanceof WorldProviderHell ? MusicTicker.MusicType.NETHER : (this.thePlayer.worldObj.provider instanceof WorldProviderEnd ? (BossStatus.bossName != null && BossStatus.statusBarTime > 0 ? MusicTicker.MusicType.END_BOSS : MusicTicker.MusicType.END) : (this.thePlayer.capabilities.isCreativeMode && this.thePlayer.capabilities.allowFlying ? MusicTicker.MusicType.CREATIVE : MusicTicker.MusicType.GAME))) : MusicTicker.MusicType.MENU);
+	}
+
+	public IStream getTwitchStream()
+	{
+		return this.stream;
+	}
+
+	public void dispatchKeypresses()
+	{
+		int var1 = Keyboard.getEventKey();
+
+		if (var1 != 0 && !Keyboard.isRepeatEvent())
+		{
+			if (!(this.currentScreen instanceof GuiControls) || ((GuiControls)this.currentScreen).time <= getSystemTime() - 20L)
+			{
+				if (Keyboard.getEventKeyState())
+				{
+					if (var1 == this.gameSettings.keyBindStreamStartStop.getKeyCode())
+					{
+						if (this.getTwitchStream().func_152934_n())
+						{
+							this.getTwitchStream().func_152914_u();
+						}
+						else if (this.getTwitchStream().func_152924_m())
+						{
+							this.displayGuiScreen(new GuiYesNo(new GuiYesNoCallback()
+							{
+								private static final String __OBFID = "CL_00001852";
+								public void confirmClicked(boolean result, int id)
+								{
+									if (result)
+									{
+										Minecraft.this.getTwitchStream().func_152930_t();
+									}
+
+									Minecraft.this.displayGuiScreen((GuiScreen)null);
+								}
+							}, I18n.format("stream.confirm_start", new Object[0]), "", 0));
+						}
+						else if (this.getTwitchStream().func_152928_D() && this.getTwitchStream().func_152936_l())
+						{
+							if (this.theWorld != null)
+							{
+								this.ingameGUI.getChatGUI().printChatMessage(new ChatComponentText("Not ready to start streaming yet!"));
+							}
+						}
+						else
+						{
+							GuiStreamUnavailable.func_152321_a(this.currentScreen);
+						}
+					}
+					else if (var1 == this.gameSettings.keyBindStreamPauseUnpause.getKeyCode())
+					{
+						if (this.getTwitchStream().func_152934_n())
+						{
+							if (this.getTwitchStream().isPaused())
+							{
+								this.getTwitchStream().func_152933_r();
+							}
+							else
+							{
+								this.getTwitchStream().func_152916_q();
+							}
+						}
+					}
+					else if (var1 == this.gameSettings.keyBindStreamCommercials.getKeyCode())
+					{
+						if (this.getTwitchStream().func_152934_n())
+						{
+							this.getTwitchStream().func_152931_p();
+						}
+					}
+					else if (var1 == this.gameSettings.keyBindStreamToggleMic.getKeyCode())
+					{
+						this.stream.func_152910_a(true);
+					}
+					else if (var1 == this.gameSettings.keyBindFullscreen.getKeyCode())
+					{
+						this.toggleFullscreen();
+					}
+					else if (var1 == this.gameSettings.keyBindScreenshot.getKeyCode())
+					{
+						this.ingameGUI.getChatGUI().printChatMessage(ScreenShotHelper.saveScreenshot(this.mcDataDir, this.displayWidth, this.displayHeight, this.framebufferMc));
+					}
+				}
+				else if (var1 == this.gameSettings.keyBindStreamToggleMic.getKeyCode())
+				{
+					this.stream.func_152910_a(false);
+				}
+			}
+		}
+	}
+
+	public ListenableFuture addScheduledTask(Callable callableToSchedule)
+	{
+		Validate.notNull(callableToSchedule);
+
+		if (!this.isCallingFromMinecraftThread())
+		{
+			ListenableFutureTask var2 = ListenableFutureTask.create(callableToSchedule);
+			Queue var3 = this.scheduledTasks;
+
+			synchronized (this.scheduledTasks)
+			{
+				this.scheduledTasks.add(var2);
+				return var2;
+			}
+		}
+		else
+		{
+			try
+			{
+				return Futures.immediateFuture(callableToSchedule.call());
+			}
+			catch (Exception var6)
+			{
+				return Futures.immediateFailedCheckedFuture(var6);
+			}
+		}
+	}
+
+	public ListenableFuture addScheduledTask(Runnable runnableToSchedule)
+	{
+		Validate.notNull(runnableToSchedule);
+		return this.addScheduledTask(Executors.callable(runnableToSchedule));
+	}
+
+	public boolean isCallingFromMinecraftThread()
+	{
+		return Thread.currentThread() == this.mcThread;
+	}
+
+	public MinecraftSessionService getSessionService()
+	{
+		return this.sessionService;
+	}
+
+	public SkinManager getSkinManager()
+	{
+		return this.skinManager;
+	}
+
+	static final class SwitchMovingObjectType
+	{
+		static final int[] field_152390_a = new int[MovingObjectPosition.MovingObjectType.values().length];
+		private static final String __OBFID = "CL_00000638";
+
+		static
+		{
+			try
+			{
+				field_152390_a[MovingObjectPosition.MovingObjectType.ENTITY.ordinal()] = 1;
+			}
+			catch (NoSuchFieldError var2)
+			{
+				;
+			}
+
+			try
+			{
+				field_152390_a[MovingObjectPosition.MovingObjectType.BLOCK.ordinal()] = 2;
+			}
+			catch (NoSuchFieldError var1)
+			{
+				;
+			}
+		}
+	}
+
+	/** MINECRIFT ADDITIONS BELOW */
+
+
+	private void copyToMirror()
+	{
+
+		// VIVE start - render eye buffers to the desktop window
+		GL11.glPushMatrix();
+		this.framebufferMc.unbindFramebuffer();
+
+		if (this.stereoProvider.isStereo() )
+		{
+			if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_OFF && ((MCOpenVR) this.lookaimController).headIsTracking){
+
+				if(frameIndex % 45 == 0) {
+					OpenGlHelper.func_153171_g(GL30.GL_DRAW_FRAMEBUFFER, 0);   // GL30.glBindFramebuffer
+					GL11.glViewport(0, 0, this.displayFBWidth, this.displayFBHeight);
+
+					if (entityRenderer != null)
+						entityRenderer.displayNotificationText("Mirror is OFF", "", "", this.displayFBWidth, this.displayFBHeight, false, true);
+
+					Display.update(true);
+				}
+
+			}else {
+				int every = 1;
+				int ports = 2;
+
+				if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_FULL_FRAME_RATE){
+					//ok
+				} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_FULL_FRAME_RATE_SINGLE_VIEW){
+					ports = 1;
+				}if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE){
+					every = 3;
+				}if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE_SINGLE_VIEW){
+					every = 3;
+					ports = 1;
+				}
+
+				if((frameIndex % every) == 0){
+
+					for (int i = 0; i < ports; i++)
+					{
+						this.framebufferMc = framebuffers[i];
+
+						float phase = (getSystemTime() % 1000) / 1000.0f;
+						framebufferMc.framebufferRender((int)(0 + (this.displayWidth *i)*0.5f),
+								this.displayWidth/ports, this.displayHeight,0 );
+					}
+					Display.update(true);
+				}
+			}
+		} 
+
+		GL11.glPopMatrix();
+		// VIVE end - render eye buffers to the window
+
+	}
+
+	private void setupRenderConfiguration() throws Exception 
+	{
+		final float renderScaleFactor = this.vrSettings.renderScaleFactor;
+		boolean changeNonDestructiveRenderConfig = false;
+
+		glConfig.mirrorDisplay = this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF ? false : true;
+		glConfig.usePositionalTimewarp = this.vrSettings.usePositionalTimewarp;
+	
+		if (clipPlanesChanged())
+		{
+			this.reinitFramebuffers = true;
+		}
+
+		if (!Display.isActive() && this.fullscreen)
+		{
+			this.toggleFullscreen();
+			this.reinitFramebuffers = true;
+		}
+
+		if (wasDisplayResized())
+		{
+			Display.update();     // This will set new display widths accordingly
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.lastGuiScale != this.gameSettings.guiScale)
+		{
+			this.lastGuiScale = this.gameSettings.guiScale;
+			this.reinitFramebuffers = true;
+		}
+
+		if (!this.stereoProvider.isGuiOrtho()) {
+			showNativeMouseCursor(!Display.isActive());
+		}
+		else {
+			showNativeMouseCursor(true);
+		}
+
+		// Check for changes in window handle
+		glConfig = getLWJGLConfig(glConfig);
+		if (glConfig.Window != lastWindow)
+		{
+			this.reinitFramebuffers = true;
+			lastWindow = glConfig.Window;
+		}
+
+		if (lastShaderIndex != this.vrSettings.shaderIndex) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (lastMirrorSetting != this.vrSettings.displayMirrorMode) {
+			this.reinitFramebuffers = true;
+			lastMirrorSetting = this.vrSettings.displayMirrorMode;
+		}
+
+		if (this.lastEnableVsync != this.gameSettings.enableVsync) {
+			this.reinitFramebuffers = true;
+		}
+
+		if (this.reinitFramebuffers)
+		{
+			this.visible = true;
+			this.checkGLError("Start Init");
+
+			viewPortCount = 1;
+			float superSampleScaleFactor = 1f;
+			if (this.vrSettings.useFsaa)
+				superSampleScaleFactor = this.vrSettings.fsaaScaleFactor;
+
+			displayFBWidth = (Display.getWidth() < 1) ? 1 : Display.getWidth();
+			displayFBHeight = (Display.getHeight() < 1) ? 1 : Display.getHeight();
+			
+			distortionRenderTargetSize[0] = new Sizei(displayFBWidth, displayFBHeight);
+			distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+	
+			this.EyeTextureSize[0].w = this.displayWidth = (int)ceil((displayFBWidth * superSampleScaleFactor));
+			this.EyeTextureSize[0].h = this.displayHeight = (int)ceil((displayFBHeight * superSampleScaleFactor));
+			this.EyeTextureSize[1] = this.EyeTextureSize[0];
+
+			FovPort leftFov = null;
+			FovPort rightFov = null;
+
+			if (!this.stereoProvider.isInitialized()) {
+				throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getInitializationStatus());
+			}
+
+			// Scale up the FBO to allow for the distortion
+			if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+			{
+				leftFov = hmdInfo.getHMDInfo().DefaultEyeFov[0];
+				rightFov = hmdInfo.getHMDInfo().DefaultEyeFov[1];
+
+				System.out.println("L Fov:           " + leftFov.toString());
+				System.out.println("R Fov:           " + rightFov.toString());
+
+				RenderTextureInfo renderTextureInfo = this.stereoProvider.getRenderTextureSizes(leftFov, rightFov, renderScaleFactor);
+
+				distortionRenderTargetSize[0] = renderTextureInfo.LeftFovTextureResolution;
+				distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+				this.EyeTextureSize[0].w = (int)ceil(renderTextureInfo.LeftFovTextureResolution.w * superSampleScaleFactor);
+				this.EyeTextureSize[0].h = (int)ceil(renderTextureInfo.LeftFovTextureResolution.h * superSampleScaleFactor);
+				this.EyeTextureSize[1] = this.EyeTextureSize[0];
+
+				viewPortCount = 2;
+
+			}
+
+			if (this.framebuffers[0] != null) {
+				this.framebuffers[0].deleteFramebuffer();
+				this.framebuffers[0] = null;
+			}
+
+			if (this.framebuffers[1] != null) {
+				this.framebuffers[1].deleteFramebuffer();
+				this.framebuffers[1] = null;
+			}
+
+			this.stereoProvider.deleteRenderTextures();
+
+			if (this.guiFramebuffer != null) {
+				this.guiFramebuffer.deleteFramebuffer();
+				this.guiFramebuffer = null;
+			}
+
+			if (this.loadingScreen != null) {
+				this.loadingScreen.deleteFramebuffer();
+			}
+
+			if (this.mirrorFB != null) {
+				this.mirrorFB.delete();
+				this.mirrorFB = null;
+			}
+
+			this.stereoProvider.deleteMirrorTexture();
+
+			if (this.fsaaFirstPassResultFBO[0] != null) {
+				this.fsaaFirstPassResultFBO[0].delete();
+				this.fsaaFirstPassResultFBO[0] = null;
+			}
+			if (this.fsaaFirstPassResultFBO[1] != null) {
+				this.fsaaFirstPassResultFBO[1].delete();
+				this.fsaaFirstPassResultFBO[1] = null;
+			}
+			if (this.fsaaSecondPassResultFBO[0] != null) {
+				this.fsaaSecondPassResultFBO[0].delete();
+				this.fsaaSecondPassResultFBO[0] = null;
+			}
+			if (this.fsaaSecondPassResultFBO[1] != null) {
+				this.fsaaSecondPassResultFBO[1].delete();
+				this.fsaaSecondPassResultFBO[1] = null;
+			}
+
+			_LanczosShader_texelWidthOffsetUniform = -1;
+			_LanczosShader_texelHeightOffsetUniform = -1;
+			_LanczosShader_inputImageTextureUniform = -1;
+
+			int multiSampleCount = 0;
+			boolean multiSample = (multiSampleCount > 0 ? true : false);
+			boolean genMipMaps = true;
+			this.entityRenderer.generatedIconMipmaps[0] = false;
+			this.entityRenderer.generatedIconMipmaps[1] = false;
+
+			if (this.stereoProvider.providesMirrorTexture() && this.vrSettings.displayMirrorMode != VRSettings.MIRROR_OFF)
+			{ //alwasy false
+				this.mirrorFBWidth = this.displayFBWidth;
+				this.mirrorFBHeight = this.displayFBHeight;
+				if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_FULL_FRAME_RATE_SINGLE_VIEW ||
+						this.vrSettings.displayMirrorMode == VRSettings.MIRROR_ON_ONE_THIRD_FRAME_RATE_SINGLE_VIEW) {
+					this.mirrorFBWidth *= 2;
+					this.mirrorFBHeight *= 2;
+				}
+				int mirrorTextureId = this.stereoProvider.createMirrorTexture(this.mirrorFBWidth, this.mirrorFBHeight);
+				if (mirrorTextureId == -1) {
+					throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+				}
+				print("Provider supplied mirror texture ID: " + mirrorTextureId);
+
+				mirrorTexProvider.setTextureId(mirrorTextureId);
+				mirrorFB = new FBOParams("Mirror FBO", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, this.mirrorFBWidth, this.mirrorFBHeight, mirrorTexProvider);
+				System.out.println(mirrorFB.toString());
+			}
+			this.checkGLError("Mirror framebuffer setup");
+
+			if (this.stereoProvider.providesRenderTextures())
+			{ //always true
+				// Source render textures
+				RenderTextureSet renderTextures = this.stereoProvider.createRenderTextureSet(
+						distortionRenderTargetSize[0].w,
+						distortionRenderTargetSize[0].h,
+						distortionRenderTargetSize[1].w,
+						distortionRenderTargetSize[1].h);
+				if (renderTextures == null) {
+					throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+				}
+				print("L Render texture resolution: " + distortionRenderTargetSize[0].w + " x " + distortionRenderTargetSize[0].h);
+				print("R Render texture resolution: " + distortionRenderTargetSize[1].w + " x " + distortionRenderTargetSize[1].h);
+				print("Provider supplied render texture IDs:\n" + renderTextures.toString());
+
+				renderTexProvider[0].setTextureIds(renderTextures.leftEyeTextureIds);
+				renderTexProvider[1].setTextureIds(renderTextures.rightEyeTextureIds);
+			}
+			else
+			{
+				// Generate our textures
+				renderTexProvider[0].genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, distortionRenderTargetSize[0].h, 1);
+				renderTexProvider[1].genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, distortionRenderTargetSize[1].h, 1);
+			}
+			this.checkGLError("Render Texture setup");
+
+
+			this.framebuffers[0] = new Framebuffer("L Eye", this.EyeTextureSize[0].w, this.EyeTextureSize[0].h, true, genMipMaps, multiSample, multiSampleCount, this.vrSettings.useFsaa ? null : renderTexProvider[0]);
+			print(this.framebuffers[0].toString());
+			this.checkGLError("Left Eye framebuffer setup");
+
+			this.framebuffers[1] = new Framebuffer("R Eye", this.EyeTextureSize[1].w, this.EyeTextureSize[1].h, true, genMipMaps, multiSample, multiSampleCount, this.vrSettings.useFsaa ? null : renderTexProvider[1]);
+			print(this.framebuffers[1].toString());
+			this.checkGLError("Right Eye framebuffer setup");
+
+			this.guiFramebuffer  = new Framebuffer("GUI", this.displayFBWidth, this.displayFBHeight, true, genMipMaps);
+			print(this.guiFramebuffer.toString());
+			this.checkGLError("GUI framebuffer setup");
+
+			this.framebuffers[0].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+			this.framebuffers[1].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+			this.guiFramebuffer.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+
+			setupClipPlanes();
+
+			if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+			{
+				this.entityRenderer.eyeproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getProjectionMatrix(hmdInfo.getHMDInfo().DefaultEyeFov[0], EyeType.ovrEye_Left, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+				this.entityRenderer.eyeproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getProjectionMatrix(hmdInfo.getHMDInfo().DefaultEyeFov[1], EyeType.ovrEye_Right, this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+			}
+
+			try
+			{
+				if (this.vrSettings.useFsaa)
+				{
+					// GL21.GL_SRGB8_ALPHA8
+					// GL11.GL_RGBA8
+
+					// Lanczos downsample FBOs
+					fsaaFirstPassResultFBO[0] = new FBOParams("FSAA Pass1 FBO1 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, this.EyeTextureSize[0].h, null);
+					fsaaFirstPassResultFBO[1] = new FBOParams("FSAA Pass1 FBO2 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, this.EyeTextureSize[1].h, null);
+					fsaaSecondPassResultFBO[0] = new FBOParams("FSAA Pass2 FBO1", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, distortionRenderTargetSize[0].h, renderTexProvider[0]);
+					fsaaSecondPassResultFBO[1] = new FBOParams("FSAA Pass2 FBO2", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, distortionRenderTargetSize[1].h, renderTexProvider[1]);
+
+					print(this.fsaaFirstPassResultFBO[0].toString());
+					print(this.fsaaFirstPassResultFBO[1].toString());
+					print(this.fsaaSecondPassResultFBO[0].toString());
+					print(this.fsaaSecondPassResultFBO[1].toString());
+					checkGLError("FSAA FBO creation");
+
+					_Lanczos_shaderProgramId = ShaderHelper.initShaders(LANCZOS_SAMPLER_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER, true);
+					if (_Lanczos_shaderProgramId == 0) {
+						throw new Exception("Failed to validate FSAA shader!");
+					}
+
+					ShaderHelper.checkGLError("@1");
+
+					// Setup uniform IDs
+					_LanczosShader_texelWidthOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset");
+					_LanczosShader_texelHeightOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset");
+					_LanczosShader_inputImageTextureUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture");
+
+					ShaderHelper.checkGLError("FBO init Lanczos shader");
+				}
+			}
+			catch (Exception ex)
+			{
+				// We had an issue. Set the usual suspects to defaults...
+				this.vrSettings.useFsaa = false;
+				this.vrSettings.fsaaScaleFactor = 1.4f;
+				this.vrSettings.saveOptions();
+				System.out.println("[Minecrift] FAILED to setup FSAA: " + ex.getMessage());
+				reinitFramebuffers = true;
+				return;
+			}
+
+			// Init screen size
+			if (this.currentScreen != null)
+			{
+				ScaledResolution scaledresolution = new ScaledResolution(this,
+						this.stereoProvider.isGuiOrtho() ? (int)Math.ceil(this.displayFBWidth * superSampleScaleFactor) : this.displayFBWidth,
+								this.stereoProvider.isGuiOrtho() ? (int)Math.ceil(this.displayFBHeight * superSampleScaleFactor) : this.displayFBHeight);
+				int k = scaledresolution.getScaledWidth();
+				int l = scaledresolution.getScaledHeight();
+				this.currentScreen.setWorldAndResolution(this, k, l);
+			}
+			this.loadingScreen = new LoadingScreenRenderer(this, this.stereoProvider.isGuiOrtho() ? this.displayWidth : this.displayFBWidth, this.stereoProvider.isGuiOrtho() ? this.displayHeight : this.displayFBHeight);
+			this.loadingScreen.deleteFramebuffer();
+			
+			if (this.stereoProvider.isGuiOrtho()) {
+				this.loadingScreen.renderTarget = this.getFramebuffer();
+			}
+			else {
+				this.loadingScreen.renderTarget = this.guiFramebuffer;
+			}
+
+			System.out.println("[Minecrift] New render config:" +
+					"\nRender target width:  " + (this.stereoProvider.isStereo() ? this.EyeTextureSize[0].w + this.EyeTextureSize[1].w: this.displayWidth) +
+					", height: " + (this.stereoProvider.isStereo() ? Math.max(this.EyeTextureSize[0].h, this.EyeTextureSize[1].h) : this.displayHeight) +
+					(this.stereoProvider.isStereo() ? " [Render scale: " + renderScaleFactor + "]" : "") +
+					(this.vrSettings.useFsaa ? " [FSAA Scale: " + this.vrSettings.fsaaScaleFactor + "]" : "") +
+					"\nDisplay target width: " + this.displayFBWidth + ", height: " + displayFBHeight);
+
+			// Init shaders
+			if (this.entityRenderer != null) {
+				if (shaderGroup[0] != null)
+					shaderGroup[0].deleteShaderGroup();
+
+				if (shaderGroup[1] != null)
+					shaderGroup[1].deleteShaderGroup();
+
+				lastShaderIndex = this.vrSettings.shaderIndex;
+				shaderGroup[0] = this.entityRenderer.initShaderGroup(framebuffers[0]);
+				shaderGroup[1] = this.entityRenderer.initShaderGroup(framebuffers[1]);
+			}
+
+			this.lastDisplayFBWidth = this.displayFBWidth;
+			this.lastDisplayFBHeight = this.displayFBHeight;
+			this.lastEnableVsync = this.gameSettings.enableVsync;
+			this.reinitFramebuffers = false;
+
+			if (this.firstInit)
+			{
+//				// Workaround for bad init of Oculus SDK
+//				this.firstInit = false;
+//				this.reinitFramebuffers = true;
+//				System.out.println("[Minecrift] Now re-init for Oculus SDK weirdness...");
+			}
+		}
+
+		if (changeNonDestructiveRenderConfig || this.reinitFramebuffers)
+		{
+			this.stereoProvider.configureRenderer(glConfig);
+		}
+	}
+
+	public void setupClipPlanes()
+	{
+		this.entityRenderer.farPlaneDistance = (float)(this.gameSettings.renderDistanceChunks * 16);
+
+		if (Config.isFogFancy())
+		{
+			this.entityRenderer.farPlaneDistance *= 0.95F;
+		}
+
+		if (Config.isFogFast())
+		{
+			this.entityRenderer.farPlaneDistance *= 0.83F;
+		}
+
+		this.entityRenderer.clipDistance = this.entityRenderer.farPlaneDistance * 2.0F;
+
+		if (this.entityRenderer.clipDistance < 128.0F)
+		{
+			this.entityRenderer.clipDistance = 128.0F;
+		}
+
+		if (this.theWorld != null && this.theWorld.provider != null && this.theWorld.provider.dimensionId == 1)
+		{
+			this.entityRenderer.clipDistance = 256.0F;
+		}
+	}
+
+	public boolean clipPlanesChanged()
+	{
+		boolean changed = false;
+
+		if (this.theWorld != null && this.theWorld.provider != null)
+		{
+			if (this.theWorld.provider.dimensionId != this.lastDimensionId)
+			{
+				//changed = true;   // TODO: Re-enable when Lib OVR doesn't crash all the bloody time. We
+				// can't currently change render config in-game, without a crash in
+				// nvgl.dll glDrawArrays
+			}
+		}
+
+		if( this.gameSettings.renderDistanceChunks != this.lastRenderDistanceChunks ||
+				Config.isFogFancy() != this.lastFogFancy                                ||
+				Config.isFogFast() != this.lastFogFast)
+		{
+			changed = true;
+		}
+
+		lastRenderDistanceChunks = this.gameSettings.renderDistanceChunks;
+		lastFogFancy = Config.isFogFancy();
+		lastFogFast = Config.isFogFast();
+		if (this.theWorld != null && this.theWorld.provider != null)
+			lastDimensionId = this.theWorld.provider.dimensionId;
+
+		return changed;
+	}
+
+	public GLConfig getLWJGLConfig(GLConfig glConfig)
+	{
+		// TODO: For LWJGL 3.0, this function may well be screwed...
+
+		// We need to retrieve certain pointers / handles from LWJGL
+		// for the Oculus SDK. However, these are not exposed by
+		// LWJGL, so use reflection to get hold of the data we need.
+
+		try
+		{
+			switch(LWJGLUtil.getPlatform())
+			{
+			case LWJGLUtil.PLATFORM_WINDOWS:
+			{
+				// Get HWND pointer...
+				if (fieldHwnd == null)
+				{
+					fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+					fieldHwnd.setAccessible(true);
+				}
+				glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+				//System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_LINUX:
+			{
+				// Get Display and Window pointers...
+				if (fieldDisplay == null)
+				{
+					fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+					fieldDisplay.setAccessible(true);
+				}
+				if (fieldWindow == null)
+				{
+					fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+					fieldWindow.setAccessible(true);
+				}
+				glConfig.Display = (Long) fieldDisplay.get(null);
+				glConfig.Window = (Long) fieldWindow.get(null);
+				//System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+				//System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_MACOSX:
+			{
+				// Do nowt...
+				break;
+			}
+			default:
+				throw new Exception ("Current platform not supported!");
+			}
+		}
+		catch (Exception ex)
+		{
+			ex.printStackTrace();
+			glConfig = null;
+		}
+
+		return glConfig;
+	}
+
+	public boolean wasDisplayResized()
+	{
+		boolean wasResized = false;
+
+		// We don't want to have to call Display.update() just to determine
+		// if the display has been resized - this will invoke a swapBuffer.
+
+		switch(LWJGLUtil.getPlatform())
+		{
+		case LWJGLUtil.PLATFORM_WINDOWS:
+		case LWJGLUtil.PLATFORM_LINUX: {
+			// Get the 'resized' field from the Display class...
+			try {
+				if (fieldResized == null) {
+					fieldResized = displayImpl.getClass().getDeclaredField("resized");
+					fieldResized.setAccessible(true);
+				}
+				wasResized = (Boolean) fieldResized.get(displayImpl);
+			} catch (Exception e) {
+				System.out.println(displayImpl.getClass().getName());
+				e.printStackTrace();
+			}
+		}
+		break;
+		case LWJGLUtil.PLATFORM_MACOSX: {
+			// Get the 'wasResized' method from the Display class...
+			try {
+				if (fieldResizedMethod == null) {
+					fieldResizedMethod = displayImpl.getClass().getDeclaredMethod("wasResized");
+					fieldResizedMethod.setAccessible(true);
+				}
+				wasResized = (Boolean) fieldResizedMethod.invoke(displayImpl);
+			} catch (Exception e) {
+				System.out.println(displayImpl.getClass().getName());
+				e.printStackTrace();
+			}
+		}
+		break;
+		}
+
+		if (wasResized)
+			System.out.println("Display resized");
+
+		return wasResized;
+	}
+
+	public void initMinecrift() throws Exception
+	{
+		this.lastGuiScale = this.gameSettings.guiScale;
+
+		// Get underlying LWJGL Display implementation
+		if (displayImpl == null)
+		{
+			try {
+				Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+				displayMethod.setAccessible(true);
+				displayImpl = displayMethod.invoke(null, (java.lang.Object[])null); // VIVE fix warning
+				System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+		try {
+			//Class.forName("com.mtbs3d.minecrift.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+			//hydraLibsAvailable = true;
+		} catch (NoClassDefFoundError e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		} catch( Exception e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		}
+
+		// #85 Allow disable mumblelib load
+		if (this.vrSettings.loadMumbleLib) {
+			try {
+				MumbleLink.loadLibrary();
+				mumbleLink = new MumbleLink("MinecraftVR", "Minecraft VR");
+				mumbleLink.setIdentityAndContext(this.session.getUsername(), "Minecraft"/*TODO: get the servername? */);
+			} catch (Exception e) {
+				System.err.println("Couldn't load [MumbleLink library]: " + e.toString());
+			}
+		}
+		else {
+			System.err.println("Skipping loading: [MumbleLink library]: Configuration setting disabled loading");
+		}
+
+		this.EyeTextureSize[0] = new Sizei();
+		this.EyeTextureSize[1] = new Sizei();
+
+		new MCOpenVR();
+		//hmdInfo = PluginManager.configureHMD("oculus");
+
+		new NullHmdInfo();
+		new NullPositionAndOrientation();
+		new NullStereoRenderer();                            // Create and register "None" stereo renderer plugin
+
+		initPlugins();
+
+		nativeMouseCursor = Mouse.getNativeCursor();
+		try {
+			invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+		} catch (LWJGLException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void initPlugins() throws Exception
+	{
+		hmdInfo           = PluginManager.configureHMD(this.vrSettings.hmdPluginID);
+		headTracker       = PluginManager.configureOrientation(this.vrSettings.headTrackerPluginID);
+		positionTracker   = PluginManager.configurePosition(this.vrSettings.headPositionPluginID);
+		lookaimController = PluginManager.configureController("mouse"); // Always configure mouse
+		lookaimController = PluginManager.configureController(this.vrSettings.controllerPluginID);
+		stereoProvider    = PluginManager.configureStereoProvider(this.vrSettings.stereoProviderPluginID);
+	}
+
+	public void printChatMessage(String msg)
+	{
+		if (this.theWorld != null) {
+			ChatComponentText chatText = new ChatComponentText("\u00a7e[Minecrift]: " + msg + "\u00a7f");
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+
+	public void showNativeMouseCursor(boolean show)
+	{
+		if (show == lastShowMouseNative)
+			return;
+
+		lastShowMouseNative = show;
+
+		try
+		{
+			if (show)
+			{
+				Mouse.setNativeCursor(nativeMouseCursor);
+			}
+			else
+			{
+				Mouse.setNativeCursor(invisibleMouseCursor);
+			}
+		}
+		catch (LWJGLException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+	public Posef getEyePose(EyeType eye)
+	{
+		Posef eyePose = new Posef();
+
+		// Get orientation first...
+		if (this.headTracker != null && this.headTracker.isInitialized())
+		{
+			Quaternion orient = this.headTracker.getOrientationQuaternion(eye);
+			if (orient != null) {
+				eyePose.Orientation.x = orient.x;
+				eyePose.Orientation.y = orient.y;
+				eyePose.Orientation.z = orient.z;
+				eyePose.Orientation.w = orient.w;
+			}
+		}
+
+		// ...as some position providers also require orientation information (I'm looking
+		// at you, Hydra!)
+		if (positionTracker != null && this.positionTracker.isInitialized())
+		{
+			Vec3 pos = positionTracker.getEyePosition(eye);
+			if (pos != null)
+			{
+				eyePose.Position.x = (float) pos.xCoord;
+				eyePose.Position.y = (float) pos.yCoord;
+				eyePose.Position.z = (float) pos.zCoord;
+			}
+		}
+
+		return eyePose;
+	}
+
+	public boolean endFrame()
+	{
+				
+		if (this.stereoProvider != null)
+			return this.stereoProvider.endFrame();
+
+	
+		return true;
+	}
+
+	public double getCurrentTimeSecs()
+	{
+		return this.stereoProvider.getCurrentTimeSecs();
+	}
+
+	private void doPostProcessing(long frameIndex, EyeType eye)
+	{
+			
+		// VIVE start - screen flash when hurt instead of view tilt
+		EntityLivingBase player = renderViewEntity;
+		if (player!=null && player.getHealth() > 0.0f)
+		{
+			float var3 = (float)player.hurtTime - timer.renderPartialTicks;
+			if (var3>0.0f)
+			{
+				var3 /= (float) player.maxHurtTime;
+				var3 = MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+				final Color3f rgb = new Color3f(255.0f, 0f, 0f);
+				this.entityRenderer.renderFadeBlend(rgb, var3);
+			}
+		}
+		// VIVE end - screen flash when hurt instead of view tilt
+
+		if (showSplashScreen && splashFadeAlpha > 0)
+		{
+			final Color3f rgb = new Color3f(0f, 0f, 0f);
+		//	this.entityRenderer.renderFadeBlend(rgb, splashFadeAlpha);
+		}
+
+		if (this.vrSettings.useFsaa)
+		{
+			GL11.glDisable(GL11.GL_ALPHA_TEST);
+			GL11.glDisable(GL11.GL_BLEND);
+
+			// Setup ortho projection
+			GL11.glMatrixMode(GL11.GL_PROJECTION);
+			GL11.glLoadIdentity();
+			GL11.glMatrixMode(GL11.GL_MODELVIEW);
+			GL11.glLoadIdentity();
+
+			GL11.glTranslatef(0.0f, 0.0f, -0.7f);
+
+			// Now switch to 1st pass FSAA result target framebuffer
+			this.fsaaFirstPassResultFBO[eye.value()].bindRenderTarget();
+
+			// Bind the FBO
+			this.framebuffers[eye.value()].bindFramebufferTexture();
+
+			GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+			GL11.glClearDepth(1.0D);
+		    GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer
+
+			// Render onto the entire screen framebuffer
+			GL11.glViewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.EyeTextureSize[eye.value()].h);
+
+			// Set the downsampling shader as in use
+			ARBShaderObjects.glUseProgramObjectARB(_Lanczos_shaderProgramId);
+
+			// Set up the fragment shader uniforms
+			ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].w));
+			ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 0.0f);
+			ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+			GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
+
+			// Pass 1
+			drawQuad();
+
+			// checkGLError("After Lanczos Pass1");
+
+			// Pass 2
+			// Now switch to 2nd pass screen framebuffer
+			if (this.stereoProvider.isStereo())
+			{
+				fsaaSecondPassResultFBO[eye.value()].bindRenderTarget();
+				fsaaSecondPassResultFBO[eye.value()].selectTexture();
+			}
+			else
+			{
+				this.framebufferMc.unbindFramebuffer();
+			}
+
+			fsaaFirstPassResultFBO[eye.value()].bindTexture();
+
+			GL11.glViewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.distortionRenderTargetSize[eye.value()].h);
+			GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+			GL11.glClearDepth(1.0D);
+			GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+			// Bind the texture
+			GL13.glActiveTexture(GL13.GL_TEXTURE0);
+
+			// Set up the fragment shader uniforms for pass 2
+			ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 0.0f);
+			ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].h));
+			ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+			drawQuad();
+
+			// Stop shader use
+			ARBShaderObjects.glUseProgramObjectARB(0);
+			// checkGLError("After Lanczos Pass2");
+
+			GL11.glEnable(GL11.GL_ALPHA_TEST);
+			GL11.glEnable(GL11.GL_BLEND);
+		}
+		else if (!this.stereoProvider.isStereo())
+		{
+			this.framebufferMc.unbindFramebuffer();
+			this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+		}
+	}
+
+	public void drawQuad()
+	{
+		// this func just draws a perfectly normal box with some texture coordinates
+		GL11.glBegin(GL11.GL_QUADS);
+
+		// Front Face
+		GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+	public void showSplash(Framebuffer rendertarget)
+	{
+
+		final int SPLASH_TIMEOUT_MS = this.stereoProvider.isStereo() ? 2000 : 1500;
+		final int SPLASH_FADE_TIMEOUT_MS = this.stereoProvider.isStereo() ? 1000 : 0;
+		splashFadeAlpha = 0f;
+		final long currentTimeMs = System.currentTimeMillis();
+
+		// Start display splash timer (only after any calibration has finished)
+		if (this.entityRenderer.calibrationHelper == null && splashTimer1 == 0 && splashTimer2 == 0)
+		{
+			splashTimer1 = currentTimeMs;
+		}
+
+		RED_COLOUR_COMPONENT = 1f;
+		GREEN_COLOUR_COMPONENT = 1f;
+		BLUE_COLOUR_COMPONENT = 1f;
+
+		// Start fade timer
+		if (splashTimer1 != 0 && (currentTimeMs > splashTimer1 + SPLASH_TIMEOUT_MS))
+		{
+			splashTimer1 = 0;
+			splashTimer2 = currentTimeMs;
+		}
+
+		// Continue or end fade
+		if (splashTimer2 != 0 && (currentTimeMs < splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+		{
+			splashFadeAlpha = (100f / SPLASH_FADE_TIMEOUT_MS) * (currentTimeMs - splashTimer2) * 0.01f;
+		}
+		else if (splashTimer2 != 0 && (currentTimeMs >= splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+		{
+			this.showSplashScreen = false;
+			splashFadeAlpha = this.stereoProvider.isStereo() ? 1f : 0f;
+			RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+			GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+			BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+		}
+
+		int existingScale = gameSettings.guiScale;
+		gameSettings.guiScale = 0;
+		ScaledResolution var1 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+				int var2 = var1.getScaleFactor();
+		if (splash == null)
+			splash = new Framebuffer(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2, true);
+		splash.bindFramebuffer(true);
+		GL11.glMatrixMode(GL11.GL_PROJECTION);
+		GL11.glLoadIdentity();
+	
+		GL11.glOrtho(0.0D, (double) var1.getScaledWidth(), (double) var1.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);
+		GL11.glMatrixMode(GL11.GL_MODELVIEW);
+		GL11.glLoadIdentity();
+		GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_FOG);
+		GL11.glDisable(GL11.GL_DEPTH_TEST);
+		GL11.glEnable(GL11.GL_TEXTURE_2D);
+			
+		try
+		{
+			if (this.mojangLogo == null)
+				this.mojangLogo = this.renderEngine.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(this.mcDefaultResourcePack.getInputStream(this.locationMojangPng))));
+			this.renderEngine.bindTexture(this.mojangLogo);
+		}
+		catch (IOException var7)
+		{
+			logger.error("Unable to load logo: " + locationMojangPng, var7);
+		}
+
+		Tessellator var4 = Tessellator.instance;
+		var4.startDrawingQuads();
+		var4.setColorOpaque_I(16777215);
+		var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV((double) this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+		var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+		var4.draw();
+		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+		var4.setColorOpaque_I(16777215);
+		short var5 = 256;
+		short var6 = 256;
+		this.scaledTessellator((var1.getScaledWidth() - var5) / 2, (var1.getScaledHeight() - var6) / 2, 0, 0, var5, var6);
+		GL11.glDisable(GL11.GL_LIGHTING);
+		GL11.glDisable(GL11.GL_FOG);
+		rendertarget.bindFramebuffer(true);
+		splash.framebufferRender(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2);
+		GL11.glEnable(GL11.GL_ALPHA_TEST);
+		GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+		//GL11.glFlush();
+		//Display.update();
+		gameSettings.guiScale = existingScale;
+		//this.func_147120_f();
+		
+	}
+
+	private static void sleepNanos (long nanoDelay)
+	{
+		final long end = System.nanoTime() + nanoDelay;
+		do
+		{
+			Thread.yield();  // This is a busy wait sadly...
+		}
+		while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime)
+	{
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0)
+		{
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+		{
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++)
+			{
+				array[i] = (Long)itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos()
+	{
+		return medianRunTickTimeNanos;
+	}
+
+	public final String LANCZOS_SAMPLER_VERTEX_SHADER =
+			"#version 120\n" +
+					"\n" +
+					" uniform float texelWidthOffset;\n" +
+					" uniform float texelHeightOffset;\n" +
+					"\n" +
+					" varying vec2 centerTextureCoordinate;\n" +
+					" varying vec2 oneStepLeftTextureCoordinate;\n" +
+					" varying vec2 twoStepsLeftTextureCoordinate;\n" +
+					" varying vec2 threeStepsLeftTextureCoordinate;\n" +
+					" varying vec2 fourStepsLeftTextureCoordinate;\n" +
+					" varying vec2 oneStepRightTextureCoordinate;\n" +
+					" varying vec2 twoStepsRightTextureCoordinate;\n" +
+					" varying vec2 threeStepsRightTextureCoordinate;\n" +
+					" varying vec2 fourStepsRightTextureCoordinate;\n" +
+					"\n" +
+					" void main()\n" +
+					" {\n" +
+					"     gl_Position = ftransform();\n" +
+					"\n" +
+					"     vec2 firstOffset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+					"     vec2 secondOffset = vec2(2.0 * texelWidthOffset, 2.0 * texelHeightOffset);\n" +
+					"     vec2 thirdOffset = vec2(3.0 * texelWidthOffset, 3.0 * texelHeightOffset);\n" +
+					"     vec2 fourthOffset = vec2(4.0 * texelWidthOffset, 4.0 * texelHeightOffset);\n" +
+					"\n" +
+					"     vec2 textCoord = gl_MultiTexCoord0.xy;\n" +
+					"     centerTextureCoordinate = textCoord;\n" +
+					"     oneStepLeftTextureCoordinate = textCoord - firstOffset;\n" +
+					"     twoStepsLeftTextureCoordinate = textCoord - secondOffset;\n" +
+					"     threeStepsLeftTextureCoordinate = textCoord - thirdOffset;\n" +
+					"     fourStepsLeftTextureCoordinate = textCoord - fourthOffset;\n" +
+					"     oneStepRightTextureCoordinate = textCoord + firstOffset;\n" +
+					"     twoStepsRightTextureCoordinate = textCoord + secondOffset;\n" +
+					"     threeStepsRightTextureCoordinate = textCoord + thirdOffset;\n" +
+					"     fourStepsRightTextureCoordinate = textCoord + fourthOffset;\n" +
+					" }\n";
+
+	public final String LANCZOS_SAMPLER_FRAGMENT_SHADER =
+
+			"#version 120\n" +
+					"\n" +
+					" uniform sampler2D inputImageTexture;\n" +
+					"\n" +
+					" varying vec2 centerTextureCoordinate;\n" +
+					" varying vec2 oneStepLeftTextureCoordinate;\n" +
+					" varying vec2 twoStepsLeftTextureCoordinate;\n" +
+					" varying vec2 threeStepsLeftTextureCoordinate;\n" +
+					" varying vec2 fourStepsLeftTextureCoordinate;\n" +
+					" varying vec2 oneStepRightTextureCoordinate;\n" +
+					" varying vec2 twoStepsRightTextureCoordinate;\n" +
+					" varying vec2 threeStepsRightTextureCoordinate;\n" +
+					" varying vec2 fourStepsRightTextureCoordinate;\n" +
+					"\n" +
+					" // sinc(x) * sinc(x/a) = (a * sin(pi * x) * sin(pi * x / a)) / (pi^2 * x^2)\n" +
+					" // Assuming a Lanczos constant of 2.0, and scaling values to max out at x = +/- 1.5\n" +
+					"\n" +
+					" void main()\n" +
+					" {\n" +
+					"     vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.38026;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.27667;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.27667;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.08074;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, threeStepsRightTextureCoordinate) * -0.02612;\n" +
+					"\n" +
+					"     fragmentColor += texture2D(inputImageTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n" +
+					"     fragmentColor += texture2D(inputImageTexture, fourStepsRightTextureCoordinate) * -0.02143;\n" +
+					"\n" +
+					"     gl_FragColor = fragmentColor;\n" +
+					" }\n";
+
+	public void enableGuiSizeHack()
+	{
+		this.currentDisplayWidth = this.displayWidth;
+		this.currentDisplayHeight = this.displayHeight;
+
+		float superSampleScaleFactor = 1f;
+		if (this.vrSettings.useFsaa)
+			superSampleScaleFactor = this.vrSettings.fsaaScaleFactor;
+
+		// Hack the GUI w & h
+		if (!this.stereoProvider.isGuiOrtho()) {
+			this.displayWidth = this.displayFBWidth;
+			this.displayHeight = this.displayFBHeight;
+		}
+		else {
+			this.displayWidth = (int)Math.ceil(this.displayFBWidth * superSampleScaleFactor);
+			this.displayHeight = (int)Math.ceil(this.displayFBHeight * superSampleScaleFactor);
+		}
+	}
+
+	public void disableGuiSizeHack()
+	{
+		this.displayWidth = this.currentDisplayWidth;
+		this.displayHeight = this.currentDisplayHeight;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+		this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s)
+	{
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
 }
