--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -9,19 +9,40 @@
 import com.google.common.util.concurrent.ListenableFutureTask;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import com.mtbs3d.minecrift.api.*;
+import com.mtbs3d.minecrift.control.GuiScreenNavigator;
+import com.mtbs3d.minecrift.provider.*;
+import com.mtbs3d.minecrift.render.FBOParams;
+import com.mtbs3d.minecrift.render.RenderConfigException;
+import com.mtbs3d.minecrift.render.ShaderHelper;
+import com.mtbs3d.minecrift.settings.VRHotkeys;
+import com.mtbs3d.minecrift.control.ControlBinding;
+import com.mtbs3d.minecrift.settings.VRSettings;
+import com.mtbs3d.minecrift.utils.TextureSelector;
+
+import de.fruitfly.ovr.OculusRift;
+import de.fruitfly.ovr.enums.EyeType;
+import de.fruitfly.ovr.structs.*;
 import io.netty.util.concurrent.GenericFutureListener;
+
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.text.DecimalFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -30,11 +51,16 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+
 import javax.imageio.ImageIO;
+import javax.vecmath.Color3f;
+
+import net.aib42.mumblelink.MumbleLink;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityClientPlayerMP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
@@ -97,6 +123,7 @@
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.settings.KeyBinding;
 import net.minecraft.client.shader.Framebuffer;
+import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.stream.IStream;
 import net.minecraft.client.stream.NullStream;
 import net.minecraft.client.stream.TwitchStream;
@@ -127,6 +154,8 @@
 import net.minecraft.profiler.Profiler;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
+import net.minecraft.src.Config;
+import net.minecraft.src.Reflector;
 import net.minecraft.stats.AchievementList;
 import net.minecraft.stats.IStatStringFormat;
 import net.minecraft.stats.StatFileWriter;
@@ -142,6 +171,7 @@
 import net.minecraft.util.Session;
 import net.minecraft.util.Timer;
 import net.minecraft.util.Util;
+import net.minecraft.util.Vec3;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldProviderHell;
@@ -150,22 +180,22 @@
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
 import org.lwjgl.LWJGLException;
+import org.lwjgl.LWJGLUtil;
 import org.lwjgl.Sys;
+import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
-import org.lwjgl.opengl.ContextCapabilities;
-import org.lwjgl.opengl.Display;
-import org.lwjgl.opengl.DisplayMode;
-import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL20;
-import org.lwjgl.opengl.GLContext;
-import org.lwjgl.opengl.OpenGLException;
-import org.lwjgl.opengl.PixelFormat;
+import org.lwjgl.opengl.*;
 import org.lwjgl.util.glu.GLU;
+import org.lwjgl.util.vector.Quaternion;
+
+import static java.lang.Math.ceil;
 
 public class Minecraft implements IPlayerUsage
 {
@@ -181,8 +211,9 @@
     private ServerData currentServerData;
 
     /** The RenderEngine instance used by Minecraft */
-    private TextureManager renderEngine;
-
+    /** MINECRIFT FORGE **/
+	public TextureManager renderEngine;
+	/** END MINECRIFT FORGE **/
     /**
      * Set to 'this' in Minecraft constructor; used by some settings get methods
      */
@@ -304,7 +335,9 @@
     private IStream stream;
     private Framebuffer framebufferMc;
     private TextureMap textureMapBlocks;
-    private SoundHandler mcSoundHandler;
+    /** MINECRIFT */
+    public  SoundHandler mcSoundHandler; 
+    /** END MINECRIFT */
     private MusicTicker mcMusicTicker;
     private ResourceLocation mojangLogo;
     private final MinecraftSessionService sessionService;
@@ -331,9 +364,101 @@
     private String debugProfilerName = "root";
     private static final String __OBFID = "CL_00000631";
 
+    /** MINECRIFT */
+    public boolean minecriftDebug = false;
+    public final float PIOVER180 = (float)(Math.PI/180);
+    public boolean reinitFramebuffers = true;
+    public Framebuffer[] framebuffers = new Framebuffer[2];
+    public Framebuffer guiFramebuffer = null;
+    public int lastDisplayFBWidth = 0;
+    public int lastDisplayFBHeight = 0;
+    public int displayFBWidth;     /* Actual width of the display buffer */
+    public int displayFBHeight;    /* Actual height of the display buffer */
+    public int viewPortCount = 2;
+    public ShaderGroup[] shaderGroup = new ShaderGroup[2];
+    public int lastShaderIndex = -1;
+    public Object displayImpl = null;
+    public Field fieldHwnd = null;
+    public Field fieldDisplay = null;
+    public Field fieldWindow = null;
+    public Field fieldResized = null;
+    public Method fieldResizedMethod = null;
+    public IHMDInfo hmdInfo;
+    public IStereoProvider stereoProvider;
+    public IOrientationProvider headTracker;
+    public IEyePositionProvider positionTracker;
+    public IBodyAimController lookaimController;
+    public VRSettings vrSettings;
+    public MumbleLink mumbleLink;
+    public long lastIntegratedServerLaunchCheck = 0;
+    public boolean integratedServerLaunchInProgress = false;
+    public boolean resetMouse = false;
+    public boolean lastEnableVsync = true;
+    public boolean lastEnableMirror = true;
+    //public EyeRenderParams eyeRenderParams = null;
+    public EyeType currentEye = EyeType.ovrEye_Left;
+    public Posef currentEyePose = null;
+    public Cursor nativeMouseCursor = null;
+    public boolean lastShowMouseNative = true;
+    public Cursor invisibleMouseCursor = null;
+    public GLConfig glConfig = new GLConfig();
+    public long lastWindow = 0;
+    public int lastRenderDistanceChunks = -1;
+    public boolean lastFogFancy = true;
+    public boolean lastFogFast = false;
+    public float lastWorldScale = 0f;
+    public int lastDimensionId = -1;
+    public SoundManager sndManager = null;
+    public Sizei[] EyeTextureSize = new Sizei[2];
+    public boolean hydraLibsAvailable = false;
+    public double PredictedDisplayTimeSeconds = 0d;
+    public int _Lanczos_shaderProgramId = -1;
+    public int _LanczosShader_texelWidthOffsetUniform = -1;
+    public int _LanczosShader_texelHeightOffsetUniform = -1;
+    public int _LanczosShader_inputImageTextureUniform = -1;
+    public FBOParams mirrorFB = null;
+    public FBOParams[] fsaaFirstPassResultFBO = new FBOParams[2];
+    public FBOParams[] fsaaSecondPassResultFBO = new FBOParams[2];
+    public Sizei[] distortionRenderTargetSize = new Sizei[2];
+    public final float OCULUS_RED_COLOUR_COMPONENT = (1f/255f)*61f;
+    public final float OCULUS_GREEN_COLOUR_COMPONENT = (1f/255f)*61f;
+    public final float OCULUS_BLUE_COLOUR_COMPONENT = (1f/255f)*61f;
+    public float RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+    public float GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+    public float BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+    public boolean firstInit = true;
+    public boolean showSplashScreen = true;
+    public long splashTimer1 = 0;
+    public long splashTimer2 = 0;
+    public Framebuffer splash;
+    public float splashFadeAlpha = 0;
+    public int lastGuiScale = -1;
+    public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+    public long medianRunTickTimeNanos = 0;
+    public long frameIndex = 0;
+    public TextureSelector[] renderTexProvider = new TextureSelector[2];
+    public TextureSelector mirrorTexProvider;
+    public int currentDisplayWidth = 0;
+    public int currentDisplayHeight = 0;
+    public boolean visible = true;
+    public ErrorHelper errorHelper;
+    public static final String RENDER_SETUP_FAILURE_MESSAGE = "Failed to initialise stereo rendering plugin: ";
+
+    /*
+     * The minecriftVerString will be automatically updated by the build scripts, do not modify here.
+     * Modify minecriftversion.py in root minecrift dir.
+     */
+    public final String minecriftVerString = "Minecrift 1.7.10 R2-d21";
+    /* end version */
+    /** END MINECRIFT */
+
     public Minecraft(Session sessionIn, int displayWidth, int displayHeight, boolean fullscreen, boolean isDemo, File dataDir, File assetsDir, File resourcePackDir, Proxy proxy, String version, Multimap twitchDetails, String assetsJsonVersion)
     {
         theMinecraft = this;
+        /** MINECRIFT **/
+        displayWidth = 1280;
+        displayHeight = 720;
+        /** END MINECRIFT **/
         this.mcDataDir = dataDir;
         this.fileAssets = assetsDir;
         this.fileResourcepacks = resourcePackDir;
@@ -356,6 +481,12 @@
         this.jvm64bit = isJvm64bit();
         ImageIO.setUseCache(false);
         Bootstrap.register();
+        /** MINECRIFT **/
+        VRSettings.initSettings(this, this.mcDataDir);
+        renderTexProvider[0] = new TextureSelector();
+        renderTexProvider[1] = new TextureSelector();
+        mirrorTexProvider    = new TextureSelector();
+        /** END MINECRIFT **/
     }
 
     private static boolean isJvm64bit()
@@ -421,24 +552,37 @@
         File var2 = new File(getMinecraft().mcDataDir, "crash-reports");
         File var3 = new File(var2, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
         System.out.println(crashReportIn.getCompleteReport());
-
+		/** MINECRIFT FORGE **/
+        int retVal;
         if (crashReportIn.getFile() != null)
         {
             System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + crashReportIn.getFile());
-            System.exit(-1);
+            retVal = -1;
         }
         else if (crashReportIn.saveToFile(var3))
         {
             System.out.println("#@!@# Game crashed! Crash report saved to: #@!@# " + var3.getAbsolutePath());
-            System.exit(-1);
+            retVal = -1;
         }
         else
         {
             System.out.println("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
+            retVal = -2;
         }
-    }
 
+        Object fmlCommonHandler = null;
+        if( Reflector.FMLCommonHandler_instance.exists()) {
+            fmlCommonHandler = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+        }
+        if( fmlCommonHandler != null ) {
+            Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_handleExit, new Object[]{retVal});
+        }
+		else {
+			System.exit(retVal);
+		}
+		/** END MINECRIFT FORGE **/
+    }
+	
     public void setServer(String serverHostname, int serverPort)
     {
         this.serverName = serverHostname;
@@ -448,9 +592,11 @@
     /**
      * Starts the game: initializes the canvas, the title, the settings, etcetera.
      */
-    private void startGame() throws LWJGLException
+    /** MINECRIFT **/
+    private void startGame() throws Exception
     {
-        this.gameSettings = new GameSettings(this, this.mcDataDir);
+        //this.gameSettings = new GameSettings(this, this.mcDataDir);    // All settings initialised in Minecraft.minecriftFirstInit()
+    /** END MINECRIFT **/
 
         if (this.gameSettings.overrideHeight > 0 && this.gameSettings.overrideWidth > 0)
         {
@@ -480,7 +626,9 @@
         }
 
         Display.setResizable(true);
-        Display.setTitle("Minecraft 1.7.10");
+        /** MINECRIFT */
+        Display.setTitle(this.minecriftVerString + " VR");
+        /** END MINECRIFT */
         logger.info("LWJGL Version: " + Sys.getVersion());
         Util.EnumOS var1 = Util.getOSType();
 
@@ -504,7 +652,14 @@
 
         try
         {
-            Display.create((new PixelFormat()).withDepthBits(24));
+			/** MINECRIFT FORGE **/
+            if (Reflector.ForgeHooksClient_createDisplay.exists()) {
+                Reflector.callVoid(Reflector.ForgeHooksClient_createDisplay, new Object[0]);
+			}
+			else {
+				Display.create((new PixelFormat()).withDepthBits(24));
+			}
+			/** END MINECRIFT FORGE **/
         }
         catch (LWJGLException var7)
         {
@@ -552,11 +707,33 @@
         this.mcResourceManager = new SimpleReloadableResourceManager(this.metadataSerializer_);
         this.mcLanguageManager = new LanguageManager(this.metadataSerializer_, this.gameSettings.language);
         this.mcResourceManager.registerReloadListener(this.mcLanguageManager);
-        this.refreshResources();
+		/** MINECRIFT FORGE **/
+        Object fmlClientHandler = null;
+        if( Reflector.FMLClientHandler_instance.exists())
+        {
+            fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+        }
+        if( fmlClientHandler != null)
+        {
+            Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_beginMinecraftLoading, new Object[] {this, this.defaultResourcePacks, this.mcResourceManager});
+        }
+		else {
+			this.refreshResources();
+		}
+		/** END MINECRIFT FORGE **/
         this.renderEngine = new TextureManager(this.mcResourceManager);
         this.mcResourceManager.registerReloadListener(this.renderEngine);
         this.skinManager = new SkinManager(this.renderEngine, new File(this.fileAssets, "skins"), this.sessionService);
-        this.loadScreen();
+		/** MINECRIFT FORGE **/
+        boolean Forge = Reflector.forgeExists();
+        if (Forge) {
+            //cpw.mods.fml.client.SplashProgress.drawVanillaScreen();
+            Reflector.callVoid(Reflector.FMLClientSplashProgress_drawVanillaScreen, new Object[] {});
+		}
+		else {
+			this.loadScreen();
+		}
+		/** END MINECRIFT FORGE **/
         this.mcSoundHandler = new SoundHandler(this.mcResourceManager, this.gameSettings);
         this.mcResourceManager.registerReloadListener(this.mcSoundHandler);
         this.mcMusicTicker = new MusicTicker(this);
@@ -567,13 +744,30 @@
             this.fontRendererObj.setUnicodeFlag(this.isUnicode());
             this.fontRendererObj.setBidiFlag(this.mcLanguageManager.isCurrentLanguageBidirectional());
         }
-
+        /** MINECRIFT */
+        initMinecrift();
+        /** END MINECRIFT */
         this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii_sga.png"), this.renderEngine, false);
         this.mcResourceManager.registerReloadListener(this.fontRendererObj);
         this.mcResourceManager.registerReloadListener(this.standardGalacticFontRenderer);
         this.mcResourceManager.registerReloadListener(new GrassColorReloadListener());
         this.mcResourceManager.registerReloadListener(new FoliageColorReloadListener());
+		/** MINECRIFT FORGE **/
+        Object bar = null;
+        if (Forge) {
+            //cpw.mods.fml.common.ProgressManager.ProgressBar bar = cpw.mods.fml.common.ProgressManager.push("Rendering Setup", 9);
+            //bar.step("Loading Render Manager");
+            bar = Reflector.call(Reflector.FMLCommonProgressManager_push, new Object[] {"Rendering Setup", 9});
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Render Manager"});
+		}
+		/** END MINECRIFT FORGE **/
         RenderManager.instance.itemRenderer = new ItemRenderer(this);
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Loading Entity Renderer");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Entity Renderer"});
+		}
+		/** END MINECRIFT FORGE **/		
         this.entityRenderer = new EntityRenderer(this, this.mcResourceManager);
         this.mcResourceManager.registerReloadListener(this.entityRenderer);
         AchievementList.openInventory.setStatStringFormatter(new IStatStringFormat()
@@ -591,6 +785,12 @@
                 }
             }
         });
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Loading GL properties");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading GL properties"});
+		}
+		/** END MINECRIFT FORGE **/
         this.mouseHelper = new MouseHelper();
         this.checkGLError("Pre startup");
         GL11.glEnable(GL11.GL_TEXTURE_2D);
@@ -605,30 +805,115 @@
         GL11.glLoadIdentity();
         GL11.glMatrixMode(GL11.GL_MODELVIEW);
         this.checkGLError("Startup");
+        /** MINECRIFT SHADERS MOD **/
+        if (Reflector.shadersModExists()) {
+            //Shaders.startup(this);
+            Reflector.callVoid(Reflector.ShadersMod_Shaders_startup, new Object[] {this});
+        }
+        /** END MINECRIFT SHADERS MOD **/
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Render Global instance");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Render Global instance"});
+		}
+		/** END MINECRIFT FORGE **/		
         this.renderGlobal = new RenderGlobal(this);
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Building Blocks Texture");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Building Blocks Texture"});
+		}
+		/** END MINECRIFT FORGE **/		
         this.textureMapBlocks = new TextureMap(0, "textures/blocks");
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Anisotropy and Mipmaps");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Anisotropy and Mipmaps"});
+		}
+		/** END MINECRIFT FORGE **/		
         this.textureMapBlocks.setAnisotropicFiltering(this.gameSettings.anisotropicFiltering);
         this.textureMapBlocks.setMipmapLevels(this.gameSettings.mipmapLevels);
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Loading Blocks Texture");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Entity Renderer"});
+		}
+		/** END MINECRIFT FORGE **/		
         this.renderEngine.loadTextureMap(TextureMap.locationBlocksTexture, this.textureMapBlocks);
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Loading Items Texture");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Loading Items Texture"});
+		}
+		/** END MINECRIFT FORGE **/
         this.renderEngine.loadTextureMap(TextureMap.locationItemsTexture, new TextureMap(1, "textures/items"));
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//bar.step("Viewport");
+            Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, new Object[] {"Viewport"});
+		}
+		/** END MINECRIFT FORGE **/
         GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
         this.effectRenderer = new EffectRenderer(this.theWorld, this.renderEngine);
+        /** MINECRIFT FORGE **/
+		if( fmlClientHandler != null )
+        {
+			//cpw.mods.fml.common.ProgressManager.pop(bar);
+            Reflector.callVoid(Reflector.FMLCommonProgressManager_pop, new Object[]{bar});
+            Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_finishMinecraftLoading, new Object[0]);
+        }
         this.checkGLError("Post startup");
+        if( Reflector.ForgeGuiIngame.exists())
+        {
+            try {
+                this.ingameGUI = (GuiIngame)Reflector.ForgeGuiIngame_Constructor.getTargetConstructor().newInstance(new Object[]{this});
+            } catch (IllegalArgumentException e) {
+                e.printStackTrace();
+            } catch (InstantiationException e) {
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                e.printStackTrace();
+            } catch (InvocationTargetException e) {
+                e.printStackTrace();
+            }
+        }
+        else
+        {
         this.ingameGUI = new GuiIngame(this);
+        }
 
         if (this.serverName != null)
         {
+            if( fmlClientHandler != null ) {
+                Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_connectToServerAtStartup, new Object[]{this.serverName, this.serverPort});
+            }
+			else {
             this.displayGuiScreen(new GuiConnecting(new GuiMainMenu(), this, this.serverName, this.serverPort));
+			}
         }
         else
         {
             this.displayGuiScreen(new GuiMainMenu());
         }
+		/** END MINECRIFT FORGE **/
 
-        this.renderEngine.deleteTexture(this.mojangLogo);
+		/** MINECRIFT FORGE **/
+        if (Forge) {
+			//cpw.mods.fml.client.SplashProgress.clearVanillaResources(renderEngine, mojangLogo);
+            Reflector.callVoid(Reflector.FMLClientSplashProgress_clearVanillaResources, new Object[] {renderEngine, mojangLogo});
+		}
+		else {
+	        this.renderEngine.deleteTexture(this.mojangLogo);
+		}
+		/** END MINECRIFT FORGE **/
         this.mojangLogo = null;
         this.loadingScreen = new LoadingScreenRenderer(this);
 
+		/** MINECRIFT FORGE **/
+        if( fmlClientHandler != null ) {
+            Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_onInitializationComplete, new Object[0]);
+        }
+		/** END MINECRIFT FORGE **/
         if (this.gameSettings.fullScreen && !this.fullscreen)
         {
             this.toggleFullscreen();
@@ -636,7 +921,11 @@
 
         try
         {
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
+            /** MINECRIFT */
+        	//vsync needs to be false that showing the mirror image doesn't slow down the rendering for the rift.
+        	//Oculus SDK handles vsync internally
+            Display.setVSyncEnabled(false);
+            /** END MINECRIFT */
         }
         catch (OpenGLException var4)
         {
@@ -782,8 +1071,8 @@
         GL11.glDisable(GL11.GL_FOG);
         GL11.glDisable(GL11.GL_DEPTH_TEST);
         GL11.glEnable(GL11.GL_TEXTURE_2D);
-
-        try
+/** MINECRIFT */       // TODO REFACTOR! The loadScreen mods here and below are just to clear the screen to white... !
+/*      try
         {
             this.mojangLogo = this.renderEngine.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(this.mcDefaultResourcePack.getInputStream(locationMojangPng))));
             this.renderEngine.bindTexture(this.mojangLogo);
@@ -791,8 +1080,8 @@
         catch (IOException var7)
         {
             logger.error("Unable to load logo: " + locationMojangPng, var7);
-        }
-
+        }*/
+/** END MINECRIFT */
         Tessellator var4 = Tessellator.instance;
         var4.startDrawingQuads();
         var4.setColorOpaque_I(16777215);
@@ -813,6 +1102,9 @@
         GL11.glEnable(GL11.GL_ALPHA_TEST);
         GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
         GL11.glFlush();
+		/** MINECRIFT */
+        Display.update();
+        /** END MINECRIFT */
         this.resetSize();
     }
 
@@ -845,7 +1137,8 @@
      */
     public void displayGuiScreen(GuiScreen guiScreenIn)
     {
-        if (this.currentScreen != null)
+		/** MINECRIFT FORGE **/
+        if (!Reflector.forgeExists() && this.currentScreen != null)
         {
             this.currentScreen.onGuiClosed();
         }
@@ -858,6 +1151,21 @@
         {
             guiScreenIn = new GuiGameOver();
         }
+		
+        if (Reflector.forgeExists())
+        {
+            GuiScreen old = this.currentScreen;
+            Object event = Reflector.newInstance(Reflector.ForgeGuiOpenEvent_Constructor, new Object[] {guiScreenIn});
+
+            if (Reflector.postForgeBusEvent(event)) return;
+
+            guiScreenIn = (GuiScreen)Reflector.getFieldValue(event, Reflector.ForgeGuiOpenEvent_gui);
+            if (old != null && guiScreenIn != old)
+            {
+                old.onGuiClosed();
+            }
+        }
+		/** END MINECRIFT FORGE **/
 
         if (guiScreenIn instanceof GuiMainMenu)
         {
@@ -870,7 +1178,7 @@
         if (guiScreenIn != null)
         {
             this.setIngameNotInFocus();
-            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+            ScaledResolution var2 = new ScaledResolution(this, this.displayWidth, this.displayHeight);  /** Minecrift **/
             int var3 = var2.getScaledWidth();
             int var4 = var2.getScaledHeight();
             ((GuiScreen)guiScreenIn).setWorldAndResolution(this, var3, var4);
@@ -886,7 +1194,9 @@
     /**
      * Checks for an OpenGL error. If there is one, prints the error ID and error string.
      */
-    private void checkGLError(String message)
+    /** MINECRIFT */ 
+    public void checkGLError(String message)
+    /** END MINECRIFT */
     {
         int var2 = GL11.glGetError();
 
@@ -1016,8 +1326,11 @@
     /**
      * Called repeatedly from run()
      */
-    private void runGameLoop()
+    /** MINECRIFT */
+    private void runGameLoop() throws Exception
+    /** END MINECRIFT */
     {
+        try {
         this.mcProfiler.startSection("root");
 
         if (Display.isCreated() && Display.isCloseRequested())
@@ -1025,6 +1338,10 @@
             this.shutdown();
         }
 
+        /** MINECRIFT */ // setup the display, render buffers, shaders etc.
+        this.frameIndex++;
+        setupRenderConfiguration();
+        /** END MINECRIFT */
         if (this.isGamePaused && this.theWorld != null)
         {
             float var1 = this.timer.renderPartialTicks;
@@ -1042,77 +1359,183 @@
             this.refreshResources();
         }
 
+        /** MINECRIFT */
         long var5 = System.nanoTime();
-        this.mcProfiler.startSection("tick");
+        long var6 = 0;
+        int ticks = 0;
 
-        for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
-        {
-            this.runTick();
+        if (!this.integratedServerLaunchInProgress)
+		{
+            this.mcProfiler.startSection("tick");
+
+            enableGuiSizeHack();
+
+            for (int var3 = 0; var3 < this.timer.elapsedTicks; ++var3)
+            {
+                this.runTick();
+                ticks++;
+            }
+
+            disableGuiSizeHack();
+
+            var6 = System.nanoTime() - var5;
+
+            // Test to see if render config change is requested. If so,
+            // update framebuffers
+            setupRenderConfiguration();
+        }
+
+        if (vrSettings.smoothTick) {
+            if (ticks > 0) {
+                addRunTickTimeNanos(var6 / ticks);
+            } else {
+                long sleepTimeNanos = getMedianRunTickTimeNanos();
+                sleepNanos(sleepTimeNanos);
+            }
         }
 
+        var6 = System.nanoTime() - var5;
         this.mcProfiler.endStartSection("preRenderErrors");
-        long var6 = System.nanoTime() - var5;
-        this.checkGLError("Pre render");
+        //long var6 = System.nanoTime() - var5;
+        //this.checkGLError("Pre render");
         RenderBlocks.fancyGrass = this.gameSettings.fancyGraphics;
         this.mcProfiler.endStartSection("sound");
         this.mcSoundHandler.setListener(this.thePlayer, this.timer.renderPartialTicks);
         this.mcProfiler.endSection();
         this.mcProfiler.startSection("render");
-        GL11.glPushMatrix();
-        GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
-        this.framebufferMc.bindFramebuffer(true);
-        this.mcProfiler.startSection("display");
-        GL11.glEnable(GL11.GL_TEXTURE_2D);
-
-        if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
-        {
-            this.gameSettings.thirdPersonView = 0;
-        }
-
-        this.mcProfiler.endSection();
 
-        if (!this.skipRenderWorld)
-        {
-            this.mcProfiler.endStartSection("gameRenderer");
-            this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
-            this.mcProfiler.endSection();
-        }
-
-        GL11.glFlush();
-        this.mcProfiler.endSection();
+        // Render GUI to FBO if necessary
+        this.entityRenderer.renderVrGui(this.timer.renderPartialTicks);
 
-        if (!Display.isActive() && this.fullscreen)
-        {
-            this.toggleFullscreen();
+        // TODO: PollAll can call controller code that updates the GUI.
+        // All controller code should be moved to UpdateTick really. For
+        // now, hack the displaySize so that any gui screens changed use
+        // the correct size...
+        enableGuiSizeHack();
+
+        // Mark beginning of frame AFTER any GUI rendering to allow maximum
+        // latency reduction
+        PluginManager.beginFrameAll(frameIndex);
+
+        // Poll sensors
+        if (!this.vrSettings.testTimewarp) {
+            PluginManager.pollAll(frameIndex);
+            PredictedDisplayTimeSeconds = this.stereoProvider.getFrameTiming();
+        }
+
+        // End display size hack
+        disableGuiSizeHack();
+
+        if (minecriftDebug) print("FrameIndex: " + frameIndex);
+        renderTexProvider[0].setFrameIndex(frameIndex);
+        renderTexProvider[1].setFrameIndex(frameIndex);
+
+        /** Minecrift - main stereo render loop **/
+        for (int i = 0; this.visible && i < viewPortCount; i++)
+        {
+            this.currentEye = this.stereoProvider.eyeRenderOrder(i);
+            this.framebufferMc = framebuffers[this.currentEye.value()];
+
+            this.stereoProvider.setCurrentRenderTextureInfo(
+                    this.currentEye.value(),
+                    renderTexProvider[this.currentEye.value()].getCurrentSwapIdx(),
+                    this.framebufferMc.depthBuffer,
+                    this.framebufferMc.framebufferTextureWidth,
+                    this.framebufferMc.framebufferTextureHeight);
+            this.framebufferMc.bindFramebuffer(true);
+            this.framebufferMc.selectTexture();
+
+            if (this.entityRenderer != null)
+            {
+                this.entityRenderer.renderpass = i;
+                this.entityRenderer.theShaderGroup = shaderGroup[this.currentEye.value()];
+            }
+
+            this.displayWidth = this.EyeTextureSize[this.currentEye.value()].w;
+            this.displayHeight = this.EyeTextureSize[this.currentEye.value()].h;
+
+            currentEyePose = getEyePose(this.currentEye);
+            //System.out.println("Posef (" + this.currentEye.toString() + "): " + currentEyePose.toString());
+
+	        GL11.glPushMatrix();
+	        GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+	        //this.framebufferMc.bindFramebuffer(true);
+	        this.mcProfiler.startSection("display");
+	        GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+	        if (this.thePlayer != null && this.thePlayer.isEntityInsideOpaqueBlock())
+	        {
+	            this.gameSettings.thirdPersonView = 0;
+	        }
+
+	        this.mcProfiler.endSection();
+
+	        // Update our orientation and position variables from the sensor polled data
+	        this.entityRenderer.updatePositionAndOrientation(this.timer.renderPartialTicks, Display.isActive());
+
+	        if (!this.skipRenderWorld)
+	        {
+				/** MINECRIFT FORGE **/
+	            Object fmlCommonHandler = null;
+	            if (Reflector.FMLCommonHandler_instance.exists()) {
+	                fmlCommonHandler = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+	            }
+	            if (fmlCommonHandler != null) {
+	                Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickStart, new Object[]{this.timer.renderPartialTicks});
+	            }
+	            this.mcProfiler.endStartSection("gameRenderer");
+	            this.entityRenderer.updateCameraAndRender(this.timer.renderPartialTicks);
+	            this.mcProfiler.endSection();
+	            if (fmlCommonHandler != null) {
+	                Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onRenderTickEnd, new Object[]{this.timer.renderPartialTicks});
+	            }
+				/** END MINECRIFT FORGE **/
+	        }
+
+	        //GL11.glFlush();
+	        //this.mcProfiler.endSection();
+
+	        //if (!Display.isActive() && this.fullscreen)
+	        //{
+	        //    this.toggleFullscreen();
+	        //}
+
+	        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)    // <-- TODO: Move; needs to be overlayed over GUI FBO
+	        {
+	            if (!this.mcProfiler.profilingEnabled)
+	            {
+	                this.mcProfiler.clearProfiling();
+	            }
+
+	            this.mcProfiler.profilingEnabled = true;
+	            this.displayDebugInfo(var6);
+	        }
+	        else
+	        {
+	            this.mcProfiler.profilingEnabled = false;
+	            this.prevFrameTime = System.nanoTime();
+	        }
+
+            //this.guiAchievement.updateAchievementWindow();  // <-- TODO: Move; needs to be overlayed over GUI FBO
+            //this.framebufferMc.unbindFramebuffer();
+            GL11.glPopMatrix();
+            GL11.glPushMatrix();
+            //this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+
+            doPostProcessing(frameIndex, this.currentEye);
+
+            GL11.glPopMatrix();
+            GL11.glPushMatrix();
+            //this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);   // <-- TODO: What does this do? Some sort of stream status overlay? REENABLE, move to GUI FBO?
+            GL11.glPopMatrix();
         }
 
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart)
-        {
-            if (!this.mcProfiler.profilingEnabled)
-            {
-                this.mcProfiler.clearProfiling();
-            }
-
-            this.mcProfiler.profilingEnabled = true;
-            this.displayDebugInfo(var6);
-        }
-        else
-        {
-            this.mcProfiler.profilingEnabled = false;
-            this.prevFrameTime = System.nanoTime();
-        }
+        this.visible = endFrame();
 
-        this.guiAchievement.updateAchievementWindow();
-        this.framebufferMc.unbindFramebuffer();
-        GL11.glPopMatrix();
-        GL11.glPushMatrix();
-        this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
-        GL11.glPopMatrix();
-        GL11.glPushMatrix();
-        this.entityRenderer.func_152430_c(this.timer.renderPartialTicks);
-        GL11.glPopMatrix();
+        copyToMirror();
+        //this.checkGLError("endFrame");
         this.mcProfiler.startSection("root");
-        this.resetSize();
+        //this.resetSize();  // Now handled in setup setupRenderConfiguration
         Thread.yield();
         this.mcProfiler.startSection("stream");
         this.mcProfiler.startSection("update");
@@ -1121,9 +1544,10 @@
         this.stream.func_152922_k();
         this.mcProfiler.endSection();
         this.mcProfiler.endSection();
-        this.checkGLError("Post render");
+        //this.checkGLError("Post render");
         ++this.fpsCounter;
         this.isGamePaused = this.isSingleplayer() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame() && !this.theIntegratedServer.getPublic();
+/** END MINECRIFT */
 
         while (getSystemTime() >= this.debugUpdateTime + 1000L)
         {
@@ -1141,11 +1565,28 @@
         }
 
         this.mcProfiler.endSection();
-
-        if (this.isFramerateLimitBelowMax())
-        {
-            Display.sync(this.getLimitFramerate());
+/** MINECRIFT */
+//        if (this.isFramerateLimitBelowMax())
+//        {
+//            Display.sync(this.getLimitFramerate());  // <-- Minecrift - Don't limit fps
+//        }
+        }
+        catch (RenderConfigException e) {
+            // set mono provider
+            vrSettings.stereoProviderPluginID = "mono";
+            vrSettings.saveOptions();
+            try {
+                stereoProvider = PluginManager.configureStereoProvider(vrSettings.stereoProviderPluginID);
+            }
+            catch (Exception ex) {
+                ex.printStackTrace();
+            }
+
+            // set error
+            this.errorHelper = new ErrorHelper(e.title, e.error, "Reverted to mono renderer!", 15);
+            e.printStackTrace();
         }
+/** END MINECRIFT */
     }
 
     /**
@@ -1153,35 +1594,40 @@
      */
     public void resetSize()
     {
-        Display.update();
-
-        if (!this.fullscreen && Display.wasResized())
-        {
-            int var1 = this.displayWidth;
-            int var2 = this.displayHeight;
-            this.displayWidth = Display.getWidth();
-            this.displayHeight = Display.getHeight();
-
-            if (this.displayWidth != var1 || this.displayHeight != var2)
-            {
-                if (this.displayWidth <= 0)
-                {
-                    this.displayWidth = 1;
-                }
-
-                if (this.displayHeight <= 0)
-                {
-                    this.displayHeight = 1;
-                }
-
-                this.resize(this.displayWidth, this.displayHeight);
-            }
-        }
+/** MINECRIFT */
+        this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+//        Display.update();
+//
+//        if (!this.fullscreen && Display.wasResized())
+//        {
+//            int i = this.displayWidth;
+//            int j = this.displayHeight;
+//            this.displayWidth = Display.getWidth();
+//            this.displayHeight = Display.getHeight();
+//
+//            if (this.displayWidth != i || this.displayHeight != j)
+//            {
+//                if (this.displayWidth <= 0)
+//                {
+//                    this.displayWidth = 1;
+//                }
+//
+//                if (this.displayHeight <= 0)
+//                {
+//                    this.displayHeight = 1;
+//                }
+//
+//                this.resize(this.displayWidth, this.displayHeight);
+//            }
+//        }
+/** END MINECRIFT */
     }
 
     public int getLimitFramerate()
     {
-        return this.theWorld == null && this.currentScreen != null ? 30 : this.gameSettings.limitFramerate;
+        /** MINECRIFT */
+        return this.gameSettings.limitFramerate;   // Do not limit the framerate in menus!
+        /** END MINECRIFT */
     }
 
     public boolean isFramerateLimitBelowMax()
@@ -1467,8 +1913,9 @@
             }
         }
     }
-
-    private void clickMouse()
+    /** MINECRIFT */
+    public void clickMouse()
+    /** END MINECRIFT */
     {
         if (this.leftClickCounter <= 0)
         {
@@ -1476,7 +1923,9 @@
 
             if (this.objectMouseOver == null)
             {
-                logger.error("Null returned as \'hitResult\', this shouldn\'t happen!");
+                /** MINECRIFT */
+                //logger.error("Null returned as \'hitResult\', this shouldn\'t happen!");
+                /** END MINECRIFT */
 
                 if (this.playerController.isNotCreative())
                 {
@@ -1515,7 +1964,9 @@
     /**
      * Called when user clicked he's mouse right button (place)
      */
-    private void rightClickMouse()
+	/** MINECRIFT */ 
+    public void rightClickMouse()
+	/** END MINECRIFT */
     {
         this.rightClickDelayTimer = 4;
         boolean var1 = true;
@@ -1523,7 +1974,9 @@
 
         if (this.objectMouseOver == null)
         {
-            logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
+            /** MINECRIFT */
+            //logger.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
+            /** END MINECRIFT */
         }
         else
         {
@@ -1546,7 +1999,14 @@
                     {
                         int var6 = var2 != null ? var2.stackSize : 0;
 
-                        if (this.playerController.onPlayerRightClick(this.thePlayer, this.theWorld, var2, var3, var4, var5, this.objectMouseOver.sideHit, this.objectMouseOver.hitVec))
+						boolean result = true;
+						/** MINECRIFT FORGE **/
+						if (Reflector.forgeExists()) {
+						    Object event = Reflector.call(Reflector.ForgeEventFactory_onPlayerInteract, new Object[] {thePlayer, Reflector.ForgePlayerInteractEvent_Action_RIGHT_CLICK_BLOCK.getValue(), var3, var4, var5, this.objectMouseOver.sideHit, this.theWorld});
+                            result = !Reflector.callBoolean(event, Reflector.ForgeEvent_isCanceled, new Object[0]);
+						}
+						/** END MINECRIFT FORGE **/
+                        if (result && this.playerController.onPlayerRightClick(this.thePlayer, this.theWorld, var2, var3, var4, var5, this.objectMouseOver.sideHit, this.objectMouseOver.hitVec))
                         {
                             var1 = false;
                             this.thePlayer.swingItem();
@@ -1573,7 +2033,14 @@
         {
             ItemStack var7 = this.thePlayer.inventory.getCurrentItem();
 
-            if (var7 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var7))
+			boolean result = true;
+			/** MINECRIFT FORGE **/
+            if (Reflector.forgeExists()) {
+                Object event = Reflector.call(Reflector.ForgeEventFactory_onPlayerInteract, new Object[] {thePlayer, Reflector.ForgePlayerInteractEvent_Action_RIGHT_CLICK_AIR.getValue(), 0, 0, 0, -1, this.theWorld});
+                result = !Reflector.callBoolean(event, Reflector.ForgeEvent_isCanceled, new Object[0]);
+            }
+			/** END MINECRIFT FORGE **/
+            if (result && var7 != null && this.playerController.sendUseItem(this.thePlayer, this.theWorld, var7))
             {
                 this.entityRenderer.itemRenderer.resetEquippedProgress2();
             }
@@ -1632,8 +2099,10 @@
             }
 
             Display.setFullscreen(this.fullscreen);
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
-            this.resetSize();
+            /** MINECRIFT */
+            Display.setVSyncEnabled(false);
+			this.resetSize();
+            /** END MINECRIFT */
         }
         catch (Exception var2)
         {
@@ -1646,29 +2115,23 @@
      */
     private void resize(int width, int height)
     {
-        this.displayWidth = width <= 0 ? 1 : width;
-        this.displayHeight = height <= 0 ? 1 : height;
+        /** MINECRIFT */
+        this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+        /** END MINECRIFT */
 
-        if (this.currentScreen != null)
-        {
-            ScaledResolution var3 = new ScaledResolution(this, width, height);
-            int var4 = var3.getScaledWidth();
-            int var5 = var3.getScaledHeight();
-            this.currentScreen.setWorldAndResolution(this, var4, var5);
-        }
-
-        this.loadingScreen = new LoadingScreenRenderer(this);
-        this.updateFramebufferSize();
     }
 
     private void updateFramebufferSize()
     {
-        this.framebufferMc.createBindFramebuffer(this.displayWidth, this.displayHeight);
+        /** MINECRIFT */
+        this.reinitFramebuffers = true;    // Screen resize now performed in setupRenderConfiguration
+/*      this.framebufferMc.createBindFramebuffer(this.displayWidth, this.displayHeight);
 
         if (this.entityRenderer != null)
         {
             this.entityRenderer.updateShaderGroupSize(this.displayWidth, this.displayHeight);
-        }
+        }*/
+        /** END MINECRIFT */
     }
 
     /**
@@ -1693,11 +2156,24 @@
         {
             --this.rightClickDelayTimer;
         }
+		/** MINECRIFT FORGE **/
+        Object fmlCommonHandler = null;
+        if( Reflector.FMLCommonHandler_instance.exists()) {
+            fmlCommonHandler = Reflector.call( Reflector.FMLCommonHandler_instance, new Object[0]);
+        }
+        if( fmlCommonHandler != null) {
+            Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPreClientTick, new Object[0]);
+        }
+		/** END MINECRIFT FORGE **/
 
         this.mcProfiler.startSection("gui");
 
         if (!this.isGamePaused)
         {
+            /** MINECRIFT */
+//            if( JoystickAim.selectedJoystickMode != null )
+//                JoystickAim.selectedJoystickMode.updateTick();
+            /** END MINECRIFT */
             this.ingameGUI.updateTick();
         }
 
@@ -1719,6 +2195,10 @@
 
         if (this.currentScreen == null && this.thePlayer != null)
         {
+            /** MINECRIFT */
+            this.thePlayer.stepHeight = this.vrSettings.walkUpBlocks ? 1f : 0.5f;
+            /** END MINECRIFT */
+
             if (this.thePlayer.getHealth() <= 0.0F)
             {
                 this.displayGuiScreen((GuiScreen)null);
@@ -1792,6 +2272,12 @@
 
             while (Mouse.next())
             {
+				/** MINECRIFT FORGE **/
+                if (Reflector.ForgeHooksClient_postMouseEvent.exists()) {
+                    if (Reflector.callBoolean(Reflector.ForgeHooksClient_postMouseEvent, new Object[0])) continue;
+                }
+				/** END MINECRIFT FORGE **/
+
                 var9 = Mouse.getEventButton();
                 KeyBinding.setKeyBindState(var9 - 100, Mouse.getEventButtonState());
 
@@ -1838,6 +2324,11 @@
                         this.currentScreen.handleMouseInput();
                     }
                 }
+				/** MINECRIFT FORGE **/
+                if( fmlCommonHandler != null) {
+                    Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_fireMouseInput, new Object[0]);
+                }
+				/** END MINECRIFT FORGE **/
             }
 
             if (this.leftClickCounter > 0)
@@ -1889,6 +2380,10 @@
                     }
                     else
                     {
+						/** MINECRIFT */
+                        VRHotkeys.handleKeyboardInputs(this);
+						/** END MINECRIFT */
+
                         if (Keyboard.getEventKey() == 1)
                         {
                             this.displayInGameMenu();
@@ -1932,10 +2427,12 @@
                             this.gameSettings.saveOptions();
                         }
 
+                        /** MINECRIFT **/
                         if (Keyboard.getEventKey() == 59)
                         {
-                            this.gameSettings.hideGUI = !this.gameSettings.hideGUI;
+                            this.vrSettings.hideGui = !this.vrSettings.hideGui;
                         }
+                        /** END MINECRIFT **/
 
                         if (Keyboard.getEventKey() == 61)
                         {
@@ -1975,6 +2472,11 @@
                         }
                     }
                 }
+				/** MINECRIFT FORGE **/
+                if( fmlCommonHandler != null) {
+                    Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_fireKeyInput, new Object[0]);
+                }
+				/** END MINECRIFT FORGE **/
             }
 
             for (var9 = 0; var9 < 9; ++var9)
@@ -2070,6 +2572,12 @@
 
             this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.getIsKeyPressed() && this.inGameHasFocus);
         }
+        /** MINECRIFT */
+        else
+        {
+            VRHotkeys.handleKeyboardInputs(this);
+        }
+        /** END MINECRIFT */
 
         if (this.theWorld != null)
         {
@@ -2164,7 +2672,11 @@
             this.mcProfiler.endStartSection("pendingConnection");
             this.myNetworkManager.processReceivedPackets();
         }
-
+		/** MINECRIFT FORGE **/
+        if( fmlCommonHandler != null) {
+            Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPostClientTick, new Object[0]);
+        }
+		/** END MINECRIFT FORGE **/
         this.mcProfiler.endSection();
         this.systemTime = getSystemTime();
     }
@@ -2174,6 +2686,15 @@
      */
     public void launchIntegratedServer(String folderName, String worldName, WorldSettings worldSettingsIn)
     {
+		/** MINECRIFT FORGE **/
+        Object fmlClientHandler = null;
+        if( Reflector.FMLClientHandler_instance.exists()) {
+            fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+        }
+        if( fmlClientHandler != null) {
+            Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_startIntegratedServer, new Object[] {folderName, worldName, worldSettingsIn});
+        }
+		/** END MINECRIFT FORGE **/
         this.loadWorld((WorldClient)null);
         System.gc();
         ISaveHandler var4 = this.saveLoader.getSaveLoader(folderName, false);
@@ -2207,37 +2728,81 @@
 
         this.loadingScreen.displaySavingString(I18n.format("menu.loadingLevel", new Object[0]));
 
-        while (!this.theIntegratedServer.serverIsInRunLoop())
+/** MINECRIFT */
+        // Exit now. Server launch progress will be checked periodically.
+        this.lastIntegratedServerLaunchCheck = System.currentTimeMillis();
+        this.integratedServerLaunchInProgress = true;
+    }
+
+    public boolean isIntegratedServerLaunching()
+    {
+        if (!this.integratedServerLaunchInProgress)
+            return false;
+
+        if (!this.theIntegratedServer.serverIsInRunLoop())
         {
-            String var6 = this.theIntegratedServer.getUserMessage();
+            long currentTime = System.currentTimeMillis();
 
-            if (var6 != null)
-            {
-                this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
-            }
-            else
+            if (currentTime - lastIntegratedServerLaunchCheck > 200L)
             {
-                this.loadingScreen.displayLoadingString("");
-            }
+                this.lastIntegratedServerLaunchCheck = currentTime;
+				/** MINECRIFT FORGE **/
+                if (Reflector.FMLStartupQuery_check.exists())
+                {
+                    if (!Reflector.callBoolean(Reflector.FMLStartupQuery_check, new Object[0]))
+                    {
+                        loadWorld(null);
+                        displayGuiScreen(null);
+                        this.lastIntegratedServerLaunchCheck = 0;
+                        this.integratedServerLaunchInProgress = false;
+                        return false;
+                    }
+                }
+				/** END MINECRIFT FORGE **/
 
-            try
-            {
-                Thread.sleep(200L);
-            }
-            catch (InterruptedException var9)
-            {
-                ;
+	            String var6 = this.theIntegratedServer.getUserMessage();
+
+	            if (var6 != null)
+	            {
+	                this.loadingScreen.displayLoadingString(I18n.format(var6, new Object[0]));
+	            }
+                else
+                {
+                    this.loadingScreen.displayLoadingString("");
+                }
+
+                // Wait & loop not used
+                //try
+                //{
+                //    Thread.sleep(200L);
+                //}
+                //catch (InterruptedException interruptedexception)
+                //{
+                //    ;
+                //}
             }
+
+            return true;
         }
+        else
+        {
+            this.lastIntegratedServerLaunchCheck = 0;
+            this.integratedServerLaunchInProgress = false;
 
-        this.displayGuiScreen((GuiScreen)null);
-        SocketAddress var11 = this.theIntegratedServer.getNetworkSystem().addLocalEndpoint();
-        NetworkManager var12 = NetworkManager.provideLocalClient(var11);
-        var12.setNetHandler(new NetHandlerLoginClient(var12, this, (GuiScreen)null));
-        var12.scheduleOutboundPacket(new C00Handshake(5, var11.toString(), 0, EnumConnectionState.LOGIN), new GenericFutureListener[0]);
-        var12.scheduleOutboundPacket(new C00PacketLoginStart(this.getSession().getProfile()), new GenericFutureListener[0]);
-        this.myNetworkManager = var12;
+            // Ideally the network stuff below would also be part of the integrated server
+            // launch, i.e. on it's own thread
+            this.displayGuiScreen((GuiScreen) null);
+	        SocketAddress var11 = this.theIntegratedServer.getNetworkSystem().addLocalEndpoint();
+	        NetworkManager var12 = NetworkManager.provideLocalClient(var11);
+	        var12.setNetHandler(new NetHandlerLoginClient(var12, this, (GuiScreen)null));
+	        var12.scheduleOutboundPacket(new C00Handshake(5, var11.toString(), 0, EnumConnectionState.LOGIN), new GenericFutureListener[0]);
+	        var12.scheduleOutboundPacket(new C00PacketLoginStart(this.getSession().getProfile()), new GenericFutureListener[0]);
+	        this.myNetworkManager = var12;
+
+            return false;
+        }
     }
+/** END MINECRIFT */
 
     /**
      * unloads the current world first
@@ -2252,6 +2817,13 @@
      */
     public void loadWorld(WorldClient worldClientIn, String loadingMessage)
     {
+		/** MINECRIFT FORGE **/
+        if (worldClientIn != null && Reflector.EventBus.exists())
+        {
+            Reflector.postForgeBusEvent(Reflector.ForgeWorldEvent_Unload_Constructor, new Object[] {this.theWorld});
+        }
+		/** END MINECRIFT FORGE **/
+
         if (worldClientIn == null)
         {
             NetHandlerPlayClient var3 = this.getNetHandler();
@@ -2264,6 +2836,23 @@
             if (this.theIntegratedServer != null)
             {
                 this.theIntegratedServer.initiateShutdown();
+				/** MINECRIFT FORGE **/
+				if (Reflector.ForgeIntegratedServer_isServerStopped.exists())
+				{
+	                if (loadingScreen != null)
+	                {
+                    	this.loadingScreen.resetProgressAndMessage(I18n.format("forge.client.shutdown.internal"));
+	                }
+                    while (!Reflector.callBoolean(Reflector.ForgeIntegratedServer_isServerStopped, new Object[0]))
+	                {
+	                    try
+	                    {
+	                        Thread.sleep(10);
+	                    }
+	                    catch (InterruptedException ie) {}
+	                }				
+				}
+				/** END MINECRIFT FORGE **/
             }
 
             this.theIntegratedServer = null;
@@ -2290,6 +2879,15 @@
             this.mcResourcePackRepository.func_148529_f();
             this.setServerData((ServerData)null);
             this.integratedServerIsRunning = false;
+			/** MINECRIFT FORGE **/
+            Object fmlClientHandler = null;
+            if( Reflector.FMLClientHandler_instance.exists()) {
+                fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance, new Object[0]);
+            }
+            if( fmlClientHandler != null) {
+                Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_handleClientWorldClosing, new Object[]{this.theWorld});
+            }
+			/** END MINECRIFT FORGE **/
         }
 
         this.mcSoundHandler.stopSounds();
@@ -2406,10 +3004,12 @@
         return this.thePlayer != null ? this.thePlayer.sendQueue : null;
     }
 
+    /** MINECRIFT **/
     public static boolean isGuiEnabled()
     {
-        return theMinecraft == null || !theMinecraft.gameSettings.hideGUI;
+        return theMinecraft == null || !theMinecraft.vrSettings.hideGui;
     }
+    /** END MINECRIFT **/
 
     public static boolean isFancyGraphicsEnabled()
     {
@@ -2437,107 +3037,117 @@
             Item var2;
             int var5;
 
-            if (this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
-            {
-                var5 = this.objectMouseOver.blockX;
-                int var6 = this.objectMouseOver.blockY;
-                int var7 = this.objectMouseOver.blockZ;
-                Block var8 = this.theWorld.getBlock(var5, var6, var7);
-
-                if (var8.getMaterial() == Material.air)
-                {
-                    return;
-                }
-
-                var2 = var8.getItem(this.theWorld, var5, var6, var7);
-
-                if (var2 == null)
-                {
-                    return;
-                }
-
-                var4 = var2.getHasSubtypes();
-                Block var9 = var2 instanceof ItemBlock && !var8.isFlowerPot() ? Block.getBlockFromItem(var2) : var8;
-                var3 = var9.getDamageValue(this.theWorld, var5, var6, var7);
-            }
-            else
+			/** MINECRIFT FORGE **/
+			if (!Reflector.ForgeHooks_onPickBlock.exists())
+			{
+	            if (this.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK)
+	            {
+	                var5 = this.objectMouseOver.blockX;
+	                int var6 = this.objectMouseOver.blockY;
+	                int var7 = this.objectMouseOver.blockZ;
+	                Block var8 = this.theWorld.getBlock(var5, var6, var7);
+
+	                if (var8.getMaterial() == Material.air)
+	                {
+	                    return;
+	                }
+
+	                var2 = var8.getItem(this.theWorld, var5, var6, var7);
+
+	                if (var2 == null)
+	                {
+	                    return;
+	                }
+
+	                var4 = var2.getHasSubtypes();
+	                Block var9 = var2 instanceof ItemBlock && !var8.isFlowerPot() ? Block.getBlockFromItem(var2) : var8;
+	                var3 = var9.getDamageValue(this.theWorld, var5, var6, var7);
+	            }
+	            else
+	            {
+	                if (this.objectMouseOver.typeOfHit != MovingObjectPosition.MovingObjectType.ENTITY || this.objectMouseOver.entityHit == null || !var1)
+	                {
+	                    return;
+	                }
+
+	                if (this.objectMouseOver.entityHit instanceof EntityPainting)
+	                {
+	                    var2 = Items.painting;
+	                }
+	                else if (this.objectMouseOver.entityHit instanceof EntityLeashKnot)
+	                {
+	                    var2 = Items.lead;
+	                }
+	                else if (this.objectMouseOver.entityHit instanceof EntityItemFrame)
+	                {
+	                    EntityItemFrame var10 = (EntityItemFrame)this.objectMouseOver.entityHit;
+	                    ItemStack var12 = var10.getDisplayedItem();
+
+	                    if (var12 == null)
+	                    {
+	                        var2 = Items.item_frame;
+	                    }
+	                    else
+	                    {
+	                        var2 = var12.getItem();
+	                        var3 = var12.getMetadata();
+	                        var4 = true;
+	                    }
+	                }
+	                else if (this.objectMouseOver.entityHit instanceof EntityMinecart)
+	                {
+	                    EntityMinecart var11 = (EntityMinecart)this.objectMouseOver.entityHit;
+
+	                    if (var11.getMinecartType() == 2)
+	                    {
+	                        var2 = Items.furnace_minecart;
+	                    }
+	                    else if (var11.getMinecartType() == 1)
+	                    {
+	                        var2 = Items.chest_minecart;
+	                    }
+	                    else if (var11.getMinecartType() == 3)
+	                    {
+	                        var2 = Items.tnt_minecart;
+	                    }
+	                    else if (var11.getMinecartType() == 5)
+	                    {
+	                        var2 = Items.hopper_minecart;
+	                    }
+	                    else if (var11.getMinecartType() == 6)
+	                    {
+	                        var2 = Items.command_block_minecart;
+	                    }
+	                    else
+	                    {
+	                        var2 = Items.minecart;
+	                    }
+	                }
+	                else if (this.objectMouseOver.entityHit instanceof EntityBoat)
+	                {
+	                    var2 = Items.boat;
+	                }
+	                else
+	                {
+	                    var2 = Items.spawn_egg;
+	                    var3 = EntityList.getEntityID(this.objectMouseOver.entityHit);
+	                    var4 = true;
+
+	                    if (var3 <= 0 || !EntityList.entityEggs.containsKey(Integer.valueOf(var3)))
+	                    {
+	                        return;
+	                    }
+	                }
+	            }
+
+	            this.thePlayer.inventory.setCurrentItem(var2, var3, var4, var1);
+			}
+            else if (!Reflector.callBoolean(Reflector.ForgeHooks_onPickBlock, new Object[]{this.objectMouseOver,this.thePlayer,this.theWorld}))
             {
-                if (this.objectMouseOver.typeOfHit != MovingObjectPosition.MovingObjectType.ENTITY || this.objectMouseOver.entityHit == null || !var1)
-                {
-                    return;
-                }
-
-                if (this.objectMouseOver.entityHit instanceof EntityPainting)
-                {
-                    var2 = Items.painting;
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityLeashKnot)
-                {
-                    var2 = Items.lead;
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityItemFrame)
-                {
-                    EntityItemFrame var10 = (EntityItemFrame)this.objectMouseOver.entityHit;
-                    ItemStack var12 = var10.getDisplayedItem();
-
-                    if (var12 == null)
-                    {
-                        var2 = Items.item_frame;
-                    }
-                    else
-                    {
-                        var2 = var12.getItem();
-                        var3 = var12.getMetadata();
-                        var4 = true;
-                    }
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityMinecart)
-                {
-                    EntityMinecart var11 = (EntityMinecart)this.objectMouseOver.entityHit;
-
-                    if (var11.getMinecartType() == 2)
-                    {
-                        var2 = Items.furnace_minecart;
-                    }
-                    else if (var11.getMinecartType() == 1)
-                    {
-                        var2 = Items.chest_minecart;
-                    }
-                    else if (var11.getMinecartType() == 3)
-                    {
-                        var2 = Items.tnt_minecart;
-                    }
-                    else if (var11.getMinecartType() == 5)
-                    {
-                        var2 = Items.hopper_minecart;
-                    }
-                    else if (var11.getMinecartType() == 6)
-                    {
-                        var2 = Items.command_block_minecart;
-                    }
-                    else
-                    {
-                        var2 = Items.minecart;
-                    }
-                }
-                else if (this.objectMouseOver.entityHit instanceof EntityBoat)
-                {
-                    var2 = Items.boat;
-                }
-                else
-                {
-                    var2 = Items.spawn_egg;
-                    var3 = EntityList.getEntityID(this.objectMouseOver.entityHit);
-                    var4 = true;
-
-                    if (var3 <= 0 || !EntityList.entityEggs.containsKey(Integer.valueOf(var3)))
-                    {
-                        return;
-                    }
-                }
+                // We delete this code wholly instead of commenting it out, to make sure we detect changes in it between MC versions
+                return;
             }
-
-            this.thePlayer.inventory.setCurrentItem(var2, var3, var4, var1);
+			/** END MINECRIFT FORGE **/
 
             if (var1)
             {
@@ -2810,11 +3420,18 @@
         playerSnooper.addStatToSnooper("gl_max_texture_size", Integer.valueOf(getGLMaximumTextureSize()));
     }
 
+/** MINECRIFT */ // From Forge: Adds a optimization to the getGLMaximumTextureSize, only calculate it once.
+    private static int max_texture_size = -1;
     /**
      * Used in the usage snooper.
      */
     public static int getGLMaximumTextureSize()
     {
+        if (max_texture_size != -1)
+        {
+            return max_texture_size;
+        }
+
         for (int var0 = 16384; var0 > 0; var0 >>= 1)
         {
             GL11.glTexImage2D(GL11.GL_PROXY_TEXTURE_2D, 0, GL11.GL_RGBA, var0, var0, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, (ByteBuffer)null);
@@ -2822,12 +3439,14 @@
 
             if (var1 != 0)
             {
+                max_texture_size = var0;
                 return var0;
             }
         }
 
         return -1;
     }
+/** END MINECRIFT */
 
     /**
      * Returns whether snooping is enabled or not.
@@ -3134,4 +3753,1051 @@
             }
         }
     }
+
+	/** MINECRIFT ADDITIONS BELOW */
+
+
+    private void copyToMirror()
+    {
+        if (this.stereoProvider.providesMirrorTexture())
+        {
+            if (this.frameIndex % 3 == 0)  // Update every third frame
+            {
+                if (this.vrSettings.useDisplayMirroring)
+                {
+                    OpenGlHelper.func_153171_g(GL30.GL_READ_FRAMEBUFFER, mirrorFB.getFramebufferId());   // GL30.glBindFramebuffer
+                    OpenGlHelper.func_153171_g(GL30.GL_DRAW_FRAMEBUFFER, 0);   // GL30.glBindFramebuffer
+                    int w = displayFBWidth;
+                    int h = displayFBHeight;
+                    GL30.glBlitFramebuffer(0, h, w, 0,
+                                           0, 0, w, h,
+                                           GL11.GL_COLOR_BUFFER_BIT, GL11.GL_NEAREST);
+                    OpenGlHelper.func_153171_g(GL30.GL_READ_FRAMEBUFFER, 0);   // GL30.glBindFramebuffer
+
+                    Display.update();
+                }
+                else
+                {
+                    // Notify mirror is off!
+                    OpenGlHelper.func_153171_g(GL30.GL_DRAW_FRAMEBUFFER, 0);   // GL30.glBindFramebuffer
+                    GL11.glViewport(0, 0, this.displayFBWidth, this.displayFBHeight);
+
+                    if (entityRenderer != null)
+                        entityRenderer.displayNotificationText("Mirror is OFF", "", "", this.displayFBWidth, this.displayFBHeight, false, true);
+
+                    Display.update();
+                }
+            }
+        }
+	}
+
+    private void setupRenderConfiguration() throws Exception 
+    {
+        final float renderScaleFactor = this.vrSettings.renderScaleFactor;
+        boolean changeNonDestructiveRenderConfig = false;
+
+        glConfig.mirrorDisplay = this.vrSettings.useDisplayMirroring;
+        glConfig.usePositionalTimewarp = this.vrSettings.usePositionalTimewarp;
+        glConfig.worldScale = this.vrSettings.worldScale;
+
+        if (this.lastWorldScale != this.vrSettings.worldScale)
+        {
+            changeNonDestructiveRenderConfig = true;
+            this.lastWorldScale = this.vrSettings.worldScale;
+        }
+
+        if (clipPlanesChanged())
+        {
+            this.reinitFramebuffers = true;
+        }
+
+        if (!Display.isActive() && this.fullscreen)
+        {
+            this.toggleFullscreen();
+            this.reinitFramebuffers = true;
+        }
+
+        if (wasDisplayResized())
+        {
+            Display.update();     // This will set new display widths accordingly
+            this.reinitFramebuffers = true;
+        }
+
+        if (this.lastGuiScale != this.gameSettings.guiScale)
+        {
+            this.lastGuiScale = this.gameSettings.guiScale;
+            this.reinitFramebuffers = true;
+        }
+
+        if (!this.stereoProvider.isGuiOrtho()) {
+            showNativeMouseCursor(!Display.isActive());
+        }
+        else {
+            showNativeMouseCursor(true);
+        }
+
+        // Check for changes in window handle
+        glConfig = getLWJGLConfig(glConfig);
+        if (glConfig.Window != lastWindow)
+        {
+            this.reinitFramebuffers = true;
+            lastWindow = glConfig.Window;
+        }
+
+        if (lastShaderIndex != this.vrSettings.shaderIndex) {
+            this.reinitFramebuffers = true;
+        }
+
+        if (lastEnableMirror != this.vrSettings.useDisplayMirroring) {
+            this.reinitFramebuffers = true;
+            lastEnableMirror = this.vrSettings.useDisplayMirroring;
+        }
+
+        if (this.lastEnableVsync != this.gameSettings.enableVsync) {
+            this.reinitFramebuffers = true;
+        }
+
+        if (this.reinitFramebuffers)
+        {
+            this.visible = true;
+            this.checkGLError("Start Init");
+            
+            viewPortCount = 1;
+            float superSampleScaleFactor = 1f;
+            if (this.vrSettings.useFsaa)
+                superSampleScaleFactor = this.vrSettings.fsaaScaleFactor;
+
+            displayFBWidth = (Display.getWidth() < 1) ? 1 : Display.getWidth();
+            displayFBHeight = (Display.getHeight() < 1) ? 1 : Display.getHeight();
+            distortionRenderTargetSize[0] = new Sizei(displayFBWidth, displayFBHeight);
+            distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+            this.EyeTextureSize[0].w = this.displayWidth = (int)ceil((displayFBWidth * superSampleScaleFactor));
+            this.EyeTextureSize[0].h = this.displayHeight = (int)ceil((displayFBHeight * superSampleScaleFactor));
+            this.EyeTextureSize[1] = this.EyeTextureSize[0];
+
+            FovPort leftFov = null;
+            FovPort rightFov = null;
+
+            if (!this.stereoProvider.isInitialized()) {
+                throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getInitializationStatus());
+            }
+
+            // Scale up the FBO to allow for the distortion
+            if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+            {
+                leftFov = hmdInfo.getHMDInfo().DefaultEyeFov[0];
+                rightFov = hmdInfo.getHMDInfo().DefaultEyeFov[1];
+
+                System.out.println("L Fov:           " + leftFov.toString());
+                System.out.println("R Fov:           " + rightFov.toString());
+
+                RenderTextureInfo renderTextureInfo = this.stereoProvider.getRenderTextureSizes(leftFov, rightFov, renderScaleFactor);
+
+                distortionRenderTargetSize[0] = renderTextureInfo.LeftFovTextureResolution;
+                distortionRenderTargetSize[1] = distortionRenderTargetSize[0];
+                this.EyeTextureSize[0].w = (int)ceil(renderTextureInfo.LeftFovTextureResolution.w * superSampleScaleFactor);
+                this.EyeTextureSize[0].h = (int)ceil(renderTextureInfo.LeftFovTextureResolution.h * superSampleScaleFactor);
+                this.EyeTextureSize[1] = this.EyeTextureSize[0];
+
+                viewPortCount = 2;
+
+                // Oculus scaled render height seems ridiculous? For DK1, yes.
+            }
+
+            if (this.framebuffers[0] != null) {
+                this.framebuffers[0].deleteFramebuffer();
+                this.framebuffers[0] = null;
+            }
+
+            if (this.framebuffers[1] != null) {
+                this.framebuffers[1].deleteFramebuffer();
+                this.framebuffers[1] = null;
+            }
+
+            this.stereoProvider.deleteRenderTextures();
+
+            if (this.guiFramebuffer != null) {
+                this.guiFramebuffer.deleteFramebuffer();
+                this.guiFramebuffer = null;
+            }
+
+            if (this.loadingScreen != null) {
+                this.loadingScreen.deleteFramebuffer();
+            }
+
+            if (this.mirrorFB != null) {
+                this.mirrorFB.delete();
+                this.mirrorFB = null;
+            }
+
+            this.stereoProvider.deleteMirrorTexture();
+
+            if (this.fsaaFirstPassResultFBO[0] != null) {
+                this.fsaaFirstPassResultFBO[0].delete();
+                this.fsaaFirstPassResultFBO[0] = null;
+            }
+            if (this.fsaaFirstPassResultFBO[1] != null) {
+                this.fsaaFirstPassResultFBO[1].delete();
+                this.fsaaFirstPassResultFBO[1] = null;
+            }
+            if (this.fsaaSecondPassResultFBO[0] != null) {
+                this.fsaaSecondPassResultFBO[0].delete();
+                this.fsaaSecondPassResultFBO[0] = null;
+            }
+            if (this.fsaaSecondPassResultFBO[1] != null) {
+                this.fsaaSecondPassResultFBO[1].delete();
+                this.fsaaSecondPassResultFBO[1] = null;
+            }
+
+            _LanczosShader_texelWidthOffsetUniform = -1;
+            _LanczosShader_texelHeightOffsetUniform = -1;
+            _LanczosShader_inputImageTextureUniform = -1;
+
+            int multiSampleCount = 0;
+            boolean multiSample = (multiSampleCount > 0 ? true : false);
+            boolean genMipMaps = true;
+            this.entityRenderer.generatedIconMipmaps[0] = false;
+            this.entityRenderer.generatedIconMipmaps[1] = false;
+
+            if (this.stereoProvider.providesMirrorTexture() && this.vrSettings.useDisplayMirroring)
+            {
+                int mirrorTextureId = this.stereoProvider.createMirrorTexture(this.displayFBWidth, this.displayFBHeight);
+                if (mirrorTextureId == -1) {
+                    throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+                }
+                print("Provider supplied mirror texture ID: " + mirrorTextureId);
+
+                mirrorTexProvider.setTextureId(mirrorTextureId);
+                mirrorFB = new FBOParams("Mirror FBO", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, this.displayFBWidth, this.displayFBHeight, mirrorTexProvider);
+                System.out.println(mirrorFB.toString());
+            }
+            this.checkGLError("Mirror framebuffer setup");
+
+            if (this.stereoProvider.providesRenderTextures())
+            {
+                // Source render textures
+                RenderTextureSet renderTextures = this.stereoProvider.createRenderTextureSet(
+                        distortionRenderTargetSize[0].w,
+                        distortionRenderTargetSize[0].h,
+                        distortionRenderTargetSize[1].w,
+                        distortionRenderTargetSize[1].h);
+                if (renderTextures == null) {
+                    throw new RenderConfigException(RENDER_SETUP_FAILURE_MESSAGE + this.stereoProvider.getName(), this.stereoProvider.getLastError());
+                }
+                print("L Render texture resolution: " + distortionRenderTargetSize[0].w + " x " + distortionRenderTargetSize[0].h);
+                print("R Render texture resolution: " + distortionRenderTargetSize[1].w + " x " + distortionRenderTargetSize[1].h);
+                print("Provider supplied render texture IDs:\n" + renderTextures.toString());
+
+                renderTexProvider[0].setTextureIds(renderTextures.leftEyeTextureIds);
+                renderTexProvider[1].setTextureIds(renderTextures.rightEyeTextureIds);
+            }
+            else
+            {
+                // Generate our textures
+                renderTexProvider[0].genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, distortionRenderTargetSize[0].h, 1);
+                renderTexProvider[1].genTextureIds(GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, distortionRenderTargetSize[1].h, 1);
+            }
+            this.checkGLError("Render Texture setup");
+
+            
+            this.framebuffers[0] = new Framebuffer("L Eye", this.EyeTextureSize[0].w, this.EyeTextureSize[0].h, true, genMipMaps, multiSample, multiSampleCount, this.vrSettings.useFsaa ? null : renderTexProvider[0]);
+            print(this.framebuffers[0].toString());
+            this.checkGLError("Left Eye framebuffer setup");
+
+            this.framebuffers[1] = new Framebuffer("R Eye", this.EyeTextureSize[1].w, this.EyeTextureSize[1].h, true, genMipMaps, multiSample, multiSampleCount, this.vrSettings.useFsaa ? null : renderTexProvider[1]);
+            print(this.framebuffers[1].toString());
+            this.checkGLError("Right Eye framebuffer setup");
+
+            this.guiFramebuffer  = new Framebuffer("GUI", this.displayFBWidth, this.displayFBHeight, true, genMipMaps);
+            print(this.guiFramebuffer.toString());
+            this.checkGLError("GUI framebuffer setup");
+
+            this.framebuffers[0].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+            this.framebuffers[1].setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+            this.guiFramebuffer.setFramebufferColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 0.0F);
+
+            setupClipPlanes();
+
+            if (this.stereoProvider.isStereo() && this.stereoProvider.usesDistortion())
+            {
+                this.entityRenderer.eyeproj[EyeType.ovrEye_Left.value()] = this.stereoProvider.getProjectionMatrix(hmdInfo.getHMDInfo().DefaultEyeFov[0], this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+                this.entityRenderer.eyeproj[EyeType.ovrEye_Right.value()] = this.stereoProvider.getProjectionMatrix(hmdInfo.getHMDInfo().DefaultEyeFov[1], this.entityRenderer.minClipDistance, this.entityRenderer.clipDistance);
+            }
+
+            try
+            {
+                if (this.vrSettings.useFsaa)
+                {
+                    // GL21.GL_SRGB8_ALPHA8
+                    // GL11.GL_RGBA8
+
+                    // Lanczos downsample FBOs
+                    fsaaFirstPassResultFBO[0] = new FBOParams("FSAA Pass1 FBO1 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, this.EyeTextureSize[0].h, null);
+                    fsaaFirstPassResultFBO[1] = new FBOParams("FSAA Pass1 FBO2 ", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, this.EyeTextureSize[1].h, null);
+                    fsaaSecondPassResultFBO[0] = new FBOParams("FSAA Pass2 FBO1", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[0].w, distortionRenderTargetSize[0].h, renderTexProvider[0]);
+                    fsaaSecondPassResultFBO[1] = new FBOParams("FSAA Pass2 FBO2", GL11.GL_TEXTURE_2D, GL11.GL_RGBA8, GL11.GL_RGBA, GL11.GL_INT, distortionRenderTargetSize[1].w, distortionRenderTargetSize[1].h, renderTexProvider[1]);
+
+                    print(this.fsaaFirstPassResultFBO[0].toString());
+                    print(this.fsaaFirstPassResultFBO[1].toString());
+                    print(this.fsaaSecondPassResultFBO[0].toString());
+                    print(this.fsaaSecondPassResultFBO[1].toString());
+                    checkGLError("FSAA FBO creation");
+
+                    _Lanczos_shaderProgramId = ShaderHelper.initShaders(LANCZOS_SAMPLER_VERTEX_SHADER, LANCZOS_SAMPLER_FRAGMENT_SHADER, true);
+                    if (_Lanczos_shaderProgramId == 0) {
+                        throw new Exception("Failed to validate FSAA shader!");
+                    }
+
+                    ShaderHelper.checkGLError("@1");
+
+                    // Setup uniform IDs
+                    _LanczosShader_texelWidthOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelWidthOffset");
+                    _LanczosShader_texelHeightOffsetUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "texelHeightOffset");
+                    _LanczosShader_inputImageTextureUniform = ARBShaderObjects.glGetUniformLocationARB(_Lanczos_shaderProgramId, "inputImageTexture");
+
+                    ShaderHelper.checkGLError("FBO init Lanczos shader");
+                }
+            }
+            catch (Exception ex)
+            {
+                // We had an issue. Set the usual suspects to defaults...
+                this.vrSettings.useFsaa = false;
+                this.vrSettings.fsaaScaleFactor = 1.4f;
+                this.vrSettings.saveOptions();
+                System.out.println("[Minecrift] FAILED to setup FSAA: " + ex.getMessage());
+                reinitFramebuffers = true;
+                return;
+            }
+
+            // Init screen size
+            if (this.currentScreen != null)
+            {
+                ScaledResolution scaledresolution = new ScaledResolution(this,
+                        this.stereoProvider.isGuiOrtho() ? (int)Math.ceil(this.displayFBWidth * superSampleScaleFactor) : this.displayFBWidth,
+                        this.stereoProvider.isGuiOrtho() ? (int)Math.ceil(this.displayFBHeight * superSampleScaleFactor) : this.displayFBHeight);
+                int k = scaledresolution.getScaledWidth();
+                int l = scaledresolution.getScaledHeight();
+                this.currentScreen.setWorldAndResolution(this, k, l);
+            }
+            this.loadingScreen = new LoadingScreenRenderer(this, this.stereoProvider.isGuiOrtho() ? this.displayWidth : this.displayFBWidth, this.stereoProvider.isGuiOrtho() ? this.displayHeight : this.displayFBHeight);
+            this.loadingScreen.deleteFramebuffer();
+            if (this.stereoProvider.isGuiOrtho()) {
+                this.loadingScreen.renderTarget = this.getFramebuffer();
+            }
+            else {
+                this.loadingScreen.renderTarget = this.guiFramebuffer;
+            }
+
+            System.out.println("[Minecrift] New render config:" +
+                    "\nRender target width:  " + (this.stereoProvider.isStereo() ? this.EyeTextureSize[0].w + this.EyeTextureSize[1].w: this.displayWidth) +
+                    ", height: " + (this.stereoProvider.isStereo() ? Math.max(this.EyeTextureSize[0].h, this.EyeTextureSize[1].h) : this.displayHeight) +
+                    (this.stereoProvider.isStereo() ? " [Render scale: " + renderScaleFactor + "]" : "") +
+                    (this.vrSettings.useFsaa ? " [FSAA Scale: " + this.vrSettings.fsaaScaleFactor + "]" : "") +
+                    "\nDisplay target width: " + this.displayFBWidth + ", height: " + displayFBHeight);
+
+            // Init shaders
+            if (this.entityRenderer != null) {
+                if (shaderGroup[0] != null)
+                    shaderGroup[0].deleteShaderGroup();
+
+                if (shaderGroup[1] != null)
+                    shaderGroup[1].deleteShaderGroup();
+
+                lastShaderIndex = this.vrSettings.shaderIndex;
+                shaderGroup[0] = this.entityRenderer.initShaderGroup(framebuffers[0]);
+                shaderGroup[1] = this.entityRenderer.initShaderGroup(framebuffers[1]);
+            }
+
+            this.lastDisplayFBWidth = this.displayFBWidth;
+            this.lastDisplayFBHeight = this.displayFBHeight;
+            this.lastEnableVsync = this.gameSettings.enableVsync;
+            this.reinitFramebuffers = false;
+
+            if (this.firstInit)
+            {
+                // Workaround for bad init of Oculus SDK
+                this.firstInit = false;
+                this.reinitFramebuffers = true;
+                System.out.println("[Minecrift] Now re-init for Oculus SDK weirdness...");
+            }
+        }
+
+        if (changeNonDestructiveRenderConfig || this.reinitFramebuffers)
+        {
+            this.stereoProvider.configureRenderer(glConfig);
+        }
+    }
+
+    public void setupClipPlanes()
+    {
+        this.entityRenderer.farPlaneDistance = (float)(this.gameSettings.renderDistanceChunks * 16);
+
+        if (Config.isFogFancy())
+        {
+            this.entityRenderer.farPlaneDistance *= 0.95F;
+        }
+
+        if (Config.isFogFast())
+        {
+            this.entityRenderer.farPlaneDistance *= 0.83F;
+        }
+
+        this.entityRenderer.clipDistance = this.entityRenderer.farPlaneDistance * 2.0F;
+
+        if (this.entityRenderer.clipDistance < 128.0F)
+        {
+            this.entityRenderer.clipDistance = 128.0F;
+        }
+
+        if (this.theWorld != null && this.theWorld.provider != null && this.theWorld.provider.dimensionId == 1)
+        {
+            this.entityRenderer.clipDistance = 256.0F;
+        }
+    }
+
+    public boolean clipPlanesChanged()
+    {
+        boolean changed = false;
+
+        if (this.theWorld != null && this.theWorld.provider != null)
+        {
+            if (this.theWorld.provider.dimensionId != this.lastDimensionId)
+            {
+                //changed = true;   // TODO: Re-enable when Lib OVR doesn't crash all the bloody time. We
+                                    // can't currently change render config in-game, without a crash in
+                                    // nvgl.dll glDrawArrays
+            }
+        }
+
+        if( this.gameSettings.renderDistanceChunks != this.lastRenderDistanceChunks ||
+            Config.isFogFancy() != this.lastFogFancy                                ||
+            Config.isFogFast() != this.lastFogFast)
+        {
+            changed = true;
+        }
+
+        lastRenderDistanceChunks = this.gameSettings.renderDistanceChunks;
+        lastFogFancy = Config.isFogFancy();
+        lastFogFast = Config.isFogFast();
+        if (this.theWorld != null && this.theWorld.provider != null)
+            lastDimensionId = this.theWorld.provider.dimensionId;
+
+        return changed;
+    }
+
+    public GLConfig getLWJGLConfig(GLConfig glConfig)
+    {
+        // TODO: For LWJGL 3.0, this function may well be screwed...
+
+        // We need to retrieve certain pointers / handles from LWJGL
+        // for the Oculus SDK. However, these are not exposed by
+        // LWJGL, so use reflection to get hold of the data we need.
+
+        try
+        {
+            switch(LWJGLUtil.getPlatform())
+            {
+                case LWJGLUtil.PLATFORM_WINDOWS:
+                {
+                    // Get HWND pointer...
+                    if (fieldHwnd == null)
+                    {
+                        fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+                        fieldHwnd.setAccessible(true);
+                    }
+                    glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+                    //System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+                    break;
+                }
+                case LWJGLUtil.PLATFORM_LINUX:
+                {
+                    // Get Display and Window pointers...
+                    if (fieldDisplay == null)
+                    {
+                        fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+                        fieldDisplay.setAccessible(true);
+                    }
+                    if (fieldWindow == null)
+                    {
+                        fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+                        fieldWindow.setAccessible(true);
+                    }
+                    glConfig.Display = (Long) fieldDisplay.get(null);
+                    glConfig.Window = (Long) fieldWindow.get(null);
+                    //System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+                    //System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+                    break;
+                }
+                case LWJGLUtil.PLATFORM_MACOSX:
+                {
+                    // Do nowt...
+                    break;
+                }
+                default:
+                    throw new Exception ("Current platform not supported!");
+            }
+        }
+        catch (Exception ex)
+        {
+            ex.printStackTrace();
+            glConfig = null;
+        }
+
+        return glConfig;
+    }
+
+    public boolean wasDisplayResized()
+    {
+        boolean wasResized = false;
+
+        // We don't want to have to call Display.update() just to determine
+        // if the display has been resized - this will invoke a swapBuffer.
+
+        switch(LWJGLUtil.getPlatform())
+        {
+            case LWJGLUtil.PLATFORM_WINDOWS:
+            case LWJGLUtil.PLATFORM_LINUX: {
+                // Get the 'resized' field from the Display class...
+                try {
+                    if (fieldResized == null) {
+                        fieldResized = displayImpl.getClass().getDeclaredField("resized");
+                        fieldResized.setAccessible(true);
+                    }
+                    wasResized = (Boolean) fieldResized.get(displayImpl);
+                } catch (Exception e) {
+                    System.out.println(displayImpl.getClass().getName());
+                    e.printStackTrace();
+                }
+            }
+            break;
+            case LWJGLUtil.PLATFORM_MACOSX: {
+                // Get the 'wasResized' method from the Display class...
+                try {
+                    if (fieldResizedMethod == null) {
+                        fieldResizedMethod = displayImpl.getClass().getDeclaredMethod("wasResized");
+                        fieldResizedMethod.setAccessible(true);
+                    }
+                    wasResized = (Boolean) fieldResizedMethod.invoke(displayImpl);
+                } catch (Exception e) {
+                    System.out.println(displayImpl.getClass().getName());
+                    e.printStackTrace();
+                }
+            }
+            break;
+        }
+
+        if (wasResized)
+            System.out.println("Display resized");
+
+        return wasResized;
+    }
+
+    public void initMinecrift() throws Exception
+    {
+        this.lastGuiScale = this.gameSettings.guiScale;
+
+        // Get underlying LWJGL Display implementation
+        if (displayImpl == null)
+        {
+            try {
+                Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+                displayMethod.setAccessible(true);
+                displayImpl = displayMethod.invoke(null, null);
+                System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        try {
+            Class.forName("com.mtbs3d.minecrift.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+            hydraLibsAvailable = true;
+        } catch (NoClassDefFoundError e1) {
+            System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+        } catch( Exception e1) {
+            System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+        }
+
+        // #85 Allow disable mumblelib load
+        if (this.vrSettings.loadMumbleLib) {
+            try {
+                MumbleLink.loadLibrary();
+                mumbleLink = new MumbleLink("MinecraftVR", "Minecraft VR");
+                mumbleLink.setIdentityAndContext(this.session.getUsername(), "Minecraft"/*TODO: get the servername? */);
+            } catch (Exception e) {
+                System.err.println("Couldn't load [MumbleLink library]: " + e.toString());
+            }
+        }
+        else {
+            System.err.println("Skipping loading: [MumbleLink library]: Configuration setting disabled loading");
+        }
+
+        GuiScreenNavigator.initGuiLeftTop();
+
+        oculusInit();
+        new MCController();
+        new MCMouse();
+        ControlBinding.CreateBindingList(this.gameSettings); // Create control binding list
+        new NeckModelEyePosition();                          // Create and register "None" head position plugin
+        new NullStereoRenderer();                            // Create and register "None" stereo renderer plugin
+
+        initPlugins();
+
+        nativeMouseCursor = Mouse.getNativeCursor();
+        try {
+            invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+        } catch (LWJGLException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void initPlugins() throws Exception
+    {
+        hmdInfo           = PluginManager.configureHMD(this.vrSettings.hmdPluginID);
+        headTracker       = PluginManager.configureOrientation(this.vrSettings.headTrackerPluginID);
+        positionTracker   = PluginManager.configurePosition(this.vrSettings.headPositionPluginID);
+        lookaimController = PluginManager.configureController("mouse"); // Always configure mouse
+        lookaimController = PluginManager.configureController(this.vrSettings.controllerPluginID);
+        stereoProvider    = PluginManager.configureStereoProvider(this.vrSettings.stereoProviderPluginID);
+    }
+
+    public void printChatMessage(String msg)
+    {
+        if (this.theWorld != null) {
+            ChatComponentText chatText = new ChatComponentText("\u00a7e[Minecrift]: " + msg + "\u00a7f");
+            this.ingameGUI.getChatGUI().printChatMessage(chatText);
+        }
+    }
+
+    public void showNativeMouseCursor(boolean show)
+    {
+        if (show == lastShowMouseNative)
+            return;
+
+        lastShowMouseNative = show;
+
+        try
+        {
+            if (show)
+            {
+                Mouse.setNativeCursor(nativeMouseCursor);
+            }
+            else
+            {
+                Mouse.setNativeCursor(invisibleMouseCursor);
+            }
+        }
+        catch (LWJGLException e)
+        {
+            e.printStackTrace();
+        }
+    }
+
+    public void oculusInit() throws Exception
+    {
+        this.EyeTextureSize[0] = new Sizei();
+        this.EyeTextureSize[1] = new Sizei();
+
+        // Initialise Oculus library
+
+        OculusRift.LoadLibrary();
+        PluginManager.register(new MCOculus()); // create and register new plugin
+        hmdInfo = PluginManager.configureHMD("oculus");
+    }
+
+    public Posef getEyePose(EyeType eye)
+    {
+        Posef eyePose = new Posef();
+
+        // Get orientation first...
+        if (this.headTracker != null && this.headTracker.isInitialized())
+        {
+            Quaternion orient = this.headTracker.getOrientationQuaternion(eye);
+            if (orient != null) {
+                eyePose.Orientation.x = orient.x;
+                eyePose.Orientation.y = orient.y;
+                eyePose.Orientation.z = orient.z;
+                eyePose.Orientation.w = orient.w;
+            }
+        }
+
+        // ...as some position providers also require orientation information (I'm looking
+        // at you, Hydra!)
+        if (positionTracker != null && this.positionTracker.isInitialized())
+        {
+            Vec3 pos = positionTracker.getEyePosition(eye);
+            if (pos != null)
+            {
+                eyePose.Position.x = (float) pos.xCoord;
+                eyePose.Position.y = (float) pos.yCoord;
+                eyePose.Position.z = (float) pos.zCoord;
+            }
+        }
+
+        return eyePose;
+    }
+
+    public boolean endFrame()
+    {
+        if (this.stereoProvider != null)
+            return this.stereoProvider.endFrame();
+
+        return true;
+    }
+
+    public double getCurrentTimeSecs()
+    {
+        return this.stereoProvider.getCurrentTimeSecs();
+    }
+
+    private void doPostProcessing(long frameIndex, EyeType eye)
+    {
+        if (showSplashScreen && splashFadeAlpha > 0)
+        {
+            final Color3f rgb = new Color3f(0f, 0f, 0f);
+            this.entityRenderer.renderFadeBlend(rgb, splashFadeAlpha);
+        }
+
+        if (this.vrSettings.useFsaa)
+        {
+            GL11.glDisable(GL11.GL_ALPHA_TEST);
+            GL11.glDisable(GL11.GL_BLEND);
+
+            // Setup ortho projection
+            GL11.glMatrixMode(GL11.GL_PROJECTION);
+            GL11.glLoadIdentity();
+            GL11.glMatrixMode(GL11.GL_MODELVIEW);
+            GL11.glLoadIdentity();
+
+            GL11.glTranslatef(0.0f, 0.0f, -0.7f);
+
+            // Now switch to 1st pass FSAA result target framebuffer
+            this.fsaaFirstPassResultFBO[eye.value()].bindRenderTarget();
+
+            // Bind the FBO
+            this.framebuffers[eye.value()].bindFramebufferTexture();
+
+            GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+            GL11.glClearDepth(1.0D);
+            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);            // Clear Screen And Depth Buffer on the framebuffer
+
+            // Render onto the entire screen framebuffer
+            GL11.glViewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.EyeTextureSize[eye.value()].h);
+
+            // Set the downsampling shader as in use
+            ARBShaderObjects.glUseProgramObjectARB(_Lanczos_shaderProgramId);
+
+            // Set up the fragment shader uniforms
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].w));
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 0.0f);
+            ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
+
+            // Pass 1
+            drawQuad();
+
+            // checkGLError("After Lanczos Pass1");
+
+            // Pass 2
+            // Now switch to 2nd pass screen framebuffer
+            if (this.stereoProvider.isStereo())
+            {
+                fsaaSecondPassResultFBO[eye.value()].bindRenderTarget();
+                fsaaSecondPassResultFBO[eye.value()].selectTexture();
+            }
+            else
+            {
+                this.framebufferMc.unbindFramebuffer();
+            }
+
+            fsaaFirstPassResultFBO[eye.value()].bindTexture();
+
+            GL11.glViewport(0, 0, this.distortionRenderTargetSize[eye.value()].w, this.distortionRenderTargetSize[eye.value()].h);
+            GL11.glClearColor(RED_COLOUR_COMPONENT, GREEN_COLOUR_COMPONENT, BLUE_COLOUR_COMPONENT, 1.0f);
+            GL11.glClearDepth(1.0D);
+            GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+            // Bind the texture
+            GL13.glActiveTexture(GL13.GL_TEXTURE0);
+
+            // Set up the fragment shader uniforms for pass 2
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelWidthOffsetUniform, 0.0f);
+            ARBShaderObjects.glUniform1fARB(_LanczosShader_texelHeightOffsetUniform, 1.0f / (3.0f * (float) this.distortionRenderTargetSize[eye.value()].h));
+            ARBShaderObjects.glUniform1iARB(_LanczosShader_inputImageTextureUniform, 0);
+
+            drawQuad();
+
+            // Stop shader use
+            ARBShaderObjects.glUseProgramObjectARB(0);
+            // checkGLError("After Lanczos Pass2");
+
+            GL11.glEnable(GL11.GL_ALPHA_TEST);
+            GL11.glEnable(GL11.GL_BLEND);
+        }
+        else if (!this.stereoProvider.isStereo())
+        {
+            this.framebufferMc.unbindFramebuffer();
+            this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
+        }
+    }
+
+    public void drawQuad()
+    {
+        // this func just draws a perfectly normal box with some texture coordinates
+        GL11.glBegin(GL11.GL_QUADS);
+
+        // Front Face
+        GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+        GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+        GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+        GL11.glEnd();
+    }
+
+    public void showSplash(Framebuffer rendertarget)
+    {
+        final int SPLASH_TIMEOUT_MS = this.stereoProvider.isStereo() ? 2000 : 1500;
+        final int SPLASH_FADE_TIMEOUT_MS = this.stereoProvider.isStereo() ? 1000 : 0;
+        splashFadeAlpha = 0f;
+        final long currentTimeMs = System.currentTimeMillis();
+
+        // Start display splash timer (only after any calibration has finished)
+        if (this.entityRenderer.calibrationHelper == null && splashTimer1 == 0 && splashTimer2 == 0)
+        {
+            splashTimer1 = currentTimeMs;
+        }
+
+        RED_COLOUR_COMPONENT = 1f;
+        GREEN_COLOUR_COMPONENT = 1f;
+        BLUE_COLOUR_COMPONENT = 1f;
+
+        // Start fade timer
+        if (splashTimer1 != 0 && (currentTimeMs > splashTimer1 + SPLASH_TIMEOUT_MS))
+        {
+            splashTimer1 = 0;
+            splashTimer2 = currentTimeMs;
+        }
+
+        // Continue or end fade
+        if (splashTimer2 != 0 && (currentTimeMs < splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+        {
+            splashFadeAlpha = (100f / SPLASH_FADE_TIMEOUT_MS) * (currentTimeMs - splashTimer2) * 0.01f;
+        }
+        else if (splashTimer2 != 0 && (currentTimeMs >= splashTimer2 + SPLASH_FADE_TIMEOUT_MS))
+        {
+            this.showSplashScreen = false;
+            splashFadeAlpha = this.stereoProvider.isStereo() ? 1f : 0f;
+            RED_COLOUR_COMPONENT = OCULUS_RED_COLOUR_COMPONENT;
+            GREEN_COLOUR_COMPONENT = OCULUS_GREEN_COLOUR_COMPONENT;
+            BLUE_COLOUR_COMPONENT = OCULUS_BLUE_COLOUR_COMPONENT;
+        }
+
+        int existingScale = gameSettings.guiScale;
+        gameSettings.guiScale = 0;
+        ScaledResolution var1 = new ScaledResolution(this, this.displayWidth, this.displayHeight);
+        int var2 = var1.getScaleFactor();
+        if (splash == null)
+            splash = new Framebuffer(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2, true);
+        splash.bindFramebuffer(true);
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
+        GL11.glLoadIdentity();
+        GL11.glOrtho(0.0D, (double) var1.getScaledWidth(), (double) var1.getScaledHeight(), 0.0D, 1000.0D, 3000.0D);
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
+        GL11.glLoadIdentity();
+        GL11.glTranslatef(0.0F, 0.0F, -2000.0F);
+        GL11.glDisable(GL11.GL_LIGHTING);
+        GL11.glDisable(GL11.GL_FOG);
+        GL11.glDisable(GL11.GL_DEPTH_TEST);
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+
+        try
+        {
+            if (this.mojangLogo == null)
+                this.mojangLogo = this.renderEngine.getDynamicTextureLocation("logo", new DynamicTexture(ImageIO.read(this.mcDefaultResourcePack.getInputStream(this.locationMojangPng))));
+            this.renderEngine.bindTexture(this.mojangLogo);
+        }
+        catch (IOException var7)
+        {
+            logger.error("Unable to load logo: " + locationMojangPng, var7);
+        }
+
+        Tessellator var4 = Tessellator.instance;
+        var4.startDrawingQuads();
+        var4.setColorOpaque_I(16777215);
+        var4.addVertexWithUV(0.0D, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+        var4.addVertexWithUV((double)this.displayWidth, (double)this.displayHeight, 0.0D, 0.0D, 0.0D);
+        var4.addVertexWithUV((double) this.displayWidth, 0.0D, 0.0D, 0.0D, 0.0D);
+        var4.addVertexWithUV(0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+        var4.draw();
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        var4.setColorOpaque_I(16777215);
+        short var5 = 256;
+        short var6 = 256;
+        this.scaledTessellator((var1.getScaledWidth() - var5) / 2, (var1.getScaledHeight() - var6) / 2, 0, 0, var5, var6);
+        GL11.glDisable(GL11.GL_LIGHTING);
+        GL11.glDisable(GL11.GL_FOG);
+        rendertarget.bindFramebuffer(true);
+        splash.framebufferRender(var1.getScaledWidth() * var2, var1.getScaledHeight() * var2);
+        GL11.glEnable(GL11.GL_ALPHA_TEST);
+        GL11.glAlphaFunc(GL11.GL_GREATER, 0.1F);
+        //GL11.glFlush();
+        //Display.update();
+        gameSettings.guiScale = existingScale;
+        //this.func_147120_f();
+    }
+
+    private static void sleepNanos (long nanoDelay)
+    {
+        final long end = System.nanoTime() + nanoDelay;
+        do
+        {
+            Thread.yield();  // This is a busy wait sadly...
+        }
+        while (System.nanoTime() < end);
+    }
+
+    private void addRunTickTimeNanos(long runTickTime)
+    {
+        int i = 0;
+        medianRunTickTimeNanos = runTickTime;
+
+        if (this.vrSettings.smoothRunTickCount < 1)
+            this.vrSettings.smoothRunTickCount = 1;
+
+        if (this.vrSettings.smoothRunTickCount % 2 == 0)
+        {
+            // Need an odd number for this
+            this.vrSettings.smoothRunTickCount++;
+        }
+
+        runTickTimeNanos.addFirst(runTickTime);
+        while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+            runTickTimeNanos.removeLast();
+
+        if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+        {
+            Long[] array = new Long[runTickTimeNanos.size()];
+            for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++)
+            {
+                array[i] = (Long)itr.next();
+            }
+            Arrays.sort(array);
+            medianRunTickTimeNanos = array[array.length / 2];
+        }
+    }
+
+    private long getMedianRunTickTimeNanos()
+    {
+        return medianRunTickTimeNanos;
+    }
+
+    public final String LANCZOS_SAMPLER_VERTEX_SHADER =
+            "#version 120\n" +
+                    "\n" +
+                    " uniform float texelWidthOffset;\n" +
+                    " uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    " varying vec2 centerTextureCoordinate;\n" +
+                    " varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 oneStepRightTextureCoordinate;\n" +
+                    " varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    " varying vec2 threeStepsRightTextureCoordinate;\n" +
+                    " varying vec2 fourStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     gl_Position = ftransform();\n" +
+                    "\n" +
+                    "     vec2 firstOffset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "     vec2 secondOffset = vec2(2.0 * texelWidthOffset, 2.0 * texelHeightOffset);\n" +
+                    "     vec2 thirdOffset = vec2(3.0 * texelWidthOffset, 3.0 * texelHeightOffset);\n" +
+                    "     vec2 fourthOffset = vec2(4.0 * texelWidthOffset, 4.0 * texelHeightOffset);\n" +
+                    "\n" +
+                    "     vec2 textCoord = gl_MultiTexCoord0.xy;\n" +
+                    "     centerTextureCoordinate = textCoord;\n" +
+                    "     oneStepLeftTextureCoordinate = textCoord - firstOffset;\n" +
+                    "     twoStepsLeftTextureCoordinate = textCoord - secondOffset;\n" +
+                    "     threeStepsLeftTextureCoordinate = textCoord - thirdOffset;\n" +
+                    "     fourStepsLeftTextureCoordinate = textCoord - fourthOffset;\n" +
+                    "     oneStepRightTextureCoordinate = textCoord + firstOffset;\n" +
+                    "     twoStepsRightTextureCoordinate = textCoord + secondOffset;\n" +
+                    "     threeStepsRightTextureCoordinate = textCoord + thirdOffset;\n" +
+                    "     fourStepsRightTextureCoordinate = textCoord + fourthOffset;\n" +
+                    " }\n";
+
+    public final String LANCZOS_SAMPLER_FRAGMENT_SHADER =
+
+            "#version 120\n" +
+                    "\n" +
+                    " uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    " varying vec2 centerTextureCoordinate;\n" +
+                    " varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    " varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 threeStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 fourStepsLeftTextureCoordinate;\n" +
+                    " varying vec2 oneStepRightTextureCoordinate;\n" +
+                    " varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    " varying vec2 threeStepsRightTextureCoordinate;\n" +
+                    " varying vec2 fourStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    " // sinc(x) * sinc(x/a) = (a * sin(pi * x) * sin(pi * x / a)) / (pi^2 * x^2)\n" +
+                    " // Assuming a Lanczos constant of 2.0, and scaling values to max out at x = +/- 1.5\n" +
+                    "\n" +
+                    " void main()\n" +
+                    " {\n" +
+                    "     vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.38026;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.27667;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.27667;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.08074;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, threeStepsRightTextureCoordinate) * -0.02612;\n" +
+                    "\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n" +
+                    "     fragmentColor += texture2D(inputImageTexture, fourStepsRightTextureCoordinate) * -0.02143;\n" +
+                    "\n" +
+                    "     gl_FragColor = fragmentColor;\n" +
+                    " }\n";
+
+    public void enableGuiSizeHack()
+    {
+        this.currentDisplayWidth = this.displayWidth;
+        this.currentDisplayHeight = this.displayHeight;
+
+        float superSampleScaleFactor = 1f;
+        if (this.vrSettings.useFsaa)
+            superSampleScaleFactor = this.vrSettings.fsaaScaleFactor;
+
+        // Hack the GUI w & h
+        if (!this.stereoProvider.isGuiOrtho()) {
+            this.displayWidth = this.displayFBWidth;
+            this.displayHeight = this.displayFBHeight;
+        }
+        else {
+            this.displayWidth = (int)Math.ceil(this.displayFBWidth * superSampleScaleFactor);
+            this.displayHeight = (int)Math.ceil(this.displayFBHeight * superSampleScaleFactor);
+        }
+    }
+
+    public void disableGuiSizeHack()
+    {
+        this.displayWidth = this.currentDisplayWidth;
+        this.displayHeight = this.currentDisplayHeight;
+    }
+
+    public void print(String s)
+    {
+        s = s.replace("\n", "\n[Minecrift] ");
+        System.out.println("[Minecrift] " + s);
+    }
 }
